import { jest, describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
import { QuotaAdvancedService, quotaAdvancedService } from '../QuotaAdvancedService';

// Disable MSW for this test file to avoid response.body.getReader issues
beforeAll(() => {
    try {
        // Try to import and close the server if it exists
        const { server } = require('@/tests/mocks/server');
        if (server && typeof server.close === 'function') {
            server.close();
        }
    } catch (error) {
        // MSW not available, continue
    }
});

// MODIFIÉ: Plus besoin d'importer les types pour les mocks de fonctions ici
// import * as quotaServiceTypes from '../quotaService';
// import * as leaveServiceTypes from '../leaveService';

import AuditService from '@/services/AuditService';
import EventBusService from '@/services/eventBusService';
import { LeaveType, LeaveBalance } from '@/modules/leaves/types/leave';
import {
    QuotaTransferRule,
    QuotaCarryOverRule,
    QuotaTransferRuleType,
    QuotaCarryOverRuleType
} from '@/modules/leaves/types/quota';
import { addMonths } from '@/utils/dateUtils';
import { QuotaTransactionStatus } from '@/modules/leaves/types/quota';
import { QuotaCarryOverCalculationResult } from '@/modules/leaves/types/quota';

// --- Mocks manuels --- 
// Pour leaveService
jest.mock('../leaveService', () => ({
    __esModule: true,
    fetchLeaveBalance: jest.fn(),
}));

// Pour quotaService
jest.mock('../quotaService', () => ({
    __esModule: true,
    fetchActiveTransferRulesForUser: jest.fn(),
    fetchActiveCarryOverRulesForUser: jest.fn(),
    fetchTransferHistory: jest.fn(),
    fetchCarryOverHistory: jest.fn(),
}));

import { fetchLeaveBalance } from '../leaveService';
import {
    fetchActiveTransferRulesForUser,
    fetchActiveCarryOverRulesForUser,
    fetchTransferHistory,
    fetchCarryOverHistory
} from '../quotaService';

const mockFetchLeaveBalanceRef = fetchLeaveBalance as jest.MockedFunction<typeof fetchLeaveBalance>;
const mockFetchActiveTransferRulesForUserRef = fetchActiveTransferRulesForUser as jest.MockedFunction<typeof fetchActiveTransferRulesForUser>;
const mockFetchActiveCarryOverRulesForUserRef = fetchActiveCarryOverRulesForUser as jest.MockedFunction<typeof fetchActiveCarryOverRulesForUser>;
const mockFetchTransferHistoryRef = fetchTransferHistory as jest.MockedFunction<typeof fetchTransferHistory>;
const mockFetchCarryOverHistoryRef = fetchCarryOverHistory as jest.MockedFunction<typeof fetchCarryOverHistory>;

// Mock the local AuditService (the one imported in QuotaAdvancedService)
jest.mock('../AuditService', () => {
    const mockAuditInstance = {
        logAction: jest.fn().mockResolvedValue(undefined),
        createAuditEntry: jest.fn().mockResolvedValue({ id: 'mock-audit-id' })
    };
    
    const MockAuditService = jest.fn().mockImplementation(() => mockAuditInstance);
    MockAuditService.getInstance = jest.fn().mockReturnValue(mockAuditInstance);
    
    return {
        __esModule: true,
        AuditService: MockAuditService,
        AuditActionType: {
            QUOTA_TRANSFERRED: 'QUOTA_TRANSFERRED',
            QUOTA_CARRIED_OVER: 'QUOTA_CARRIED_OVER'
        },
        AuditSeverity: {
            LOW: 'LOW',
            MEDIUM: 'MEDIUM',
            HIGH: 'HIGH'
        },
        auditService: mockAuditInstance
    };
});

// Also mock the services AuditService for completeness
jest.mock('@/services/AuditService', () => ({
    __esModule: true,
    default: {
        getInstance: jest.fn().mockReturnValue({
            logAction: jest.fn().mockResolvedValue(undefined),
            createAuditEntry: jest.fn().mockResolvedValue({ id: 'mock-audit-id' })
        })
    }
}));

jest.mock('@/services/eventBusService', () => ({
    __esModule: true,
    default: {
        getInstance: jest.fn().mockReturnValue({
            publish: jest.fn(),
            subscribe: jest.fn()
        })
    }
}));

jest.mock('@/utils/dateUtils', () => ({
    formatDate: jest.fn((date: string | number | Date): string => new Date(date).toLocaleDateString()),
    addMonths: jest.fn((date: string | number | Date, months: number): Date => {
        const newDate = new Date(date);
        newDate.setMonth(newDate.getMonth() + months);
        return newDate;
    }),
    getDaysUntil: jest.fn((): number => 15),
    isDateInFuture: jest.fn().mockImplementation(() => true)
}));

// Mock the eventBus import
jest.mock('../../../integration/services/EventBusService', () => ({
    eventBus: {
        publish: jest.fn(),
        subscribe: jest.fn(),
        unsubscribe: jest.fn()
    },
    IntegrationEventType: {
        QUOTA_TRANSFERRED: 'QUOTA_TRANSFERRED',
        QUOTA_CARRIED_OVER: 'QUOTA_CARRIED_OVER'
    }
}));

// Also mock the EventBusService from services
jest.mock('@/services/eventBusService', () => ({
    EventBusService: {
        getInstance: jest.fn().mockReturnValue({
            publish: jest.fn(),
            subscribe: jest.fn(),
            unsubscribe: jest.fn()
        })
    }
}));

// Mock axios to handle AuditService HTTP calls
jest.mock('axios', () => {
    const mockAxiosInstance = {
        post: jest.fn().mockResolvedValue({
            data: { id: 'mock-audit-id', success: true },
            status: 201,
            statusText: 'Created'
        }),
        get: jest.fn().mockResolvedValue({
            data: { success: true },
            status: 200,
            statusText: 'OK'
        }),
        put: jest.fn().mockResolvedValue({
            data: { success: true },
            status: 200,
            statusText: 'OK'
        }),
        delete: jest.fn().mockResolvedValue({
            data: { success: true },
            status: 200,
            statusText: 'OK'
        }),
        interceptors: {
            request: {
                use: jest.fn(),
                eject: jest.fn()
            },
            response: {
                use: jest.fn(),
                eject: jest.fn()
            }
        }
    };

    return {
        __esModule: true,
        default: {
            ...mockAxiosInstance,
            create: jest.fn(() => mockAxiosInstance)
        }
    };
});

const mockUserId = 'user-123';
const mockYear = 2024;

const mockLeaveBalance = {
    userId: mockUserId,
    year: mockYear,
    balances: {
        [LeaveType.ANNUAL]: {
            initial: 25,
            used: 5,
            pending: 2,
            remaining: 18,
            acquired: 25,
        },
        [LeaveType.RECOVERY]: {
            initial: 10,
            used: 3,
            pending: 0,
            remaining: 7,
            acquired: 10,
        },
    },
    lastUpdated: new Date().toISOString(),
} as unknown as LeaveBalance;

const mockTransferRules: QuotaTransferRule[] = [
    {
        id: 'rule-1',
        fromType: LeaveType.RECOVERY,
        toType: LeaveType.ANNUAL,
        conversionRate: 1,
        maxTransferDays: 5,
        requiresApproval: false,
        isActive: true,
        ruleType: QuotaTransferRuleType.STANDARD,
        maxTransferPercentage: undefined,
        authorizedRoles: undefined,
        departmentId: undefined,
        applicableUserRoles: undefined,
        minimumRemainingDays: undefined,
        metadata: undefined,
    },
    {
        id: 'rule-2',
        fromType: LeaveType.ANNUAL,
        toType: LeaveType.RECOVERY,
        conversionRate: 0.5,
        maxTransferPercentage: 10,
        requiresApproval: true,
        authorizedRoles: ['manager'],
        isActive: true,
        ruleType: QuotaTransferRuleType.ROLE_BASED,
        maxTransferDays: undefined,
        departmentId: undefined,
        applicableUserRoles: undefined,
        minimumRemainingDays: undefined,
        metadata: undefined,
    }
];

const mockCarryOverRules: QuotaCarryOverRule[] = [
    {
        id: 'carry-rule-1',
        leaveType: LeaveType.ANNUAL,
        ruleType: QuotaCarryOverRuleType.PERCENTAGE,
        value: 50,
        maxCarryOverDays: 10,
        expirationDays: 90,
        requiresApproval: false,
        isActive: true,
        authorizedRoles: undefined,
        departmentId: undefined,
        applicableUserRoles: undefined,
        metadata: undefined,
    }
];

const mockTransferHistoryData = [
    {
        id: 'transfer-1',
        userId: 'user-123',
        sourceType: LeaveType.RECOVERY,
        targetType: LeaveType.ANNUAL,
        sourceAmount: 2,
        targetAmount: 1.6,
        ratio: 0.8,
        ruleApplied: 'rule-1',
        createdAt: new Date(),
        createdBy: 'user-123',
        comment: 'Transfert test'
    }
];

const mockCarryOverHistoryData = [
    {
        id: 'carryover-1',
        userId: 'user-123',
        leaveType: LeaveType.ANNUAL,
        fromYear: mockYear - 1,
        toYear: mockYear,
        originalAmount: 4,
        carriedAmount: 4,
        expiryDate: addMonths(new Date(mockYear, 0, 1), 3),
        ruleApplied: 'co-rule-1',
        createdAt: new Date(),
        createdBy: 'user-123',
        status: 'completed'
    }
];

// Define mock fetch responses for different endpoints
const createMockResponse = (data: any, status = 200) => ({
    ok: status >= 200 && status < 300,
    status,
    statusText: status === 200 ? 'OK' : 'Error',
    headers: new Map(),
    json: async () => data,
    text: async () => JSON.stringify(data),
    blob: async () => new Blob([JSON.stringify(data)]),
    arrayBuffer: async () => new ArrayBuffer(0),
    clone: function() { return this; },
    body: null,
    bodyUsed: false,
    url: '',
    type: 'basic' as ResponseType,
    redirected: false,
});

let mockLogActionAuditService: jest.MockedFunction<any>;
let mockCreateAuditEntry: jest.MockedFunction<any>;

beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    
    // Reset the singleton instances to ensure fresh mocks
    (QuotaAdvancedService as any).instance = null;
    
    // Get the mocked AuditService
    const { AuditService } = require('../AuditService');
    const auditServiceInstance = AuditService.getInstance();
    mockLogActionAuditService = auditServiceInstance.logAction as jest.MockedFunction<any>;
    mockCreateAuditEntry = auditServiceInstance.createAuditEntry as jest.MockedFunction<any>;
    
    mockLogActionAuditService.mockClear();
    mockLogActionAuditService.mockResolvedValue(undefined);
    
    mockCreateAuditEntry.mockClear();
    mockCreateAuditEntry.mockResolvedValue({ id: 'mock-audit-id' });

    // Mock fetch directly with comprehensive URL matching
    const mockFetch = jest.fn().mockImplementation((url: string, options?: any) => {
        const urlStr = url.toString();
        const method = options?.method || 'GET';
        
        // Transfer endpoints
        if (urlStr.includes('/api/conges/quotas/transfer') && method === 'POST') {
            return Promise.resolve(createMockResponse({ success: true, transferId: 'mock-transfer-id' }));
        }
        
        if (urlStr.includes('/api/conges/quotas/transfer/history')) {
            return Promise.resolve(createMockResponse(mockTransferHistoryData));
        }
        
        // Carry-over endpoints
        if (urlStr.includes('/api/conges/quotas/carry-over') && method === 'POST') {
            return Promise.resolve(createMockResponse({ success: true, id: 'mock-carryover-id' }));
        }
        
        if (urlStr.includes('/api/conges/quotas/carry-over/history')) {
            return Promise.resolve(createMockResponse(mockCarryOverHistoryData));
        }
        
        // Audit endpoints
        if (urlStr.includes('/api/conges/audit/entries') && method === 'POST') {
            return Promise.resolve(createMockResponse({ id: 'mock-audit-entry-id', success: true }, 201));
        }
        
        // Default response for any unmatched URL
        return Promise.resolve(createMockResponse({ success: true, message: 'Mock response' }));
    });
    
    global.fetch = mockFetch;

    // Set up service mocks
    mockFetchLeaveBalanceRef.mockResolvedValue(mockLeaveBalance);
    mockFetchActiveTransferRulesForUserRef.mockResolvedValue(mockTransferRules);
    mockFetchActiveCarryOverRulesForUserRef.mockResolvedValue(mockCarryOverRules);
    mockFetchTransferHistoryRef.mockResolvedValue(mockTransferHistoryData);
    mockFetchCarryOverHistoryRef.mockResolvedValue(mockCarryOverHistoryData);
});

afterEach(() => {
    jest.restoreAllMocks();
});

describe('QuotaAdvancedService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    describe('getActiveTransferRules', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait récupérer les règles de transfert actives', async () => {
            const rules = await quotaAdvancedService.getActiveTransferRules(mockUserId);
            expect(mockFetchActiveTransferRulesForUserRef).toHaveBeenCalledWith(mockUserId);
            expect(rules).toEqual(mockTransferRules);
        });

        it('devrait gérer les erreurs lors de la récupération des règles', async () => {
            mockFetchActiveTransferRulesForUserRef.mockRejectedValue(new Error('Test error'));
            await expect(quotaAdvancedService.getActiveTransferRules(mockUserId)).rejects.toThrow('Test error');
        });
    });

    describe('getActiveCarryOverRules', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait récupérer les règles de report actives', async () => {
            const rules = await quotaAdvancedService.getActiveCarryOverRules(mockUserId);
            expect(mockFetchActiveCarryOverRulesForUserRef).toHaveBeenCalledWith(mockUserId);
            expect(rules).toEqual(mockCarryOverRules);
        });

        it('devrait gérer les erreurs lors de la récupération des règles', async () => {
            mockFetchActiveCarryOverRulesForUserRef.mockRejectedValue(new Error('Test error'));
            await expect(quotaAdvancedService.getActiveCarryOverRules(mockUserId)).rejects.toThrow('Test error');
        });
    });

    describe('simulateTransfer', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait simuler un transfert valide avec application des règles', async () => {
            const result = await quotaAdvancedService.simulateTransfer({
                userId: mockUserId,
                sourceType: LeaveType.RECOVERY,
                targetType: LeaveType.ANNUAL,
                amount: 2,
                applyRules: true
            });

            expect(result.isValid).toBe(true);
            expect(result.targetAmount).toBe(2);
            expect(result.sourceRemaining).toBe(7 - 2);
        });

        it('devrait détecter un transfert invalide si le montant dépasse le quota disponible', async () => {
            const result = await quotaAdvancedService.simulateTransfer({
                userId: mockUserId,
                sourceType: LeaveType.RECOVERY,
                targetType: LeaveType.ANNUAL,
                amount: 10,
                applyRules: true
            });

            expect(result.isValid).toBe(false);
            expect(result.messages).toContain('Quota insuffisant. Il vous reste 7 jours de RECOVERY.');
        });
    });

    describe('executeTransfer', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait exécuter un transfert valide', async () => {
            const result = await quotaAdvancedService.executeTransfer({
                userId: mockUserId,
                sourceType: LeaveType.RECOVERY,
                targetType: LeaveType.ANNUAL,
                sourceAmount: 2,
                comment: 'Test transfer'
            } as any, mockUserId);

            expect(result.success).toBe(true);
            expect(mockCreateAuditEntry).toHaveBeenCalled();
        });

        it('devrait rejeter un transfert si la simulation échoue', async () => {
            const simulateTransferSpy = jest.spyOn(quotaAdvancedService as any, 'simulateTransfer')
                .mockResolvedValueOnce({
                    isValid: false,
                    messages: ['Quota insuffisant simulé'],
                    sourceRemaining: 0,
                    targetAmount: 0,
                    appliedRatio: 1
                });

            await expect(quotaAdvancedService.executeTransfer({
                userId: mockUserId,
                sourceType: LeaveType.RECOVERY,
                targetType: LeaveType.ANNUAL,
                sourceAmount: 10
            } as any, mockUserId)).rejects.toThrow('Quota insuffisant simulé');

            expect(simulateTransferSpy).toHaveBeenCalled();
            expect(mockCreateAuditEntry).not.toHaveBeenCalled();

            simulateTransferSpy.mockRestore();
        });
    });

    describe('simulateCarryOver', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait simuler un report valide', async () => {
            const result = await quotaAdvancedService.simulateCarryOver({
                userId: mockUserId,
                leaveType: LeaveType.ANNUAL,
                fromYear: mockYear,
                toYear: mockYear + 1
            });

            expect(result.carryOverAmount).toBeGreaterThanOrEqual(0);
            expect(result.eligibleForCarryOver).toBe(18);
            expect(result.carryOverAmount).toBe(Math.min(18 * 0.5, 10));
        });

        it('devrait calculer correctement un report avec pourcentage', async () => {
            mockFetchActiveCarryOverRulesForUserRef.mockResolvedValueOnce([
                {
                    id: 'carry-rule-rtt', leaveType: LeaveType.RECOVERY, ruleType: QuotaCarryOverRuleType.PERCENTAGE,
                    value: 30,
                    maxCarryOverDays: 5, expirationDays: 180, requiresApproval: false, isActive: true,
                    authorizedRoles: undefined,
                    departmentId: undefined,
                    applicableUserRoles: undefined,
                    metadata: undefined,
                }
            ]);
            const result = await quotaAdvancedService.simulateCarryOver({
                userId: mockUserId,
                leaveType: LeaveType.RECOVERY,
                fromYear: mockYear,
                toYear: mockYear + 1
            });

            expect(result.carryOverAmount).toBeGreaterThanOrEqual(0);
            expect(result.eligibleForCarryOver).toBeCloseTo(7);
            expect(result.carryOverAmount).toBe(Math.floor(Math.min(7 * 0.3, 5)));
        });
    });

    describe('executeCarryOver', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait exécuter un report valide', async () => {
            const result = await quotaAdvancedService.executeCarryOver({
                userId: mockUserId,
                leaveType: LeaveType.ANNUAL,
                fromYear: mockYear,
                toYear: mockYear + 1,
                amount: 5
            }, mockUserId);

            expect(result).toBe(true);
            expect(mockCreateAuditEntry).toHaveBeenCalled();
        });

        it('devrait rejeter un report si la simulation échoue', async () => {
            mockFetchLeaveBalanceRef.mockResolvedValueOnce({ ...mockLeaveBalance, balances: { ...mockLeaveBalance.balances, [LeaveType.ANNUAL]: { ...mockLeaveBalance.balances[LeaveType.ANNUAL], remaining: 0 } } } as LeaveBalance);

            await expect(quotaAdvancedService.executeCarryOver({
                userId: mockUserId,
                leaveType: LeaveType.ANNUAL,
                fromYear: mockYear,
                toYear: mockYear + 1
            }, mockUserId)).rejects.toThrow('Aucun jour à reporter');

            expect(mockCreateAuditEntry).not.toHaveBeenCalled();
        });
    });

    describe('getEnhancedQuotaState', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait récupérer et combiner les informations de quotas, transferts et reports', async () => {
            const enhancedQuotas = await quotaAdvancedService.getEnhancedQuotaState(mockUserId, mockYear);

            expect(mockFetchLeaveBalanceRef).toHaveBeenCalledWith(mockUserId);

            expect(enhancedQuotas).toBeDefined();
            expect(Array.isArray(enhancedQuotas)).toBe(true);

            const cpQuota = enhancedQuotas.find(q => q.type === LeaveType.ANNUAL);
            expect(cpQuota).toBeDefined();
            if (cpQuota) {
                expect(cpQuota.total).toBe(mockLeaveBalance.balances[LeaveType.ANNUAL].initial);
                expect(cpQuota.used).toBe(mockLeaveBalance.balances[LeaveType.ANNUAL].used);
                expect(cpQuota.remaining).toBe(mockLeaveBalance.balances[LeaveType.ANNUAL].remaining);
                expect(cpQuota.transferItems).toBeDefined();
                expect(cpQuota.carriedOverItems).toBeDefined();
            }

            const rttQuota = enhancedQuotas.find(q => q.type === LeaveType.RECOVERY);
            expect(rttQuota).toBeDefined();
        });

        it('devrait gérer une erreur lors de la récupération des données', async () => {
            mockFetchLeaveBalanceRef.mockRejectedValueOnce(new Error('Network Error'));

            await expect(quotaAdvancedService.getEnhancedQuotaState(mockUserId, mockYear))
                .rejects.toThrow('Network Error');
        });
    });
}); 