import leaveBalanceService from '../leaveBalanceService';
import apiClient from '@/utils/apiClient';
import { LeaveType } from '@/modules/leaves/types/leave';

// Mock apiClient
jest.mock('@/utils/apiClient');

// Mock window.URL.createObjectURL
global.URL.createObjectURL = jest.fn(() => 'blob:mock-url');

describe('leaveBalanceService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    describe('getUserBalances', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should fetch user balances for current year by default', async () => {
            const mockBalances = [
                { type: LeaveType.PAID, balance: 25, used: 10, remaining: 15 },
                { type: LeaveType.RTT, balance: 10, used: 5, remaining: 5 }
            ];
            mockApiClient.get.mockResolvedValueOnce({ data: mockBalances });

            const result = await leaveBalanceService.getUserBalances('user123');

            expect(result).toEqual(mockBalances);
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/user123', {
                params: { year: new Date().getFullYear() }
            });
        });

        it('should fetch user balances for specific year', async () => {
            const mockBalances = [
                { type: LeaveType.PAID, balance: 25, used: 10, remaining: 15 }
            ];
            mockApiClient.get.mockResolvedValueOnce({ data: mockBalances });

            const result = await leaveBalanceService.getUserBalances('user123', 2023);

            expect(result).toEqual(mockBalances);
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/user123', {
                params: { year: 2023 }
            });
        });
    });

    describe('getUserBalanceByType', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should fetch balance for specific leave type', async () => {
            const mockBalance = { type: LeaveType.PAID, balance: 25, used: 10, remaining: 15 };
            mockApiClient.get.mockResolvedValueOnce({ data: mockBalance });

            const result = await leaveBalanceService.getUserBalanceByType('user123', LeaveType.PAID);

            expect(result).toEqual(mockBalance);
            expect(mockApiClient.get).toHaveBeenCalledWith(
                `/api/leave-balances/user123/${LeaveType.PAID}`,
                {
                    params: { year: new Date().getFullYear() }
                }
            );
        });

        it('should fetch balance for specific year and type', async () => {
            const mockBalance = { type: LeaveType.RTT, balance: 10, used: 5, remaining: 5 };
            mockApiClient.get.mockResolvedValueOnce({ data: mockBalance });

            const result = await leaveBalanceService.getUserBalanceByType('user123', LeaveType.RTT, 2023);

            expect(result).toEqual(mockBalance);
            expect(mockApiClient.get).toHaveBeenCalledWith(
                `/api/leave-balances/user123/${LeaveType.RTT}`,
                {
                    params: { year: 2023 }
                }
            );
        });
    });

    describe('adjustBalance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should adjust balance with positive amount', async () => {
            const updatedBalance = { type: LeaveType.PAID, balance: 30, used: 10, remaining: 20 };
            mockApiClient.post.mockResolvedValueOnce({ data: updatedBalance });

            const result = await leaveBalanceService.adjustBalance(
                'user123',
                LeaveType.PAID,
                5,
                'Bonus days'
            );

            expect(result).toEqual(updatedBalance);
            expect(mockApiClient.post).toHaveBeenCalledWith('/api/leave-balances/user123/adjust', {
                type: LeaveType.PAID,
                amount: 5,
                reason: 'Bonus days',
                year: new Date().getFullYear()
            });
        });

        it('should adjust balance with negative amount', async () => {
            const updatedBalance = { type: LeaveType.PAID, balance: 20, used: 10, remaining: 10 };
            mockApiClient.post.mockResolvedValueOnce({ data: updatedBalance });

            const result = await leaveBalanceService.adjustBalance(
                'user123',
                LeaveType.PAID,
                -5,
                'Correction',
                2023
            );

            expect(result).toEqual(updatedBalance);
            expect(mockApiClient.post).toHaveBeenCalledWith('/api/leave-balances/user123/adjust', {
                type: LeaveType.PAID,
                amount: -5,
                reason: 'Correction',
                year: 2023
            });
        });
    });

    describe('calculateWorkingDays', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should calculate working days with Date objects', async () => {
            const startDate = new Date('2023-01-02');
            const endDate = new Date('2023-01-06');
            mockApiClient.get.mockResolvedValueOnce({ data: { days: 5 } });

            const result = await leaveBalanceService.calculateWorkingDays(startDate, endDate);

            expect(result).toBe(5);
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/calculate-days', {
                params: {
                    startDate: startDate.toISOString(),
                    endDate: endDate.toISOString(),
                    halfDayStart: undefined,
                    halfDayEnd: undefined
                }
            });
        });

        it('should calculate working days with string dates', async () => {
            const startDate = '2023-01-02T00:00:00.000Z';
            const endDate = '2023-01-06T00:00:00.000Z';
            mockApiClient.get.mockResolvedValueOnce({ data: { days: 5 } });

            const result = await leaveBalanceService.calculateWorkingDays(startDate, endDate);

            expect(result).toBe(5);
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/calculate-days', {
                params: {
                    startDate,
                    endDate,
                    halfDayStart: undefined,
                    halfDayEnd: undefined
                }
            });
        });

        it('should calculate working days with half days', async () => {
            const startDate = new Date('2023-01-02');
            const endDate = new Date('2023-01-06');
            mockApiClient.get.mockResolvedValueOnce({ data: { days: 4 } });

            const result = await leaveBalanceService.calculateWorkingDays(
                startDate,
                endDate,
                true,
                true
            );

            expect(result).toBe(4);
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/calculate-days', {
                params: {
                    startDate: startDate.toISOString(),
                    endDate: endDate.toISOString(),
                    halfDayStart: true,
                    halfDayEnd: true
                }
            });
        });
    });

    describe('getAdjustmentsHistory', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should fetch adjustments history without year filter', async () => {
            const mockAdjustments = [
                { id: '1', amount: 5, reason: 'Bonus', date: '2023-01-01' },
                { id: '2', amount: -2, reason: 'Correction', date: '2023-02-01' }
            ];
            mockApiClient.get.mockResolvedValueOnce({ data: mockAdjustments });

            const result = await leaveBalanceService.getAdjustmentsHistory('user123');

            expect(result).toEqual(mockAdjustments);
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/user123/adjustments', {
                params: { year: undefined }
            });
        });

        it('should fetch adjustments history with year filter', async () => {
            const mockAdjustments = [
                { id: '1', amount: 5, reason: 'Bonus', date: '2023-01-01' }
            ];
            mockApiClient.get.mockResolvedValueOnce({ data: mockAdjustments });

            const result = await leaveBalanceService.getAdjustmentsHistory('user123', 2023);

            expect(result).toEqual(mockAdjustments);
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/user123/adjustments', {
                params: { year: 2023 }
            });
        });
    });

    describe('initializeYearBalances', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should initialize balances for a new year', async () => {
            const mockResponse = { success: true, count: 50 };
            mockApiClient.post.mockResolvedValueOnce({ data: mockResponse });

            const result = await leaveBalanceService.initializeYearBalances(2024);

            expect(result).toEqual(mockResponse);
            expect(mockApiClient.post).toHaveBeenCalledWith('/api/leave-balances/initialize-year', {
                year: 2024
            });
        });
    });

    describe('carryOverBalances', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should carry over balances without max limit', async () => {
            const mockResponse = { success: true, count: 30 };
            mockApiClient.post.mockResolvedValueOnce({ data: mockResponse });

            const result = await leaveBalanceService.carryOverBalances(2023, 2024);

            expect(result).toEqual(mockResponse);
            expect(mockApiClient.post).toHaveBeenCalledWith('/api/leave-balances/carry-over', {
                fromYear: 2023,
                toYear: 2024,
                maxDaysToCarryOver: undefined
            });
        });

        it('should carry over balances with max limit', async () => {
            const mockResponse = { success: true, count: 25 };
            mockApiClient.post.mockResolvedValueOnce({ data: mockResponse });

            const result = await leaveBalanceService.carryOverBalances(2023, 2024, 5);

            expect(result).toEqual(mockResponse);
            expect(mockApiClient.post).toHaveBeenCalledWith('/api/leave-balances/carry-over', {
                fromYear: 2023,
                toYear: 2024,
                maxDaysToCarryOver: 5
            });
        });
    });

    describe('exportBalances', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should export balances as xlsx by default', async () => {
            const mockBlob = new Blob(['mock data']);
            mockApiClient.get.mockResolvedValueOnce({ data: mockBlob });

            const result = await leaveBalanceService.exportBalances(2023);

            expect(result).toEqual({ url: 'blob:mock-url' });
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/export', {
                params: { year: 2023, format: 'xlsx' },
                responseType: 'blob'
            });
            expect(global.URL.createObjectURL).toHaveBeenCalled();
        });

        it('should export balances as csv', async () => {
            const mockBlob = new Blob(['mock csv data']);
            mockApiClient.get.mockResolvedValueOnce({ data: mockBlob });

            const result = await leaveBalanceService.exportBalances(2023, 'csv');

            expect(result).toEqual({ url: 'blob:mock-url' });
            expect(mockApiClient.get).toHaveBeenCalledWith('/api/leave-balances/export', {
                params: { year: 2023, format: 'csv' },
                responseType: 'blob'
            });
        });

        it('should create correct blob type for xlsx', async () => {
            const mockData = 'mock xlsx data';
            mockApiClient.get.mockResolvedValueOnce({ data: mockData });
            
            // Mock Blob constructor properly
            const originalBlob = global.Blob;
            global.Blob = jest.fn((content, options) => ({
                content,
                options,
                size: content[0].length,
                type: options.type
            })) as any;

            await leaveBalanceService.exportBalances(2023, 'xlsx');

            expect(global.Blob).toHaveBeenCalledWith([mockData], {
                type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            });

            global.Blob = originalBlob;
        });

        it('should create correct blob type for csv', async () => {
            const mockData = 'mock csv data';
            mockApiClient.get.mockResolvedValueOnce({ data: mockData });
            
            // Mock Blob constructor properly
            const originalBlob = global.Blob;
            global.Blob = jest.fn((content, options) => ({
                content,
                options,
                size: content[0].length,
                type: options.type
            })) as any;

            await leaveBalanceService.exportBalances(2023, 'csv');

            expect(global.Blob).toHaveBeenCalledWith([mockData], {
                type: 'text/csv'
            });

            global.Blob = originalBlob;
        });
    });
});