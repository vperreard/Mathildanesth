/**
 * @jest-environment jsdom
 */

import { 
  calculateLeaveQuota, 
  checkQuotaAvailability, 
  updateQuotaUsage,
  getQuotaBalance,
  transferQuota,
  carryOverQuota,
  calculateProRatedQuota
} from '../quotaService';
import { LeaveType } from '@/types/leave';

// Mock the leaveService
jest.mock('../leaveService', () => ({
  fetchLeaveBalance: jest.fn(),
}));

// Mock Prisma
jest.mock('@/lib/prisma', () => ({
  prisma: {
    leaveQuota: {
      findFirst: jest.fn(),
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      upsert: jest.fn(),
    },
    user: {
      findUnique: jest.fn(),
    },
    leave: {
      findMany: jest.fn(),
    },
  },
}));

import { prisma } from '@/lib/prisma';
import { fetchLeaveBalance } from '../leaveService';
const mockPrisma = prisma as jest.Mocked<typeof prisma>;
const mockFetchLeaveBalance = fetchLeaveBalance as jest.MockedFunction<typeof fetchLeaveBalance>;

describe('quotaService Comprehensive Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
  });

  describe('calculateLeaveQuota', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should calculate annual leave quota correctly', async () => {
      const userId = 'user-123';

      const mockLeaveBalance = {
        userId,
        year: 2024,
        balances: {
          [LeaveType.ANNUAL]: {
            initial: 25,
            used: 5,
            pending: 2,
            remaining: 18,
            acquired: 25
          },
          [LeaveType.RECOVERY]: {
            initial: 10,
            used: 0,
            pending: 0,
            remaining: 10,
            acquired: 10
          }
        }
      };

      mockFetchLeaveBalance.mockResolvedValue(mockLeaveBalance);

      const result = await calculateLeaveQuota(userId, LeaveType.ANNUAL);

      expect(result).toBe(25); // Should return the total quota for ANNUAL leave
    });

    it('should calculate pro-rated quota for new employees', async () => {
      const userId = 'user-456';

      const mockLeaveBalance = {
        userId,
        year: 2024,
        balances: {
          [LeaveType.ANNUAL]: {
            initial: 12, // Pro-rated for mid-year hire
            used: 0,
            pending: 0,
            remaining: 12,
            acquired: 12
          }
        }
      };

      mockFetchLeaveBalance.mockResolvedValue(mockLeaveBalance);

      const result = await calculateLeaveQuota(userId, LeaveType.ANNUAL);

      expect(result).toBe(12); // Pro-rated quota
    });

    it('should calculate part-time quota correctly', async () => {
      const userId = 'user-789';

      const mockLeaveBalance = {
        userId,
        year: 2024,
        balances: {
          [LeaveType.ANNUAL]: {
            initial: 12, // 50% of 25 days for part-time
            used: 0,
            pending: 0,
            remaining: 12,
            acquired: 12
          }
        }
      };

      mockFetchLeaveBalance.mockResolvedValue(mockLeaveBalance);

      const result = await calculateLeaveQuota(userId, LeaveType.ANNUAL);

      expect(result).toBe(12); // Part-time quota
    });

    it('should handle different leave types', async () => {
      const userId = 'user-456';

      const mockLeaveBalance = {
        userId,
        year: 2024,
        balances: {
          [LeaveType.SICK]: {
            initial: 0, // Sick leave typically unlimited or calculated differently
            used: 0,
            pending: 0,
            remaining: 0,
            acquired: 0
          }
        }
      };

      mockFetchLeaveBalance.mockResolvedValue(mockLeaveBalance);

      const result = await calculateLeaveQuota(userId, LeaveType.SICK);

      expect(result).toBe(0); // Default for sick leave when not specifically configured
    });
  });

  describe('checkQuotaAvailability', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return true when sufficient quota available', async () => {
      const userId = 'user-123';
      const requestedDays = 5;

      const mockLeaveBalance = {
        userId,
        year: 2024,
        balances: {
          [LeaveType.ANNUAL]: {
            initial: 25,
            used: 5,
            pending: 0,
            remaining: 20,
            acquired: 25
          }
        }
      };

      mockFetchLeaveBalance.mockResolvedValue(mockLeaveBalance);

      const result = await checkQuotaAvailability(userId, LeaveType.ANNUAL, requestedDays);

      expect(result).toBe(true);
    });

    it('should return false when insufficient quota', async () => {
      const userId = 'user-123';
      const requestedDays = 25;

      const mockLeaveBalance = {
        userId,
        year: 2024,
        balances: {
          [LeaveType.ANNUAL]: {
            initial: 25,
            used: 20,
            pending: 0,
            remaining: 5,
            acquired: 25
          }
        }
      };

      mockFetchLeaveBalance.mockResolvedValue(mockLeaveBalance);

      const result = await checkQuotaAvailability(userId, LeaveType.ANNUAL, requestedDays);

      expect(result).toBe(false);
    });
  });

  describe('Error Handling', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle fetchLeaveBalance errors gracefully', async () => {
      const userId = 'user-123';

      mockFetchLeaveBalance.mockRejectedValue(new Error('Database connection failed'));

      await expect(calculateLeaveQuota(userId, LeaveType.ANNUAL)).rejects.toThrow('Database connection failed');
    });

    it('should handle missing balance data', async () => {
      const userId = 'user-123';

      mockFetchLeaveBalance.mockResolvedValue({
        userId,
        year: 2024,
        balances: {}
      });

      const result = await calculateLeaveQuota(userId, LeaveType.ANNUAL);

      expect(result).toBe(0); // Should default to 0 for missing types
    });
  });
});