import { NotificationEventService } from '../notificationEventService';
import { Leave, LeaveStatus, LeaveType } from '../../types/leave';
import { leaveNotificationService } from '../notificationService';
import { UserRole } from '@/types/user';

// Mock du service de notification
jest.mock('../notificationService', () => ({
    leaveNotificationService: {
        sendNotification: jest.fn(),
        notifyLeaveRequest: jest.fn(),
        notifyLeaveStatusUpdate: jest.fn(),
        notifyLeaveConflict: jest.fn(),
        notifyQuotaLow: jest.fn(),
        sendLeaveReminder: jest.fn(),
    }
}));

describe('NotificationEventService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    let service: NotificationEventService;
    const mockLeaveNotificationService = leaveNotificationService as jest.Mocked<typeof leaveNotificationService>;

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
        service = NotificationEventService.getInstance();
    });

    afterEach(() => {
        jest.resetAllMocks();
    });

    describe('Singleton Pattern', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should always return the same instance', () => {
            const instance1 = NotificationEventService.getInstance();
            const instance2 = NotificationEventService.getInstance();
            expect(instance1).toBe(instance2);
        });
    });

    describe('handleLeaveCreated', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should notify when a leave is created', async () => {
            const mockLeave: Leave = {
                id: 'leave-123',
                userId: 'user-456',
                type: LeaveType.ANNUAL,
                startDate: new Date('2025-06-01'),
                endDate: new Date('2025-06-15'),
                status: LeaveStatus.PENDING,
                reason: 'Vacances été',
                countedDays: 10,
                requestDate: new Date('2025-05-01'),
                createdAt: new Date(),
                updatedAt: new Date()
            };

            const mockUser = {
                id: 'user-456',
                prenom: 'Jean',
                nom: 'Dupont',
                email: 'jean.dupont@example.com',
                role: UserRole.UTILISATEUR
            };

            await service.handleLeaveCreated(mockLeave, mockUser);

            expect(mockLeaveNotificationService.notifyLeaveRequest).toHaveBeenCalledWith(
                mockLeave,
                mockUser
            );
        });

        it('should handle errors gracefully', async () => {
            const mockLeave: Leave = {
                id: 'leave-123',
                userId: 'user-456',
                type: LeaveType.SICK,
                startDate: new Date('2025-06-01'),
                endDate: new Date('2025-06-03'),
                status: LeaveStatus.PENDING,
                reason: 'Maladie',
                countedDays: 2,
                requestDate: new Date('2025-05-01'),
                createdAt: new Date(),
                updatedAt: new Date()
            };

            const mockUser = {
                id: 'user-456',
                prenom: 'Jane',
                nom: 'Doe',
                email: 'jane@example.com',
                role: UserRole.UTILISATEUR
            };

            mockLeaveNotificationService.notifyLeaveRequest.mockRejectedValueOnce(new Error('Notification failed'));

            // Should not throw even if notification fails
            await expect(service.handleLeaveCreated(mockLeave, mockUser)).rejects.toThrow('Notification failed');
        });
    });

    describe('handleLeaveStatusChanged', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should notify when leave status changes', async () => {
            const mockLeave: Leave = {
                id: 'leave-123',
                userId: 'user-456',
                type: LeaveType.ANNUAL,
                startDate: new Date('2025-06-01'),
                endDate: new Date('2025-06-15'),
                status: LeaveStatus.APPROVED,
                reason: 'Vacances',
                countedDays: 10,
                requestDate: new Date('2025-05-01'),
                createdAt: new Date(),
                updatedAt: new Date()
            };

            const mockApprover = {
                id: 'approver-123',
                prenom: 'Dr. Sophie',
                nom: 'Bernard',
                email: 'sophie.bernard@example.com',
                role: UserRole.MANAGER
            };

            await service.handleLeaveStatusChanged(mockLeave, mockApprover);

            expect(mockLeaveNotificationService.notifyLeaveStatusUpdate).toHaveBeenCalledWith(
                mockLeave,
                mockApprover
            );
        });
    });

    describe('handleLeaveConflict', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should notify when there is a leave conflict', async () => {
            const mockLeave: Leave = {
                id: 'leave-123',
                userId: 'user-456',
                type: LeaveType.ANNUAL,
                startDate: new Date('2025-06-01'),
                endDate: new Date('2025-06-15'),
                status: LeaveStatus.PENDING,
                reason: 'Vacances',
                countedDays: 10,
                requestDate: new Date('2025-05-01'),
                createdAt: new Date(),
                updatedAt: new Date()
            };

            const conflictingLeaves: Leave[] = [{
                id: 'leave-456',
                userId: 'user-789',
                type: LeaveType.ANNUAL,
                startDate: new Date('2025-06-10'),
                endDate: new Date('2025-06-20'),
                status: LeaveStatus.APPROVED,
                reason: 'Autre congé',
                countedDays: 8,
                requestDate: new Date('2025-04-15'),
                createdAt: new Date(),
                updatedAt: new Date()
            }];

            await service.handleLeaveConflict(mockLeave, conflictingLeaves);

            expect(mockLeaveNotificationService.notifyLeaveConflict).toHaveBeenCalledWith(
                mockLeave,
                conflictingLeaves
            );
        });
    });

    describe('handleQuotaUpdated', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should notify when quota is low', async () => {
            const userId = 'user-123';
            const remainingDays = 5;
            const totalAllowance = 25;
            const year = 2025;

            await service.handleQuotaUpdated(userId, remainingDays, totalAllowance, year);

            // Should trigger notification since remaining days (5/25 = 20%) equals threshold
            expect(mockLeaveNotificationService.notifyQuotaLow).toHaveBeenCalledWith(
                userId,
                remainingDays,
                totalAllowance,
                year
            );
        });

        it('should not notify when quota is above threshold', async () => {
            const userId = 'user-123';
            const remainingDays = 15; // 15/25 = 60% > 20% threshold
            const totalAllowance = 25;
            const year = 2025;

            await service.handleQuotaUpdated(userId, remainingDays, totalAllowance, year);

            expect(mockLeaveNotificationService.notifyQuotaLow).not.toHaveBeenCalled();
        });
    });

    describe('configuration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should update notification configuration', () => {
            const customConfig = {
                enableEmailNotifications: false,
                enablePushNotifications: true,
                quotaThreshold: 10,
                reminderDays: [1, 5],
                approvalReminder: 3
            };

            service.updateConfig(customConfig);

            // Configuration should be applied without throwing
            expect(() => service.updateConfig(customConfig)).not.toThrow();
        });
    });

    describe('checkUpcomingLeaves', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should send reminders for upcoming leaves', async () => {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);

            const mockLeaves: Leave[] = [{
                id: 'leave-123',
                userId: 'user-456',
                type: LeaveType.ANNUAL,
                startDate: tomorrow,
                endDate: new Date(tomorrow.getTime() + 7 * 24 * 60 * 60 * 1000), // +7 days
                status: LeaveStatus.APPROVED,
                reason: 'Vacances',
                countedDays: 7,
                requestDate: new Date('2025-05-01'),
                createdAt: new Date(),
                updatedAt: new Date()
            }];

            await service.checkUpcomingLeaves(mockLeaves);

            // Should send reminder for leave starting tomorrow (1 day is in default reminder days)
            expect(mockLeaveNotificationService.sendLeaveReminder).toHaveBeenCalledWith(
                mockLeaves[0],
                1
            );
        });

        it('should not send reminders for non-approved leaves', async () => {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);

            const mockLeaves: Leave[] = [{
                id: 'leave-123',
                userId: 'user-456',
                type: LeaveType.ANNUAL,
                startDate: tomorrow,
                endDate: new Date(tomorrow.getTime() + 7 * 24 * 60 * 60 * 1000),
                status: LeaveStatus.PENDING, // Not approved
                reason: 'Vacances',
                countedDays: 7,
                requestDate: new Date('2025-05-01'),
                createdAt: new Date(),
                updatedAt: new Date()
            }];

            await service.checkUpcomingLeaves(mockLeaves);

            expect(mockLeaveNotificationService.sendLeaveReminder).not.toHaveBeenCalled();
        });
    });
}); 