import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import '@testing-library/jest-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import LeavesList from '../LeavesList';
import { LeaveWithUser, LeaveStatus } from '../../types/leave';
import { User, UserRole, ExperienceLevel } from '@/types/user';
import { useLeaveListFilteringSorting } from '../../hooks/useLeaveListFilteringSorting';

// Mock du hook de tri/filtrage
jest.mock('../../hooks/useLeaveListFilteringSorting');
const mockedUseLeaveListFilteringSorting = useLeaveListFilteringSorting as jest.Mock;

// Créer un thème Material-UI pour les tests
const theme = createTheme();

// Wrapper avec ThemeProvider pour Material-UI
const renderWithTheme = (component: React.ReactElement) => {
    return render(
        <ThemeProvider theme={theme}>
            {component}
        </ThemeProvider>
    );
};

describe('LeavesList Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

    const mockOnEditLeaveClick = jest.fn();
    const mockOnCancelLeaveClick = jest.fn();

    // Données de test
    const mockUser1: User = {
        id: 'u1',
        prenom: 'Alice',
        nom: 'Alpha',
        email: 'alice@example.com',
        role: UserRole.DOCTOR,
        specialties: [],
        experienceLevel: ExperienceLevel.SENIOR,
        createdAt: new Date('2024-01-01'),
        updatedAt: new Date('2024-01-01')
    };

    const mockUser2: User = {
        id: 'u2',
        prenom: 'Bob',
        nom: 'Bravo',
        email: 'bob@example.com',
        role: UserRole.DOCTOR,
        specialties: [],
        experienceLevel: ExperienceLevel.JUNIOR,
        createdAt: new Date('2024-01-01'),
        updatedAt: new Date('2024-01-01')
    };

    const mockLeaves: LeaveWithUser[] = [
        {
            id: 'l1',
            userId: 'u1',
            user: mockUser1,
            startDate: '2024-09-05', // LeavesList utilise formatDateForDisplay
            endDate: '2024-09-10',
            type: 'ANNUAL',
            status: LeaveStatus.PENDING,
            countedDays: 4,
            reason: 'Vacances été',
            requestDate: new Date('2024-08-01'),
            createdAt: new Date('2024-08-01'),
            updatedAt: new Date('2024-08-02')
        },
        {
            id: 'l2',
            userId: 'u2',
            user: mockUser2,
            startDate: '2024-09-01',
            endDate: '2024-09-03',
            type: 'SICK',
            status: LeaveStatus.APPROVED,
            countedDays: 2,
            reason: 'Malade',
            requestDate: new Date('2024-08-20'),
            createdAt: new Date('2024-08-20'),
            updatedAt: new Date('2024-08-20')
        },
    ];

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
        // Par défaut, le hook retourne la liste complète
        mockedUseLeaveListFilteringSorting.mockImplementation(({ leaves }) => leaves);
    });

    describe('Rendering', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('renders table headers correctly', () => {
            renderWithTheme(
                <LeavesList
                    leaves={[]}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Vérifier les en-têtes de colonne (il peut y avoir des doublons avec les filtres)
            const columnHeaders = screen.getAllByRole('columnheader');
            expect(columnHeaders.length).toBeGreaterThan(0);
            
            // Vérifier la présence des textes d'en-têtes principaux
            expect(screen.getByText('Utilisateur')).toBeInTheDocument();
            expect(screen.getByText('Type')).toBeInTheDocument();
            expect(screen.getByText('Début')).toBeInTheDocument();
            expect(screen.getByText('Fin')).toBeInTheDocument();
            expect(screen.getByText('Statut')).toBeInTheDocument();
            expect(screen.getByText('Actions')).toBeInTheDocument();
        });

        it('renders filter inputs correctly', () => {
            renderWithTheme(
                <LeavesList
                    leaves={[]}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Vérifier la présence des champs de filtre
            expect(screen.getByPlaceholderText(/filtrer par nom/i)).toBeInTheDocument();
            
            // Les select Material-UI peuvent être trouvés par leur rôle
            const comboboxes = screen.getAllByRole('combobox');
            expect(comboboxes.length).toBeGreaterThanOrEqual(2); // Au moins type et statut
        });

        it('displays leave data correctly', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Vérifier l'affichage des données du premier congé
            expect(screen.getByText('Alice Alpha')).toBeInTheDocument();
            expect(screen.getByText('ANNUAL')).toBeInTheDocument();
            expect(screen.getByText('PENDING')).toBeInTheDocument();

            // Vérifier l'affichage des données du deuxième congé
            expect(screen.getByText('Bob Bravo')).toBeInTheDocument();
            expect(screen.getByText('SICK')).toBeInTheDocument();
            expect(screen.getByText('APPROVED')).toBeInTheDocument();
        });
    });

    describe('Loading and Error States', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('displays loading indicator when isLoading is true', () => {
            renderWithTheme(
                <LeavesList
                    leaves={[]}
                    isLoading={true}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Vérifier la présence de l'indicateur de chargement
            expect(screen.getByRole('progressbar')).toBeInTheDocument();
            expect(screen.getByText(/chargement des données/i)).toBeInTheDocument();
        });

        it('displays error message when error prop is provided', () => {
            const errorMessage = 'Erreur de chargement des données';
            renderWithTheme(
                <LeavesList
                    leaves={[]}
                    isLoading={false}
                    error={errorMessage}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Vérifier l'affichage du message d'erreur
            expect(screen.getByText(`Erreur: ${errorMessage}`)).toBeInTheDocument();
        });

        it('displays empty state message when no leaves match filters', () => {
            // Mock le hook pour retourner une liste vide (après filtrage)
            mockedUseLeaveListFilteringSorting.mockReturnValue([]);

            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves} // Données initiales non vides
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            expect(screen.getByText(/aucune demande ne correspond aux critères/i)).toBeInTheDocument();
        });
    });

    describe('Action Buttons', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('calls onEditLeaveClick when edit button is clicked', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const editButtons = screen.getAllByRole('button', { name: /modifier/i });
            fireEvent.click(editButtons[0]);

            expect(mockOnEditLeaveClick).toHaveBeenCalledTimes(1);
            expect(mockOnEditLeaveClick).toHaveBeenCalledWith(mockLeaves[0]);
        });

        it('calls onCancelLeaveClick when cancel button is clicked', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const cancelButtons = screen.getAllByRole('button', { name: /annuler/i });
            fireEvent.click(cancelButtons[0]);

            expect(mockOnCancelLeaveClick).toHaveBeenCalledTimes(1);
            expect(mockOnCancelLeaveClick).toHaveBeenCalledWith(mockLeaves[0]);
        });

        it('disables edit and cancel buttons for non-PENDING leaves', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const editButtons = screen.getAllByRole('button', { name: /modifier/i });
            const cancelButtons = screen.getAllByRole('button', { name: /annuler/i });

            // Premier congé (PENDING) - boutons activés
            expect(editButtons[0]).not.toBeDisabled();
            expect(cancelButtons[0]).not.toBeDisabled();

            // Deuxième congé (APPROVED) - boutons désactivés
            expect(editButtons[1]).toBeDisabled();
            expect(cancelButtons[1]).toBeDisabled();
        });
    });

    describe('Filtering', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('filters leaves by user name', async () => {
            // Mock le hook pour simuler le filtrage
            mockedUseLeaveListFilteringSorting.mockImplementation(({ leaves, filter }) => {
                if (filter?.user) {
                    return leaves.filter((leave: LeaveWithUser) => {
                        if (!leave.user) return false;
                        const userName = `${leave.user.prenom} ${leave.user.nom}`.toLowerCase();
                        return userName.includes(filter.user.toLowerCase());
                    });
                }
                return leaves;
            });

            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const nameFilterInput = screen.getByPlaceholderText(/filtrer par nom/i);
            fireEvent.change(nameFilterInput, { target: { value: 'alice' } });

            // Vérifier que le hook a été appelé avec le bon filtre
            await waitFor(() => {
                expect(mockedUseLeaveListFilteringSorting).toHaveBeenCalledWith(
                    expect.objectContaining({
                        filter: expect.objectContaining({
                            user: 'alice'
                        })
                    })
                );
            });
        });

        it('clears filter when input is cleared', async () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const nameFilterInput = screen.getByPlaceholderText(/filtrer par nom/i);
            
            // Appliquer un filtre
            fireEvent.change(nameFilterInput, { target: { value: 'alice' } });
            
            // Effacer le filtre
            fireEvent.change(nameFilterInput, { target: { value: '' } });

            await waitFor(() => {
                expect(mockedUseLeaveListFilteringSorting).toHaveBeenCalledWith(
                    expect.objectContaining({
                        filter: expect.objectContaining({
                            user: ''
                        })
                    })
                );
            });
        });
    });

    describe('Sorting', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('handles column header clicks for sorting', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Trouver et cliquer sur l'en-tête "Utilisateur"
            const userHeader = screen.getAllByRole('button', { name: /utilisateur/i })[0];
            fireEvent.click(userHeader);

            // Vérifier que le hook a été appelé (le tri exact dépend de l'implémentation)
            expect(mockedUseLeaveListFilteringSorting).toHaveBeenCalled();
        });

        it('toggles sort direction when clicking same column twice', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const userHeader = screen.getAllByRole('button', { name: /utilisateur/i })[0];
            
            // Premier clic
            fireEvent.click(userHeader);
            
            // Deuxième clic
            fireEvent.click(userHeader);

            // Le hook devrait avoir été appelé plusieurs fois avec différentes configurations de tri
            expect(mockedUseLeaveListFilteringSorting).toHaveBeenCalledTimes(3); // Initial + 2 clics
        });
    });

    describe('Edge Cases', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('handles leaves with missing user data', () => {
            const leavesWithMissingUser: LeaveWithUser[] = [
                {
                    ...mockLeaves[0],
                    user: undefined
                }
            ];

            renderWithTheme(
                <LeavesList
                    leaves={leavesWithMissingUser}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Le composant devrait afficher "Utilisateur inconnu"
            expect(screen.getByText('Utilisateur inconnu')).toBeInTheDocument();
        });

        it('handles leaves with partial user names', () => {
            const leavesWithPartialUser: LeaveWithUser[] = [
                {
                    ...mockLeaves[0],
                    user: {
                        ...mockUser1,
                        prenom: 'Marie',
                        nom: '' // Nom vide
                    }
                }
            ];

            renderWithTheme(
                <LeavesList
                    leaves={leavesWithPartialUser}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            // Devrait afficher le prénom seulement
            expect(screen.getByText('Marie')).toBeInTheDocument();
        });

        it('handles invalid dates gracefully', () => {
            const leavesWithInvalidDates: LeaveWithUser[] = [
                {
                    ...mockLeaves[0],
                    startDate: 'invalid-date', // Dates invalides comme strings
                    endDate: 'invalid-date'
                }
            ];

            // Le rendu ne devrait pas planter
            expect(() => {
                renderWithTheme(
                    <LeavesList
                        leaves={leavesWithInvalidDates}
                        isLoading={false}
                        error={null}
                        onEditLeaveClick={mockOnEditLeaveClick}
                        onCancelLeaveClick={mockOnCancelLeaveClick}
                    />
                );
            }).not.toThrow();
        });
    });

    describe('Accessibility', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('has proper table structure with accessibility attributes', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const table = screen.getByRole('table');
            expect(table).toBeInTheDocument();
            expect(table).toHaveAttribute('aria-label', 'Liste des congés');

            // Vérifier la structure de la table
            const columnHeaders = screen.getAllByRole('columnheader');
            expect(columnHeaders.length).toBeGreaterThan(0);

            const cells = screen.getAllByRole('cell');
            expect(cells.length).toBeGreaterThan(0);
        });

        it('has focusable and accessible buttons', () => {
            renderWithTheme(
                <LeavesList
                    leaves={mockLeaves}
                    isLoading={false}
                    error={null}
                    onEditLeaveClick={mockOnEditLeaveClick}
                    onCancelLeaveClick={mockOnCancelLeaveClick}
                />
            );

            const buttons = screen.getAllByRole('button');
            expect(buttons.length).toBeGreaterThan(0);

            // Vérifier que les boutons sont focusables
            buttons.forEach(button => {
                expect(button).toBeVisible();
            });
        });
    });
});