import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import { LeaveConflictRecommendation } from '../LeaveConflictRecommendation';
import { ConflictSeverity, ConflictType } from '../../types/conflict';
import { ConflictPriority, ResolutionStrategy } from '../../types/recommendation';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';

// Mock react-i18next
jest.mock('react-i18next', () => ({
    useTranslation: () => ({
        t: (key: string) => key,
        i18n: {
            language: 'fr'
        }
    })
}));

// Mock UI components
jest.mock('@/components/ui/alert', () => ({
    Alert: ({ children, severity, ...props }: any) => (
        <div data-testid="alert" data-severity={severity} {...props}>{children}</div>
    )
}));

jest.mock('@/components/ui/badge', () => ({
    Badge: ({ children, color, ...props }: any) => (
        <span data-testid="badge" data-color={color} {...props}>{children}</span>
    )
}));

jest.mock('@/components/ui/button', () => ({
    Button: ({ children, onClick, variant, color, size, disabled, ...props }: any) => (
        <button 
            data-testid="button" 
            onClick={onClick} 
            disabled={disabled}
            data-variant={variant}
            data-color={color}
            data-size={size}
            {...props}
        >
            {children}
        </button>
    )
}));

describe('LeaveConflictRecommendation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

    const mockConflict = {
        id: 'conflict-1',
        type: ConflictType.TEAM_ABSENCE,
        severity: ConflictSeverity.HIGH,
        message: 'Trop de membres de l'équipe absents',
        startDate: new Date('2025-01-15'),
        endDate: new Date('2025-01-20'),
        affectedUsers: ['user-1', 'user-2'],
        details: {
            teamId: 'team-1',
            maxAbsence: 2,
            currentAbsence: 3
        }
    };

    const mockRecommendation = {
        id: 'rec-1',
        conflictId: 'conflict-1',
        priority: ConflictPriority.HIGH,
        confidence: 0.85,
        strategies: [
            {
                type: ResolutionStrategy.SHIFT_DATES,
                description: 'Décaler les dates de congés',
                impact: 'Minimal',
                success_probability: 0.9,
                steps: [
                    'Décaler le début au 22 janvier',
                    'Maintenir la durée de 6 jours'
                ],
                alternative_dates: {
                    startDate: new Date('2025-01-22'),
                    endDate: new Date('2025-01-27')
                }
            },
            {
                type: ResolutionStrategy.FIND_REPLACEMENT,
                description: 'Trouver un remplaçant',
                impact: 'Modéré',
                success_probability: 0.7,
                steps: [
                    'Contacter les praticiens disponibles',
                    'Proposer des heures supplémentaires'
                ],
                suggested_replacements: ['user-3', 'user-4']
            }
        ],
        explanation: 'Ces stratégies permettront de maintenir la continuité de service',
        metadata: {
            analysisTime: 245,
            rulesApplied: ['MIN_TEAM_COVERAGE', 'CRITICAL_PERIOD']
        }
    };

    const mockOnApplyStrategy = jest.fn();
    const mockOnRejectRecommendation = jest.fn();

    const defaultProps = {
        conflict: { ...mockConflict, recommendation: mockRecommendation },
        onApplyStrategy: mockOnApplyStrategy,
        onRejectRecommendation: mockOnRejectRecommendation,
        showDetails: true,
        showActions: true
    };

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    describe('rendering', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should render conflict information correctly', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            expect(screen.getByText(mockConflict.message)).toBeInTheDocument();
            expect(screen.getByTestId('badge')).toHaveAttribute('data-color', 'error');
            expect(screen.getByText('leaves.conflict.priority.high')).toBeInTheDocument();
        });

        it('should display confidence score', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const progress = screen.getByTestId('progress');
            expect(progress).toHaveAttribute('data-value', '85');
            expect(progress).toHaveAttribute('data-max', '100');
        });

        it('should render without recommendation', () => {
            const conflictWithoutRec = { ...mockConflict };
            render(
                <LeaveConflictRecommendation 
                    {...defaultProps} 
                    conflict={conflictWithoutRec}
                />
            );

            expect(screen.getByText('leaves.conflict.no_recommendation')).toBeInTheDocument();
        });

        it('should display affected period', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const formattedPeriod = `${format(mockConflict.startDate, 'dd MMM', { locale: fr })} - ${format(mockConflict.endDate, 'dd MMM yyyy', { locale: fr })}`;
            expect(screen.getByText(formattedPeriod)).toBeInTheDocument();
        });
    });

    describe('strategies display', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should render all strategies', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            expect(screen.getByText('Décaler les dates de congés')).toBeInTheDocument();
            expect(screen.getByText('Trouver un remplaçant')).toBeInTheDocument();
        });

        it('should display strategy details when expanded', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            // Click on first strategy to expand
            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            fireEvent.click(firstStrategy);

            // Check if steps are displayed
            expect(screen.getByText('Décaler le début au 22 janvier')).toBeInTheDocument();
            expect(screen.getByText('Maintenir la durée de 6 jours')).toBeInTheDocument();
        });

        it('should show success probability for each strategy', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            expect(screen.getByText('90%')).toBeInTheDocument(); // First strategy
            expect(screen.getByText('70%')).toBeInTheDocument(); // Second strategy
        });

        it('should display alternative dates for shift strategy', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            // Expand first strategy
            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            fireEvent.click(firstStrategy);

            const altDates = '22 jan - 27 jan 2025';
            expect(screen.getByText(new RegExp(altDates))).toBeInTheDocument();
        });

        it('should display suggested replacements', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            // Expand second strategy
            const secondStrategy = screen.getAllByTestId('list-group-item')[1];
            fireEvent.click(secondStrategy);

            expect(screen.getByText(/user-3.*user-4/)).toBeInTheDocument();
        });
    });

    describe('user interactions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should call onApplyStrategy when applying a strategy', async () => {
            mockOnApplyStrategy.mockResolvedValue(true);
            render(<LeaveConflictRecommendation {...defaultProps} />);

            // Expand first strategy
            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            fireEvent.click(firstStrategy);

            // Click apply button
            const applyButton = screen.getAllByText('leaves.conflict.apply_strategy')[0];
            fireEvent.click(applyButton);

            expect(mockOnApplyStrategy).toHaveBeenCalledWith('conflict-1', 0);

            await waitFor(() => {
                expect(screen.getByText('leaves.conflict.strategy_applied')).toBeInTheDocument();
            });
        });

        it('should handle failed strategy application', async () => {
            mockOnApplyStrategy.mockResolvedValue(false);
            render(<LeaveConflictRecommendation {...defaultProps} />);

            // Expand and apply first strategy
            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            fireEvent.click(firstStrategy);

            const applyButton = screen.getAllByText('leaves.conflict.apply_strategy')[0];
            fireEvent.click(applyButton);

            await waitFor(() => {
                expect(screen.getByText('leaves.conflict.strategy_failed')).toBeInTheDocument();
            });
        });

        it('should disable apply button while applying', async () => {
            mockOnApplyStrategy.mockImplementation(() => 
                new Promise(resolve => setTimeout(() => resolve(true), 100))
            );
            
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            fireEvent.click(firstStrategy);

            const applyButton = screen.getAllByText('leaves.conflict.apply_strategy')[0];
            fireEvent.click(applyButton);

            expect(applyButton).toBeDisabled();

            await waitFor(() => {
                expect(applyButton).not.toBeDisabled();
            });
        });

        it('should call onRejectRecommendation when rejecting', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const rejectButton = screen.getByText('leaves.conflict.reject_all');
            fireEvent.click(rejectButton);

            expect(mockOnRejectRecommendation).toHaveBeenCalledWith('conflict-1', undefined);
        });
    });

    describe('conditional rendering', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should not show actions when showActions is false', () => {
            render(
                <LeaveConflictRecommendation 
                    {...defaultProps} 
                    showActions={false}
                />
            );

            expect(screen.queryByText('leaves.conflict.apply_strategy')).not.toBeInTheDocument();
            expect(screen.queryByText('leaves.conflict.reject_all')).not.toBeInTheDocument();
        });

        it('should not show details when showDetails is false', () => {
            render(
                <LeaveConflictRecommendation 
                    {...defaultProps} 
                    showDetails={false}
                />
            );

            // Should not be able to expand strategies
            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            fireEvent.click(firstStrategy);

            expect(screen.queryByText('Décaler le début au 22 janvier')).not.toBeInTheDocument();
        });

        it('should apply custom className', () => {
            render(
                <LeaveConflictRecommendation 
                    {...defaultProps} 
                    className="custom-class"
                />
            );

            const card = screen.getByTestId('card');
            expect(card).toHaveClass('custom-class');
        });
    });

    describe('severity indicators', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should show appropriate color for HIGH severity', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const badge = screen.getAllByTestId('badge')[0];
            expect(badge).toHaveAttribute('data-color', 'error');
        });

        it('should show appropriate color for MEDIUM severity', () => {
            const mediumConflict = {
                ...mockConflict,
                severity: ConflictSeverity.MEDIUM,
                recommendation: mockRecommendation
            };

            render(
                <LeaveConflictRecommendation 
                    {...defaultProps}
                    conflict={mediumConflict}
                />
            );

            const badge = screen.getAllByTestId('badge')[0];
            expect(badge).toHaveAttribute('data-color', 'warning');
        });

        it('should show appropriate color for LOW severity', () => {
            const lowConflict = {
                ...mockConflict,
                severity: ConflictSeverity.LOW,
                recommendation: mockRecommendation
            };

            render(
                <LeaveConflictRecommendation 
                    {...defaultProps}
                    conflict={lowConflict}
                />
            );

            const badge = screen.getAllByTestId('badge')[0];
            expect(badge).toHaveAttribute('data-color', 'info');
        });
    });

    describe('priority display', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should display HIGH priority correctly', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            expect(screen.getByText('leaves.conflict.priority.high')).toBeInTheDocument();
            const priorityBadge = screen.getAllByTestId('badge').find(
                badge => badge.textContent?.includes('priority')
            );
            expect(priorityBadge).toHaveAttribute('data-color', 'error');
        });

        it('should display MEDIUM priority correctly', () => {
            const mediumPriorityRec = {
                ...mockRecommendation,
                priority: ConflictPriority.MEDIUM
            };

            render(
                <LeaveConflictRecommendation 
                    {...defaultProps}
                    conflict={{ ...mockConflict, recommendation: mediumPriorityRec }}
                />
            );

            expect(screen.getByText('leaves.conflict.priority.medium')).toBeInTheDocument();
        });
    });

    describe('edge cases', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should handle conflicts without dates gracefully', () => {
            const conflictWithoutDates = {
                ...mockConflict,
                startDate: undefined,
                endDate: undefined,
                recommendation: mockRecommendation
            };

            render(
                <LeaveConflictRecommendation 
                    {...defaultProps}
                    conflict={conflictWithoutDates as any}
                />
            );

            // Should not crash and display message
            expect(screen.getByText(mockConflict.message)).toBeInTheDocument();
        });

        it('should handle empty strategies array', () => {
            const recWithoutStrategies = {
                ...mockRecommendation,
                strategies: []
            };

            render(
                <LeaveConflictRecommendation 
                    {...defaultProps}
                    conflict={{ ...mockConflict, recommendation: recWithoutStrategies }}
                />
            );

            expect(screen.getByText('leaves.conflict.no_strategies')).toBeInTheDocument();
        });

        it('should handle strategy without steps', () => {
            const strategyWithoutSteps = {
                ...mockRecommendation,
                strategies: [{
                    ...mockRecommendation.strategies[0],
                    steps: undefined
                }]
            };

            render(
                <LeaveConflictRecommendation 
                    {...defaultProps}
                    conflict={{ ...mockConflict, recommendation: strategyWithoutSteps }}
                />
            );

            // Expand strategy
            const strategy = screen.getByTestId('list-group-item');
            fireEvent.click(strategy);

            // Should show strategy but no steps
            expect(screen.getByText('Décaler les dates de congés')).toBeInTheDocument();
        });

        it('should handle async errors in onApplyStrategy', async () => {
            mockOnApplyStrategy.mockRejectedValue(new Error('Network error'));
            
            // Mock console.error to avoid error output in tests
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
            
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            fireEvent.click(firstStrategy);

            const applyButton = screen.getAllByText('leaves.conflict.apply_strategy')[0];
            fireEvent.click(applyButton);

            await waitFor(() => {
                expect(screen.getByText('leaves.conflict.strategy_error')).toBeInTheDocument();
            });

            consoleSpy.mockRestore();
        });
    });

    describe('accessibility', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should have proper ARIA labels', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const strategies = screen.getAllByTestId('list-group-item');
            strategies.forEach((strategy, index) => {
                expect(strategy).toHaveAttribute('role', 'button');
                expect(strategy).toHaveAttribute('tabIndex', '0');
            });
        });

        it('should be keyboard navigable', () => {
            render(<LeaveConflictRecommendation {...defaultProps} />);

            const firstStrategy = screen.getAllByTestId('list-group-item')[0];
            
            // Simulate Enter key press
            fireEvent.keyPress(firstStrategy, { key: 'Enter', code: 13, charCode: 13 });

            // Should expand
            expect(screen.getByText('Décaler le début au 22 janvier')).toBeInTheDocument();
        });
    });
});