import { renderHook, act, waitFor } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import { useConflictDetection } from '../useConflictDetection';
import { useLeave } from '../useLeave';
import { useLeaveValidation } from '../useLeaveValidation';
import { useDateValidation } from '../useDateValidation';

// Mock des services
jest.mock('../../services/leaveService', () => ({
    checkLeaveConflicts: jest.fn().mockResolvedValue({
        conflicts: [],
        hasBlockers: false,
        hasConflicts: false
    }),
    fetchLeaves: jest.fn().mockResolvedValue([]),
    saveLeave: jest.fn(),
    submitLeaveRequest: jest.fn(),
    calculateLeaveDays: jest.fn().mockReturnValue(5)
}));

jest.mock('@/hooks/useErrorHandler', () => ({
    useErrorHandler: jest.fn(() => ({
        setError: jest.fn(),
        errorState: { errors: {}, globalError: null },
        hasError: false,
        clearError: jest.fn()
    }))
}));

jest.mock('@/context/AuthContext', () => ({
    useAuth: jest.fn(() => ({
        user: { id: 'user-123', name: 'Test User' }
    }))
}));

describe('Hooks Integration Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

    const userId = 'user-123';
    const mockStartDate = new Date();
    mockStartDate.setDate(mockStartDate.getDate() + 1);
    const mockEndDate = new Date();
    mockEndDate.setDate(mockEndDate.getDate() + 5);

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    describe('useDateValidation integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should work as a standalone hook', () => {
            const { result } = renderHook(() => useDateValidation());
            
            expect(result.current).toHaveProperty('validateDate');
            expect(result.current).toHaveProperty('validateDateRange');
            expect(result.current).toHaveProperty('resetErrors');
            expect(result.current).toHaveProperty('hasErrors');
            expect(result.current).toHaveProperty('errors');
        });

        it('should validate dates correctly', () => {
            const { result } = renderHook(() => useDateValidation());
            
            act(() => {
                const isValid = result.current.validateDate(mockStartDate, 'test', { required: true });
                expect(isValid).toBe(true);
            });
        });
    });

    describe('useConflictDetection integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should initialize correctly and use useDateValidation', async () => {
            const { result } = renderHook(() => useConflictDetection({ userId }));
            
            expect(result.current).toHaveProperty('checkConflicts');
            expect(result.current).toHaveProperty('validateDates');
            expect(result.current).toHaveProperty('conflicts');
            expect(result.current).toHaveProperty('hasBlockingConflicts');
            
            // Test validation functionality
            const isValid = result.current.validateDates(mockStartDate, mockEndDate);
            expect(typeof isValid).toBe('boolean');
        });

        it('should check conflicts without errors', async () => {
            const { result } = renderHook(() => useConflictDetection({ userId }));
            
            await act(async () => {
                await result.current.checkConflicts(mockStartDate, mockEndDate, undefined, true);
            });

            expect(result.current.loading).toBe(false);
            expect(result.current.error).toBeNull();
        });
    });

    describe('useLeave integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should initialize correctly', () => {
            const { result } = renderHook(() => useLeave({ userId }));
            
            expect(result.current).toHaveProperty('leave');
            expect(result.current).toHaveProperty('updateLeaveField');
            expect(result.current).toHaveProperty('checkConflicts');
            expect(result.current).toHaveProperty('calculateLeaveDuration');
        });

        it('should handle leave field updates', () => {
            const { result } = renderHook(() => useLeave({ 
                userId,
                initialLeave: { type: 'ANNUAL_LEAVE' as any }
            }));
            
            act(() => {
                result.current.updateLeaveField('type', 'SICK_LEAVE' as any);
            });

            // The hook should handle the update without throwing errors
            expect(result.current.leave?.type).toBe('SICK_LEAVE');
        });
    });

    describe('useLeaveValidation integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should validate leave requests', () => {
            const { result } = renderHook(() => useLeaveValidation());
            
            expect(result.current).toHaveProperty('validateLeaveRequest');
            expect(result.current).toHaveProperty('hasError');
            expect(result.current).toHaveProperty('getErrorMessage');
            expect(result.current).toHaveProperty('resetErrors');
        });

        it('should validate a simple leave request', () => {
            const { result } = renderHook(() => useLeaveValidation());
            
            act(() => {
                const isValid = result.current.validateLeaveRequest(
                    mockStartDate,
                    mockEndDate,
                    userId,
                    { required: true, allowPastDates: false }
                );
                expect(typeof isValid).toBe('boolean');
            });
        });
    });

    describe('Cross-hook integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should allow multiple hooks to work together', async () => {
            const { result: dateValidation } = renderHook(() => useDateValidation());
            const { result: conflictDetection } = renderHook(() => useConflictDetection({ userId }));
            const { result: leaveValidation } = renderHook(() => useLeaveValidation());
            
            // Test that all hooks are functional
            expect(dateValidation.current.validateDate).toBeDefined();
            expect(conflictDetection.current.checkConflicts).toBeDefined();
            expect(leaveValidation.current.validateLeaveRequest).toBeDefined();

            // Test basic operations don't conflict
            act(() => {
                dateValidation.current.validateDate(mockStartDate, 'test', { required: true });
                leaveValidation.current.validateLeaveRequest(mockStartDate, mockEndDate, userId);
            });

            await act(async () => {
                try {
                    await conflictDetection.current.checkConflicts(mockStartDate, mockEndDate, undefined, true);
                } catch (error) {
                    // Expected to potentially fail due to mocked services, but shouldn't crash
                }
            });

            // Verify hooks are still functional after operations
            expect(dateValidation.current.errors).toBeDefined();
            expect(conflictDetection.current.conflicts).toBeDefined();
        });
    });
});