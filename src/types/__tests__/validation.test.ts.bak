import { ViolationType, Violation, ValidationResult } from '../validation';

describe('Validation Types', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    describe('ViolationType enum', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('contient tous les types de violation attendus', () => {
            expect(ViolationType.SCHEDULING_CONFLICT).toBe('SCHEDULING_CONFLICT');
            expect(ViolationType.MIN_DAYS_BETWEEN_ASSIGNMENTS).toBe('MIN_DAYS_BETWEEN_ASSIGNMENTS');
            expect(ViolationType.MAX_ASSIGNMENTS_PER_MONTH).toBe('MAX_ASSIGNMENTS_PER_MONTH');
            expect(ViolationType.MAX_CONSECUTIVE_ASSIGNMENTS).toBe('MAX_CONSECUTIVE_ASSIGNMENTS');
            expect(ViolationType.SPECIAL_DAY_REQUIREMENT).toBe('SPECIAL_DAY_REQUIREMENT');
        });

        it('a exactement 5 types de violation', () => {
            const violationTypes = Object.values(ViolationType);
            expect(violationTypes).toHaveLength(5);
        });

        it('tous les types sont des chaînes de caractères', () => {
            Object.values(ViolationType).forEach(type => {
                expect(typeof type).toBe('string');
                expect(type.length).toBeGreaterThan(0);
            });
        });

        it('tous les types sont en majuscules avec des underscores', () => {
            Object.values(ViolationType).forEach(type => {
                expect(type).toMatch(/^[A-Z_]+$/);
            });
        });

        it('les types sont uniques', () => {
            const types = Object.values(ViolationType);
            const uniqueTypes = new Set(types);
            expect(types.length).toBe(uniqueTypes.size);
        });
    });

    describe('Violation interface', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('peut créer une violation basique', () => {
            const violation: Violation = {
                type: ViolationType.SCHEDULING_CONFLICT,
                message: 'Conflit d'horaire détecté'
            };

            expect(violation.type).toBe(ViolationType.SCHEDULING_CONFLICT);
            expect(violation.message).toBe('Conflit d'horaire détecté');
            expect(violation.data).toBeUndefined();
        });

        it('peut créer une violation avec des données supplémentaires', () => {
            const violation: Violation = {
                type: ViolationType.MAX_ASSIGNMENTS_PER_MONTH,
                message: 'Trop d'affectations ce mois-ci',
                data: {
                    maxAllowed: 5,
                    current: 7,
                    month: 5,
                    year: 2025
                }
            };

            expect(violation.type).toBe(ViolationType.MAX_ASSIGNMENTS_PER_MONTH);
            expect(violation.message).toBe('Trop d'affectations ce mois-ci');
            expect(violation.data).toEqual({
                maxAllowed: 5,
                current: 7,
                month: 5,
                year: 2025
            });
        });

        it('accepte différents types de données', () => {
            const violation: Violation = {
                type: ViolationType.MIN_DAYS_BETWEEN_ASSIGNMENTS,
                message: 'Repos insuffisant',
                data: {
                    string: 'test',
                    number: 42,
                    boolean: true,
                    array: [1, 2, 3],
                    object: { nested: 'value' },
                    null: null,
                    undefined: undefined
                }
            };

            expect(violation.data).toMatchObject({
                string: 'test',
                number: 42,
                boolean: true,
                array: [1, 2, 3],
                object: { nested: 'value' },
                null: null,
                undefined: undefined
            });
        });

        it('peut avoir des données vides', () => {
            const violation: Violation = {
                type: ViolationType.SPECIAL_DAY_REQUIREMENT,
                message: 'Exigence spéciale non respectée',
                data: {}
            };

            expect(violation.data).toEqual({});
        });
    });

    describe('ValidationResult interface', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('peut créer un résultat valide sans violations', () => {
            const result: ValidationResult = {
                isValid: true,
                violations: []
            };

            expect(result.isValid).toBe(true);
            expect(result.violations).toEqual([]);
            expect(result.violations).toHaveLength(0);
        });

        it('peut créer un résultat invalide avec des violations', () => {
            const violations: Violation[] = [
                {
                    type: ViolationType.SCHEDULING_CONFLICT,
                    message: 'Conflit d'horaire'
                },
                {
                    type: ViolationType.MAX_ASSIGNMENTS_PER_MONTH,
                    message: 'Trop d'affectations',
                    data: { count: 6 }
                }
            ];

            const result: ValidationResult = {
                isValid: false,
                violations
            };

            expect(result.isValid).toBe(false);
            expect(result.violations).toHaveLength(2);
            expect(result.violations[0].type).toBe(ViolationType.SCHEDULING_CONFLICT);
            expect(result.violations[1].type).toBe(ViolationType.MAX_ASSIGNMENTS_PER_MONTH);
        });

        it('peut gérer de nombreuses violations', () => {
            const violations: Violation[] = Object.values(ViolationType).map((type, index) => ({
                type,
                message: `Violation ${index + 1}`,
                data: { index }
            }));

            const result: ValidationResult = {
                isValid: false,
                violations
            };

            expect(result.isValid).toBe(false);
            expect(result.violations).toHaveLength(5);
            expect(result.violations.every(v => v.data?.index !== undefined)).toBe(true);
        });

        it('la cohérence entre isValid et violations est maintenue par le développeur', () => {
            // Test des cas cohérents
            const validResult: ValidationResult = {
                isValid: true,
                violations: []
            };

            const invalidResult: ValidationResult = {
                isValid: false,
                violations: [{
                    type: ViolationType.SCHEDULING_CONFLICT,
                    message: 'Erreur'
                }]
            };

            expect(validResult.isValid).toBe(true);
            expect(validResult.violations).toHaveLength(0);
            expect(invalidResult.isValid).toBe(false);
            expect(invalidResult.violations.length).toBeGreaterThan(0);

            // TypeScript permet des états incohérents, c'est au développeur de maintenir la cohérence
            const inconsistentResult: ValidationResult = {
                isValid: true, // Incohérent avec les violations
                violations: [{
                    type: ViolationType.SCHEDULING_CONFLICT,
                    message: 'Erreur'
                }]
            };

            // Ce test vérifie que TypeScript permet cette incohérence
            expect(inconsistentResult.isValid).toBe(true);
            expect(inconsistentResult.violations).toHaveLength(1);
        });
    });

    describe('Cas d'usage pratiques', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('peut créer un résultat de validation complet pour un conflit d'horaire', () => {
            const conflict: Violation = {
                type: ViolationType.SCHEDULING_CONFLICT,
                message: 'Le Dr. Dupont est déjà affecté le 27/05/2025',
                data: {
                    doctorId: 'dr123',
                    doctorName: 'Dr. Dupont',
                    conflictDate: '2025-05-27',
                    existingAssignmentId: 'assign456',
                    newAssignmentId: 'assign789'
                }
            };

            const result: ValidationResult = {
                isValid: false,
                violations: [conflict]
            };

            expect(result.isValid).toBe(false);
            expect(result.violations[0].type).toBe(ViolationType.SCHEDULING_CONFLICT);
            expect(result.violations[0].data?.doctorId).toBe('dr123');
        });

        it('peut créer un résultat pour des violations de règles de repos', () => {
            const restViolation: Violation = {
                type: ViolationType.MIN_DAYS_BETWEEN_ASSIGNMENTS,
                message: 'Repos minimum de 2 jours non respecté entre les affectations',
                data: {
                    doctorId: 'dr456',
                    previousAssignmentDate: '2025-05-25',
                    newAssignmentDate: '2025-05-26',
                    requiredDays: 2,
                    actualDays: 1
                }
            };

            const result: ValidationResult = {
                isValid: false,
                violations: [restViolation]
            };

            expect(result.violations[0].data?.requiredDays).toBe(2);
            expect(result.violations[0].data?.actualDays).toBe(1);
        });

        it('peut créer un résultat pour des violations de quota mensuel', () => {
            const quotaViolation: Violation = {
                type: ViolationType.MAX_ASSIGNMENTS_PER_MONTH,
                message: 'Quota mensuel dépassé: 8 affectations sur 5 autorisées',
                data: {
                    doctorId: 'dr789',
                    month: 5,
                    year: 2025,
                    currentCount: 8,
                    maxAllowed: 5,
                    assignmentIds: ['a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8']
                }
            };

            const result: ValidationResult = {
                isValid: false,
                violations: [quotaViolation]
            };

            expect(result.violations[0].data?.assignmentIds).toHaveLength(8);
        });

        it('peut gérer des violations multiples pour validation complexe', () => {
            const violations: Violation[] = [
                {
                    type: ViolationType.SCHEDULING_CONFLICT,
                    message: 'Conflit d'horaire pour Dr. A',
                    data: { doctorId: 'drA' }
                },
                {
                    type: ViolationType.MAX_CONSECUTIVE_ASSIGNMENTS,
                    message: 'Trop d'affectations consécutives pour Dr. B',
                    data: { doctorId: 'drB', consecutive: 4, maxAllowed: 3 }
                },
                {
                    type: ViolationType.SPECIAL_DAY_REQUIREMENT,
                    message: 'Spécialité requise pour jour férié non disponible',
                    data: { date: '2025-05-01', requiredSpecialty: 'urgence' }
                }
            ];

            const result: ValidationResult = {
                isValid: false,
                violations
            };

            expect(result.violations).toHaveLength(3);
            expect(result.violations.map(v => v.type)).toEqual([
                ViolationType.SCHEDULING_CONFLICT,
                ViolationType.MAX_CONSECUTIVE_ASSIGNMENTS,
                ViolationType.SPECIAL_DAY_REQUIREMENT
            ]);
        });
    });

    describe('Intégrité des types', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('ViolationType enum est compatible avec Violation.type', () => {
            // Test que tous les types d'enum peuvent être utilisés dans Violation
            Object.values(ViolationType).forEach(type => {
                const violation: Violation = {
                    type,
                    message: `Test pour ${type}`
                };

                expect(violation.type).toBe(type);
            });
        });

        it('les structures sont sérialisables en JSON', () => {
            const result: ValidationResult = {
                isValid: false,
                violations: [
                    {
                        type: ViolationType.SCHEDULING_CONFLICT,
                        message: 'Test JSON',
                        data: {
                            date: new Date('2025-05-27'),
                            count: 42,
                            flag: true
                        }
                    }
                ]
            };

            const json = JSON.stringify(result);
            const parsed = JSON.parse(json);

            expect(parsed.isValid).toBe(false);
            expect(parsed.violations[0].type).toBe(ViolationType.SCHEDULING_CONFLICT);
            expect(parsed.violations[0].message).toBe('Test JSON');
            expect(parsed.violations[0].data.count).toBe(42);
        });

        it('les types sont compatibles avec les opérations de filtrage', () => {
            const violations: Violation[] = [
                { type: ViolationType.SCHEDULING_CONFLICT, message: 'A' },
                { type: ViolationType.MAX_ASSIGNMENTS_PER_MONTH, message: 'B' },
                { type: ViolationType.SCHEDULING_CONFLICT, message: 'C' }
            ];

            const conflictViolations = violations.filter(v => 
                v.type === ViolationType.SCHEDULING_CONFLICT
            );

            expect(conflictViolations).toHaveLength(2);
            expect(conflictViolations[0].message).toBe('A');
            expect(conflictViolations[1].message).toBe('C');
        });
    });
});