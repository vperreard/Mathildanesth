import React from 'react';
import { renderWithProviders as render, screen, fireEvent, waitFor } from '@/test-utils/renderWithProviders';
import { ApplySimulationModal } from '../ApplySimulationModal';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';

// Mocks
jest.mock('next/navigation', () => ({
    useRouter: jest.fn()
}));

jest.mock('sonner', () => ({
    toast: {
        success: jest.fn(),
        error: jest.fn()
    }
}));

// Mock global fetch
global.fetch = jest.fn();

describe('ApplySimulationModal', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    // Données de test
    const mockSimulationResult = {
        id: 'result-123',
        scenarioId: 'scenario-456',
        scenarioName: 'Test Scenario',
        status: 'COMPLETED'
    };

    const mockProps = {
        isOpen: true,
        onClose: jest.fn(),
        simulationResult: mockSimulationResult,
        onSuccess: jest.fn()
    };

    const mockRouter = {
        push: jest.fn(),
        refresh: jest.fn()
    };

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
        (useRouter as jest.Mock).mockReturnValue(mockRouter);
        (global.fetch as jest.Mock).mockResolvedValue({
            ok: true,
            json: jest.fn().mockResolvedValue({
                success: true,
                message: 'Simulation appliquée avec succès',
                data: {
                    assignmentsCreated: 10,
                    assignmentsUpdated: 5,
                    leavesCreated: 0,
                    conflicts: 0
                }
            })
        });
    });

    it('doit rendre correctement le modal avec les options', () => {
        // Act
        render(<ApplySimulationModal {...mockProps} />);

        // Assert
        expect(screen.getByText('Appliquer la simulation au planning réel')).toBeInTheDocument();
        expect(screen.getByText('Supprimer les assignments existantes dans la période')).toBeInTheDocument();
        expect(screen.getByText('Inclure les congés validés de la simulation')).toBeInTheDocument();
        expect(screen.getByText('Inclure les gardes et astreintes')).toBeInTheDocument();
        expect(screen.getByText('Appliquer au planning')).toBeInTheDocument();
        expect(screen.getByText('Annuler')).toBeInTheDocument();
    });

    it('doit appeler onClose lorsque le bouton Annuler est cliqué', () => {
        // Arrange
        render(<ApplySimulationModal {...mockProps} />);

        // Act
        fireEvent.click(screen.getByText('Annuler'));

        // Assert
        expect(mockProps.onClose).toHaveBeenCalledTimes(1);
    });

    it('doit changer les options lorsque les cases à cocher sont cliquées', () => {
        // Arrange
        render(<ApplySimulationModal {...mockProps} />);

        // Les cases à cocher devraient être initialement non cochées ou cochées selon les valeurs par défaut
        const clearExistingCheckbox = screen.getByLabelText('Supprimer les assignments existantes dans la période');
        const includeLeavesCheckbox = screen.getByLabelText('Inclure les congés validés de la simulation');
        const includeOnCallCheckbox = screen.getByLabelText('Inclure les gardes et astreintes');

        expect(clearExistingCheckbox).not.toBeChecked();
        expect(includeLeavesCheckbox).not.toBeChecked();
        expect(includeOnCallCheckbox).toBeChecked(); // Par défaut true

        // Act - Changer les valeurs
        fireEvent.click(clearExistingCheckbox);
        fireEvent.click(includeLeavesCheckbox);
        fireEvent.click(includeOnCallCheckbox);

        // Assert - Les valeurs devraient être inversées
        expect(clearExistingCheckbox).toBeChecked();
        expect(includeLeavesCheckbox).toBeChecked();
        expect(includeOnCallCheckbox).not.toBeChecked();
    });

    it('doit soumettre correctement les options à l'API', async () => {
        // Arrange
        render(<ApplySimulationModal {...mockProps} />);

        // Cocher certaines options
        fireEvent.click(screen.getByLabelText('Supprimer les assignments existantes dans la période'));

        // Ajouter des notes
        fireEvent.change(screen.getByPlaceholderText('Raisons de l'application, notes pour l'équipe, etc.'), {
            target: { value: 'Test notes' }
        });

        // Act
        fireEvent.click(screen.getByText('Appliquer au planning'));

        // Assert
        await waitFor(() => {
            expect(global.fetch).toHaveBeenCalledWith('/api/simulations/apply', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    simulationResultId: mockSimulationResult.id,
                    clearExistingAssignments: true,
                    includeLeaves: false,
                    includeOnCall: true,
                    notes: 'Test notes',
                }),
            });
        });
    });

    it('doit afficher un toast de succès et fermer le modal lorsque la requête réussit', async () => {
        // Arrange
        render(<ApplySimulationModal {...mockProps} />);

        // Act
        fireEvent.click(screen.getByText('Appliquer au planning'));

        // Assert
        await waitFor(() => {
            expect(toast.success).toHaveBeenCalledWith(
                'Simulation appliquée au planning avec succès',
                expect.any(Object)
            );
            expect(mockProps.onClose).toHaveBeenCalled();
            expect(mockProps.onSuccess).toHaveBeenCalled();
        });
    });

    it('doit rediriger vers la page du planning hebdomadaire si onSuccess n'est pas fourni', async () => {
        // Arrange
        const propsWithoutOnSuccess = { ...mockProps, onSuccess: undefined };
        render(<ApplySimulationModal {...propsWithoutOnSuccess} />);

        // Act
        fireEvent.click(screen.getByText('Appliquer au planning'));

        // Assert
        await waitFor(() => {
            expect(mockRouter.push).toHaveBeenCalledWith('/planning/hebdomadaire');
            expect(mockRouter.refresh).toHaveBeenCalled();
        });
    });

    it('doit afficher une erreur si la requête échoue', async () => {
        // Arrange
        (global.fetch as jest.Mock).mockResolvedValue({
            ok: false,
            json: jest.fn().mockResolvedValue({
                error: 'Erreur pendant l'application de la simulation',
                conflicts: [{ type: 'ERROR', message: 'Détail de l'erreur' }]
            })
        });

        render(<ApplySimulationModal {...mockProps} />);

        // Act
        fireEvent.click(screen.getByText('Appliquer au planning'));

        // Assert
        await waitFor(() => {
            expect(screen.getByText('Erreur pendant l'application de la simulation')).toBeInTheDocument();
            expect(mockProps.onClose).not.toHaveBeenCalled();
        });
    });

    it('doit afficher une erreur de serveur si fetch échoue', async () => {
        // Arrange
        (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

        render(<ApplySimulationModal {...mockProps} />);

        // Act
        fireEvent.click(screen.getByText('Appliquer au planning'));

        // Assert
        await waitFor(() => {
            expect(screen.getByText('Une erreur est survenue lors de la communication avec le serveur')).toBeInTheDocument();
            expect(mockProps.onClose).not.toHaveBeenCalled();
        });
    });
}); 
