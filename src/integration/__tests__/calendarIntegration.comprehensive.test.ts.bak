import { jest, describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import React from 'react';

// Mock des services et utilitaires
import EventBusService from '@/services/eventBusService';
import { parseDate, formatDate, getDaysBetween, isDateWeekend } from '@/utils/dateUtils';
import { getPublicHolidays, getFrenchPublicHolidays } from '@/services/calendarService';

// Mock des types
interface Leave {
  id: string;
  userId: string;
  startDate: Date;
  endDate: Date;
  type: 'VACATION' | 'SICK' | 'MATERNITY' | 'TRAINING';
  status: 'PENDING' | 'APPROVED' | 'REJECTED';
}

interface Planning {
  id: string;
  userId: string;
  date: Date;
  shift: 'DAY' | 'NIGHT' | 'ON_CALL';
  specialty: string;
}

interface CalendarEvent {
  id: string;
  title: string;
  start: Date;
  end: Date;
  type: 'LEAVE' | 'PLANNING' | 'HOLIDAY' | 'MAINTENANCE';
  data?: any;
}

// Mock des services d'intégration
class CalendarIntegrationService {
  private eventBus: EventBusService;
  private events: CalendarEvent[] = [];

  constructor() {
    this.eventBus = EventBusService.getInstance();
    this.setupEventListeners();
  }

  private setupEventListeners() {
    this.eventBus.subscribe('leave-created', this.handleLeaveCreated.bind(this));
    this.eventBus.subscribe('leave-updated', this.handleLeaveUpdated.bind(this));
    this.eventBus.subscribe('leave-deleted', this.handleLeaveDeleted.bind(this));
    this.eventBus.subscribe('planning-updated', this.handlePlanningUpdated.bind(this));
    this.eventBus.subscribe('planning-deleted', this.handlePlanningDeleted.bind(this));
  }

  private handleLeaveCreated(event: { type: string; data: Leave }) {
    const calendarEvent: CalendarEvent = {
      id: `leave-${event.data.id}`,
      title: `Congé ${event.data.type}`,
      start: event.data.startDate,
      end: event.data.endDate,
      type: 'LEAVE',
      data: event.data
    };
    this.events.push(calendarEvent);
    this.eventBus.emit({ type: 'calendar-event-added', data: calendarEvent });
  }

  private handleLeaveUpdated(event: { type: string; data: Leave }) {
    const existingIndex = this.events.findIndex(e => e.id === `leave-${event.data.id}`);
    if (existingIndex !== -1) {
      this.events[existingIndex] = {
        ...this.events[existingIndex],
        title: `Congé ${event.data.type}`,
        start: event.data.startDate,
        end: event.data.endDate,
        data: event.data
      };
      this.eventBus.emit({ type: 'calendar-event-updated', data: this.events[existingIndex] });
    }
  }

  private handleLeaveDeleted(event: { type: string; data: { id: string } }) {
    const index = this.events.findIndex(e => e.id === `leave-${event.data.id}`);
    if (index !== -1) {
      const deletedEvent = this.events.splice(index, 1)[0];
      this.eventBus.emit({ type: 'calendar-event-deleted', data: deletedEvent });
    }
  }

  private handlePlanningUpdated(event: { type: string; data: Planning[] }) {
    // Supprimer les anciens événements de planning
    this.events = this.events.filter(e => e.type !== 'PLANNING');
    
    // Ajouter les nouveaux événements de planning
    event.data.forEach(planning => {
      const calendarEvent: CalendarEvent = {
        id: `planning-${planning.id}`,
        title: `${planning.specialty} - ${planning.shift}`,
        start: planning.date,
        end: new Date(planning.date.getTime() + (planning.shift === 'DAY' ? 12 : 12) * 60 * 60 * 1000),
        type: 'PLANNING',
        data: planning
      };
      this.events.push(calendarEvent);
    });
    
    this.eventBus.emit({ type: 'calendar-events-bulk-updated', data: this.events });
  }

  private handlePlanningDeleted(event: { type: string; data: { id: string } }) {
    const index = this.events.findIndex(e => e.id === `planning-${event.data.id}`);
    if (index !== -1) {
      const deletedEvent = this.events.splice(index, 1)[0];
      this.eventBus.emit({ type: 'calendar-event-deleted', data: deletedEvent });
    }
  }

  public getEvents(): CalendarEvent[] {
    return [...this.events];
  }

  public async synchronizeHolidays(year: number): Promise<void> {
    try {
      const holidays = await getPublicHolidays(year, year);
      const frenchHolidays = getFrenchPublicHolidays(year);
      
      // Combiner les jours fériés
      const allHolidays = [...holidays, ...frenchHolidays];
      const uniqueHolidays = allHolidays.filter((holiday, index, self) => 
        self.findIndex(h => h.getTime() === holiday.getTime()) === index
      );

      // Supprimer les anciens jours fériés
      this.events = this.events.filter(e => e.type !== 'HOLIDAY');

      // Ajouter les nouveaux jours fériés
      uniqueHolidays.forEach((holiday, index) => {
        const calendarEvent: CalendarEvent = {
          id: `holiday-${year}-${index}`,
          title: 'Jour férié',
          start: holiday,
          end: holiday,
          type: 'HOLIDAY',
          data: { isPublicHoliday: true }
        };
        this.events.push(calendarEvent);
      });

      this.eventBus.emit({ type: 'holidays-synchronized', data: { year, count: uniqueHolidays.length } });
    } catch (error) {
      this.eventBus.emit({ type: 'holiday-sync-error', data: { year, error } });
    }
  }

  public detectConflicts(): Array<{ type: string; events: CalendarEvent[]; message: string }> {
    const conflicts = [];
    
    // Détecter les conflits congés vs planning
    const leaveEvents = this.events.filter(e => e.type === 'LEAVE' && e.data?.status === 'APPROVED');
    const planningEvents = this.events.filter(e => e.type === 'PLANNING');

    leaveEvents.forEach(leave => {
      const conflictingPlanning = planningEvents.filter(planning => {
        const leaveStart = leave.start.getTime();
        const leaveEnd = leave.end.getTime();
        const planningStart = planning.start.getTime();
        const planningEnd = planning.end.getTime();

        // Vérifier si les périodes se chevauchent
        return (planningStart <= leaveEnd && planningEnd >= leaveStart) &&
               leave.data?.userId === planning.data?.userId;
      });

      if (conflictingPlanning.length > 0) {
        conflicts.push({
          type: 'LEAVE_PLANNING_CONFLICT',
          events: [leave, ...conflictingPlanning],
          message: `Conflit: congé approuvé mais planning assigné pour ${leave.data?.userId}`
        });
      }
    });

    // Détecter les doubles plannings
    const planningByUser = new Map<string, Planning[]>();
    planningEvents.forEach(event => {
      const userId = event.data?.userId;
      if (userId) {
        if (!planningByUser.has(userId)) {
          planningByUser.set(userId, []);
        }
        planningByUser.get(userId)!.push(event.data);
      }
    });

    planningByUser.forEach((userPlannings, userId) => {
      for (let i = 0; i < userPlannings.length; i++) {
        for (let j = i + 1; j < userPlannings.length; j++) {
          const planning1 = userPlannings[i];
          const planning2 = userPlannings[j];
          
          if (planning1.date.getTime() === planning2.date.getTime()) {
            conflicts.push({
              type: 'DOUBLE_PLANNING',
              events: [
                this.events.find(e => e.id === `planning-${planning1.id}`)!,
                this.events.find(e => e.id === `planning-${planning2.id}`)!
              ],
              message: `Double planning détecté pour ${userId} le ${formatDate(planning1.date)}`
            });
          }
        }
      }
    });

    return conflicts;
  }

  public generateMetrics(startDate: Date, endDate: Date) {
    const period = getDaysBetween(startDate, endDate);
    const eventsInPeriod = this.events.filter(event => 
      event.start >= startDate && event.end <= endDate
    );

    const weekendEvents = eventsInPeriod.filter(event => 
      isDateWeekend(event.start) || isDateWeekend(event.end)
    );

    const holidayEvents = eventsInPeriod.filter(event => 
      event.type === 'HOLIDAY'
    );

    const leaveEvents = eventsInPeriod.filter(event => 
      event.type === 'LEAVE' && event.data?.status === 'APPROVED'
    );

    const planningEvents = eventsInPeriod.filter(event => 
      event.type === 'PLANNING'
    );

    return {
      totalDays: period,
      totalEvents: eventsInPeriod.length,
      weekendEvents: weekendEvents.length,
      holidays: holidayEvents.length,
      approvedLeaves: leaveEvents.length,
      plannedShifts: planningEvents.length,
      conflicts: this.detectConflicts().length,
      coverageRate: planningEvents.length / Math.max(1, period - holidayEvents.length) * 100
    };
  }
}

describe('Intégration Calendrier - Tests Complets Système Médical', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

  let integrationService: CalendarIntegrationService;
  let eventBus: EventBusService;
  const user = userEvent.setup();

  beforeEach(() => {
    jest.clearAllMocks();
    // Réinitialiser les singletons
    (EventBusService as any).instance = undefined;
    eventBus = EventBusService.getInstance();
    integrationService = new CalendarIntegrationService();
    
    jest.clearAllMocks();
  });

  afterEach(() => {
    eventBus.clearAllListeners();
  });

  describe('CRITICITÉ HAUTE - Intégration Congés ↔ Calendrier', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait synchroniser la création de congés vers le calendrier', () => {
      const calendarEventListener = jest.fn();
      eventBus.subscribe('calendar-event-added', calendarEventListener);

      const newLeave: Leave = {
        id: 'leave-001',
        userId: 'user-123',
        startDate: new Date('2024-03-20T00:00:00'),
        endDate: new Date('2024-03-25T00:00:00'),
        type: 'VACATION',
        status: 'APPROVED'
      };

      // Émettre création de congé
      eventBus.emit({ type: 'leave-created', data: newLeave });

      expect(calendarEventListener).toHaveBeenCalledWith({
        type: 'calendar-event-added',
        data: {
          id: 'leave-leave-001',
          title: 'Congé VACATION',
          start: newLeave.startDate,
          end: newLeave.endDate,
          type: 'LEAVE',
          data: newLeave
        }
      });

      const events = integrationService.getEvents();
      expect(events).toHaveLength(1);
      expect(events[0].type).toBe('LEAVE');
    });

    it('devrait mettre à jour les événements calendrier lors de modification de congés', () => {
      // Créer un congé initial
      const initialLeave: Leave = {
        id: 'leave-002',
        userId: 'user-456',
        startDate: new Date('2024-04-01T00:00:00'),
        endDate: new Date('2024-04-05T00:00:00'),
        type: 'SICK',
        status: 'PENDING'
      };

      eventBus.emit({ type: 'leave-created', data: initialLeave });

      const updateListener = jest.fn();
      eventBus.subscribe('calendar-event-updated', updateListener);

      // Mettre à jour le congé
      const updatedLeave: Leave = {
        ...initialLeave,
        startDate: new Date('2024-04-02T00:00:00'),
        endDate: new Date('2024-04-07T00:00:00'),
        status: 'APPROVED'
      };

      eventBus.emit({ type: 'leave-updated', data: updatedLeave });

      expect(updateListener).toHaveBeenCalledWith({
        type: 'calendar-event-updated',
        data: expect.objectContaining({
          id: 'leave-leave-002',
          title: 'Congé SICK',
          start: updatedLeave.startDate,
          end: updatedLeave.endDate
        })
      });

      const events = integrationService.getEvents();
      expect(events[0].start).toEqual(updatedLeave.startDate);
      expect(events[0].end).toEqual(updatedLeave.endDate);
    });

    it('devrait supprimer les événements calendrier lors de suppression de congés', () => {
      // Créer un congé
      const leaveToDelete: Leave = {
        id: 'leave-003',
        userId: 'user-789',
        startDate: new Date('2024-05-01T00:00:00'),
        endDate: new Date('2024-05-03T00:00:00'),
        type: 'TRAINING',
        status: 'APPROVED'
      };

      eventBus.emit({ type: 'leave-created', data: leaveToDelete });
      expect(integrationService.getEvents()).toHaveLength(1);

      const deleteListener = jest.fn();
      eventBus.subscribe('calendar-event-deleted', deleteListener);

      // Supprimer le congé
      eventBus.emit({ type: 'leave-deleted', data: { id: 'leave-003' } });

      expect(deleteListener).toHaveBeenCalledWith({
        type: 'calendar-event-deleted',
        data: expect.objectContaining({
          id: 'leave-leave-003'
        })
      });

      expect(integrationService.getEvents()).toHaveLength(0);
    });

    it('devrait gérer plusieurs congés simultanément', () => {
      const leaves: Leave[] = [
        {
          id: 'leave-004',
          userId: 'user-001',
          startDate: new Date('2024-06-01T00:00:00'),
          endDate: new Date('2024-06-07T00:00:00'),
          type: 'VACATION',
          status: 'APPROVED'
        },
        {
          id: 'leave-005',
          userId: 'user-002',
          startDate: new Date('2024-06-10T00:00:00'),
          endDate: new Date('2024-06-15T00:00:00'),
          type: 'SICK',
          status: 'PENDING'
        },
        {
          id: 'leave-006',
          userId: 'user-003',
          startDate: new Date('2024-06-20T00:00:00'),
          endDate: new Date('2024-06-25T00:00:00'),
          type: 'MATERNITY',
          status: 'APPROVED'
        }
      ];

      leaves.forEach(leave => {
        eventBus.emit({ type: 'leave-created', data: leave });
      });

      const events = integrationService.getEvents();
      expect(events).toHaveLength(3);
      expect(events.every(e => e.type === 'LEAVE')).toBe(true);
    });
  });

  describe('CRITICITÉ HAUTE - Intégration Planning ↔ Calendrier', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait synchroniser les mises à jour de planning en masse', () => {
      const bulkUpdateListener = jest.fn();
      eventBus.subscribe('calendar-events-bulk-updated', bulkUpdateListener);

      const planningData: Planning[] = [
        {
          id: 'plan-001',
          userId: 'user-001',
          date: new Date('2024-03-15T08:00:00'),
          shift: 'DAY',
          specialty: 'ANESTHESIA'
        },
        {
          id: 'plan-002',
          userId: 'user-002',
          date: new Date('2024-03-15T20:00:00'),
          shift: 'NIGHT',
          specialty: 'SURGERY'
        },
        {
          id: 'plan-003',
          userId: 'user-003',
          date: new Date('2024-03-16T08:00:00'),
          shift: 'DAY',
          specialty: 'EMERGENCY'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: planningData });

      expect(bulkUpdateListener).toHaveBeenCalledWith({
        type: 'calendar-events-bulk-updated',
        data: expect.arrayContaining([
          expect.objectContaining({
            id: 'planning-plan-001',
            title: 'ANESTHESIA - DAY',
            type: 'PLANNING'
          }),
          expect.objectContaining({
            id: 'planning-plan-002',
            title: 'SURGERY - NIGHT',
            type: 'PLANNING'
          }),
          expect.objectContaining({
            id: 'planning-plan-003',
            title: 'EMERGENCY - DAY',
            type: 'PLANNING'
          })
        ])
      });

      const events = integrationService.getEvents();
      const planningEvents = events.filter(e => e.type === 'PLANNING');
      expect(planningEvents).toHaveLength(3);
    });

    it('devrait remplacer les anciens plannings lors des mises à jour', () => {
      // Créer planning initial
      const initialPlanning: Planning[] = [
        {
          id: 'plan-004',
          userId: 'user-004',
          date: new Date('2024-04-01T08:00:00'),
          shift: 'DAY',
          specialty: 'CARDIOLOGY'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: initialPlanning });
      expect(integrationService.getEvents().filter(e => e.type === 'PLANNING')).toHaveLength(1);

      // Nouvelle mise à jour avec planning différent
      const updatedPlanning: Planning[] = [
        {
          id: 'plan-005',
          userId: 'user-005',
          date: new Date('2024-04-01T08:00:00'),
          shift: 'DAY',
          specialty: 'NEUROLOGY'
        },
        {
          id: 'plan-006',
          userId: 'user-006',
          date: new Date('2024-04-01T20:00:00'),
          shift: 'NIGHT',
          specialty: 'NEUROLOGY'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: updatedPlanning });

      const planningEvents = integrationService.getEvents().filter(e => e.type === 'PLANNING');
      expect(planningEvents).toHaveLength(2);
      expect(planningEvents.find(e => e.id === 'planning-plan-004')).toBeUndefined();
      expect(planningEvents.find(e => e.id === 'planning-plan-005')).toBeDefined();
      expect(planningEvents.find(e => e.id === 'planning-plan-006')).toBeDefined();
    });

    it('devrait supprimer des plannings individuels', () => {
      const planning: Planning[] = [
        {
          id: 'plan-007',
          userId: 'user-007',
          date: new Date('2024-05-01T08:00:00'),
          shift: 'DAY',
          specialty: 'PEDIATRICS'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: planning });
      expect(integrationService.getEvents().filter(e => e.type === 'PLANNING')).toHaveLength(1);

      const deleteListener = jest.fn();
      eventBus.subscribe('calendar-event-deleted', deleteListener);

      eventBus.emit({ type: 'planning-deleted', data: { id: 'plan-007' } });

      expect(deleteListener).toHaveBeenCalledWith({
        type: 'calendar-event-deleted',
        data: expect.objectContaining({
          id: 'planning-plan-007'
        })
      });

      expect(integrationService.getEvents().filter(e => e.type === 'PLANNING')).toHaveLength(0);
    });
  });

  describe('CRITICITÉ HAUTE - Synchronisation Jours Fériés', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait synchroniser les jours fériés depuis l'API', async () => {
      const syncListener = jest.fn();
      eventBus.subscribe('holidays-synchronized', syncListener);

      // Mock des services de jours fériés
      jest.doMock('@/services/calendarService', () => ({
        getPublicHolidays: jest.fn().mockResolvedValue([
          new Date('2024-01-01'),
          new Date('2024-05-01'),
          new Date('2024-07-14')
        ]),
        getFrenchPublicHolidays: jest.fn().mockReturnValue([
          new Date('2024-01-01'),
          new Date('2024-05-01'),
          new Date('2024-07-14'),
          new Date('2024-08-15'),
          new Date('2024-11-01'),
          new Date('2024-12-25')
        ])
      }));

      await integrationService.synchronizeHolidays(2024);

      expect(syncListener).toHaveBeenCalledWith({
        type: 'holidays-synchronized',
        data: { year: 2024, count: expect.any(Number) }
      });

      const holidayEvents = integrationService.getEvents().filter(e => e.type === 'HOLIDAY');
      expect(holidayEvents.length).toBeGreaterThan(0);
    });

    it('devrait gérer les erreurs de synchronisation des jours fériés', async () => {
      const errorListener = jest.fn();
      eventBus.subscribe('holiday-sync-error', errorListener);

      // Mock d'une erreur API
      jest.doMock('@/services/calendarService', () => ({
        getPublicHolidays: jest.fn().mockRejectedValue(new Error('API Error')),
        getFrenchPublicHolidays: jest.fn().mockReturnValue([])
      }));

      await integrationService.synchronizeHolidays(2024);

      expect(errorListener).toHaveBeenCalledWith({
        type: 'holiday-sync-error',
        data: { year: 2024, error: expect.any(Error) }
      });
    });

    it('devrait éviter les doublons de jours fériés', async () => {
      // Mock avec dates en doublon
      jest.doMock('@/services/calendarService', () => ({
        getPublicHolidays: jest.fn().mockResolvedValue([
          new Date('2024-01-01'),
          new Date('2024-05-01')
        ]),
        getFrenchPublicHolidays: jest.fn().mockReturnValue([
          new Date('2024-01-01'), // Doublon
          new Date('2024-05-01'), // Doublon
          new Date('2024-12-25')
        ])
      }));

      await integrationService.synchronizeHolidays(2024);

      const holidayEvents = integrationService.getEvents().filter(e => e.type === 'HOLIDAY');
      
      // Vérifier absence de doublons
      const uniqueDates = new Set(holidayEvents.map(e => e.start.getTime()));
      expect(holidayEvents.length).toBe(uniqueDates.size);
    });
  });

  describe('CRITICITÉ HAUTE - Détection de Conflits', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait détecter les conflits congés vs planning', () => {
      // Créer un congé approuvé
      const leave: Leave = {
        id: 'leave-conflict-001',
        userId: 'user-conflict',
        startDate: new Date('2024-07-15T00:00:00'),
        endDate: new Date('2024-07-17T00:00:00'),
        type: 'VACATION',
        status: 'APPROVED'
      };

      eventBus.emit({ type: 'leave-created', data: leave });

      // Créer un planning qui entre en conflit
      const conflictingPlanning: Planning[] = [
        {
          id: 'plan-conflict-001',
          userId: 'user-conflict',
          date: new Date('2024-07-16T08:00:00'),
          shift: 'DAY',
          specialty: 'SURGERY'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: conflictingPlanning });

      const conflicts = integrationService.detectConflicts();
      expect(conflicts).toHaveLength(1);
      expect(conflicts[0].type).toBe('LEAVE_PLANNING_CONFLICT');
      expect(conflicts[0].message).toContain('user-conflict');
    });

    it('devrait détecter les doubles plannings', () => {
      const doublePlanning: Planning[] = [
        {
          id: 'plan-double-001',
          userId: 'user-double',
          date: new Date('2024-08-01T08:00:00'),
          shift: 'DAY',
          specialty: 'EMERGENCY'
        },
        {
          id: 'plan-double-002',
          userId: 'user-double',
          date: new Date('2024-08-01T08:00:00'), // Même date
          shift: 'DAY',
          specialty: 'SURGERY'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: doublePlanning });

      const conflicts = integrationService.detectConflicts();
      expect(conflicts).toHaveLength(1);
      expect(conflicts[0].type).toBe('DOUBLE_PLANNING');
      expect(conflicts[0].message).toContain('user-double');
    });

    it('devrait ignorer les congés non approuvés dans la détection de conflits', () => {
      // Congé en attente
      const pendingLeave: Leave = {
        id: 'leave-pending',
        userId: 'user-pending',
        startDate: new Date('2024-09-01T00:00:00'),
        endDate: new Date('2024-09-03T00:00:00'),
        type: 'SICK',
        status: 'PENDING'
      };

      eventBus.emit({ type: 'leave-created', data: pendingLeave });

      // Planning qui pourrait entrer en conflit
      const planning: Planning[] = [
        {
          id: 'plan-pending',
          userId: 'user-pending',
          date: new Date('2024-09-02T08:00:00'),
          shift: 'DAY',
          specialty: 'CARDIOLOGY'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: planning });

      const conflicts = integrationService.detectConflicts();
      expect(conflicts).toHaveLength(0); // Pas de conflit car congé non approuvé
    });
  });

  describe('CRITICITÉ MOYENNE - Métriques et Rapports', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait générer des métriques de période complètes', () => {
      // Créer des données test complètes
      const leaves: Leave[] = [
        {
          id: 'metric-leave-001',
          userId: 'user-metric-001',
          startDate: new Date('2024-10-05T00:00:00'),
          endDate: new Date('2024-10-07T00:00:00'),
          type: 'VACATION',
          status: 'APPROVED'
        }
      ];

      const planning: Planning[] = [
        {
          id: 'metric-plan-001',
          userId: 'user-metric-002',
          date: new Date('2024-10-01T08:00:00'),
          shift: 'DAY',
          specialty: 'EMERGENCY'
        },
        {
          id: 'metric-plan-002',
          userId: 'user-metric-003',
          date: new Date('2024-10-02T20:00:00'),
          shift: 'NIGHT',
          specialty: 'SURGERY'
        }
      ];

      leaves.forEach(leave => eventBus.emit({ type: 'leave-created', data: leave }));
      eventBus.emit({ type: 'planning-updated', data: planning });

      // Synchroniser jours fériés
      const holidays = [new Date('2024-10-15')];
      holidays.forEach((holiday, index) => {
        integrationService.getEvents().push({
          id: `holiday-${index}`,
          title: 'Jour férié',
          start: holiday,
          end: holiday,
          type: 'HOLIDAY',
          data: { isPublicHoliday: true }
        });
      });

      const startDate = new Date('2024-10-01T00:00:00');
      const endDate = new Date('2024-10-31T23:59:59');
      const metrics = integrationService.generateMetrics(startDate, endDate);

      expect(metrics.totalDays).toBe(31);
      expect(metrics.approvedLeaves).toBe(1);
      expect(metrics.plannedShifts).toBe(2);
      expect(metrics.holidays).toBe(1);
      expect(metrics.conflicts).toBe(0);
      expect(metrics.coverageRate).toBeGreaterThan(0);
    });

    it('devrait calculer le taux de couverture correctement', () => {
      const planning: Planning[] = Array.from({ length: 25 }, (_, i) => ({
        id: `coverage-plan-${i}`,
        userId: `user-${i % 10}`,
        date: new Date(`2024-11-${(i % 30) + 1}T08:00:00`),
        shift: 'DAY' as const,
        specialty: 'GENERAL'
      }));

      eventBus.emit({ type: 'planning-updated', data: planning });

      const startDate = new Date('2024-11-01T00:00:00');
      const endDate = new Date('2024-11-30T23:59:59');
      const metrics = integrationService.generateMetrics(startDate, endDate);

      // 25 shifts pour 30 jours = 83.33% de couverture
      expect(metrics.coverageRate).toBeCloseTo(83.33, 1);
    });

    it('devrait identifier les événements de week-end', () => {
      const weekendPlanning: Planning[] = [
        {
          id: 'weekend-plan-001',
          userId: 'user-weekend',
          date: new Date('2024-12-07T08:00:00'), // Samedi
          shift: 'DAY',
          specialty: 'EMERGENCY'
        },
        {
          id: 'weekend-plan-002',
          userId: 'user-weekend',
          date: new Date('2024-12-08T08:00:00'), // Dimanche
          shift: 'DAY',
          specialty: 'EMERGENCY'
        }
      ];

      eventBus.emit({ type: 'planning-updated', data: weekendPlanning });

      const startDate = new Date('2024-12-01T00:00:00');
      const endDate = new Date('2024-12-31T23:59:59');
      const metrics = integrationService.generateMetrics(startDate, endDate);

      expect(metrics.weekendEvents).toBe(2);
    });
  });

  describe('PERFORMANCE ET ROBUSTESSE', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait gérer de gros volumes de données efficacement', () => {
      const startTime = performance.now();

      // Créer 1000 événements de planning
      const largePlanning: Planning[] = Array.from({ length: 1000 }, (_, i) => ({
        id: `large-plan-${i}`,
        userId: `user-${i % 100}`,
        date: new Date(`2024-01-${(i % 30) + 1}T08:00:00`),
        shift: 'DAY' as const,
        specialty: `SPECIALTY-${i % 10}`
      }));

      eventBus.emit({ type: 'planning-updated', data: largePlanning });

      const endTime = performance.now();
      expect(endTime - startTime).toBeLessThan(1000); // <1s pour 1000 événements

      const events = integrationService.getEvents();
      expect(events.filter(e => e.type === 'PLANNING')).toHaveLength(1000);
    });

    it('devrait maintenir la performance lors de détection de conflits sur gros volumes', () => {
      // Créer un grand nombre d'événements avec des conflits potentiels
      const users = Array.from({ length: 50 }, (_, i) => `user-perf-${i}`);
      
      users.forEach(userId => {
        // Ajouter congé
        const leave: Leave = {
          id: `perf-leave-${userId}`,
          userId,
          startDate: new Date('2024-01-15T00:00:00'),
          endDate: new Date('2024-01-17T00:00:00'),
          type: 'VACATION',
          status: 'APPROVED'
        };
        eventBus.emit({ type: 'leave-created', data: leave });

        // Ajouter planning qui entre en conflit
        const planning: Planning[] = [{
          id: `perf-plan-${userId}`,
          userId,
          date: new Date('2024-01-16T08:00:00'),
          shift: 'DAY',
          specialty: 'GENERAL'
        }];
        eventBus.emit({ type: 'planning-updated', data: planning });
      });

      const startTime = performance.now();
      const conflicts = integrationService.detectConflicts();
      const endTime = performance.now();

      expect(conflicts).toHaveLength(50); // Un conflit par utilisateur
      expect(endTime - startTime).toBeLessThan(100); // <100ms pour 50 conflits
    });

    it('devrait être stable avec des événements concurrents', () => {
      // Simuler des événements concurrents
      const concurrentEvents = Array.from({ length: 100 }, (_, i) => ({
        type: i % 2 === 0 ? 'leave-created' : 'planning-updated',
        data: i % 2 === 0 ? {
          id: `concurrent-leave-${i}`,
          userId: `user-${i}`,
          startDate: new Date(`2024-02-${(i % 28) + 1}T00:00:00`),
          endDate: new Date(`2024-02-${(i % 28) + 2}T00:00:00`),
          type: 'VACATION',
          status: 'APPROVED'
        } : [{
          id: `concurrent-plan-${i}`,
          userId: `user-${i}`,
          date: new Date(`2024-02-${(i % 28) + 1}T08:00:00`),
          shift: 'DAY' as const,
          specialty: 'CONCURRENT'
        }]
      }));

      // Émettre tous les événements rapidement
      concurrentEvents.forEach(event => {
        eventBus.emit(event);
      });

      const events = integrationService.getEvents();
      expect(events.length).toBeGreaterThan(0);
      expect(events.length).toBeLessThanOrEqual(100); // Maximum 100 événements
    });
  });
});