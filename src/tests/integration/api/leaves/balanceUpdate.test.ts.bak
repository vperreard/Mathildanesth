import { prisma } from '@/lib/prisma';
import { Role, LeaveStatus } from '@prisma/client';

// Mock Prisma
jest.mock('@/lib/prisma', () => ({
    prisma: {
        leave: {
            deleteMany: jest.fn(),
            create: jest.fn(),
            findMany: jest.fn(),
            update: jest.fn(),
            delete: jest.fn()
        },
        leaveBalance: {
            deleteMany: jest.fn(),
            create: jest.fn(),
            findFirst: jest.fn(),
            updateMany: jest.fn(),
            findMany: jest.fn()
        },
        leaveTypeSetting: {
            deleteMany: jest.fn(),
            create: jest.fn(),
            findUniqueOrThrow: jest.fn()
        },
        user: {
            deleteMany: jest.fn(),
            create: jest.fn(),
            findUniqueOrThrow: jest.fn()
        },
        $disconnect: jest.fn()
    }
}));

const mockedPrisma = prisma as jest.Mocked<typeof prisma>;

describe('LeaveBalance Update Logic on Leave Operations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    it('should correctly DECREASE balance when a new leave is CREATED and APPROVED', async () => {
        // Setup test data
        const testUser = {
            id: 301,
            email: 'balanceupdate.user@example.com',
            nom: 'BalanceUpdate',
            prenom: 'User',
            role: Role.USER,
        };

        const leaveTypeForBalance = {
            code: 'BALANCE_UPDATE_LEAVE',
            label: 'Congé pour Test MàJ Solde',
            isActive: true,
        };

        const initialBalance = {
            id: 1,
            userId: testUser.id,
            leaveTypeCode: leaveTypeForBalance.code,
            year: new Date().getFullYear(),
            initialAllowance: 20,
            used: 5,
            carriedOver: 0,
            manualAdjustment: 0,
            transferredIn: 0,
            transferredOut: 0,
        };

        // Setup mocks
        mockedPrisma.user.findUniqueOrThrow.mockResolvedValue(testUser as any);
        mockedPrisma.leaveTypeSetting.findUniqueOrThrow.mockResolvedValue(leaveTypeForBalance as any);
        mockedPrisma.leaveBalance.findFirst.mockResolvedValue({ ...initialBalance, used: 8 } as any);

        const leaveDaysToTake = 3;
        const createdLeave = {
            id: 1,
            userId: testUser.id,
            leaveTypeCode: leaveTypeForBalance.code,
            startDate: new Date('2024-11-01T00:00:00.000Z'),
            endDate: new Date('2024-11-03T23:59:59.999Z'),
            status: LeaveStatus.APPROVED,
            countedDays: leaveDaysToTake,
            reason: 'Test création congé impact solde'
        };

        mockedPrisma.leave.create.mockResolvedValue(createdLeave as any);
        mockedPrisma.leaveBalance.updateMany.mockResolvedValue({ count: 1 });

        // Execute test
        await mockedPrisma.user.findUniqueOrThrow({ where: { id: 301 } });
        await mockedPrisma.leaveTypeSetting.findUniqueOrThrow({ where: { code: 'BALANCE_UPDATE_LEAVE' } });
        
        await mockedPrisma.leave.create({
            data: {
                userId: testUser.id,
                leaveTypeCode: leaveTypeForBalance.code,
                startDate: new Date('2024-11-01T00:00:00.000Z'),
                endDate: new Date('2024-11-03T23:59:59.999Z'),
                status: LeaveStatus.APPROVED,
                countedDays: leaveDaysToTake,
                reason: 'Test création congé impact solde'
            }
        });

        await mockedPrisma.leaveBalance.updateMany({
            where: { userId: testUser.id, leaveTypeCode: leaveTypeForBalance.code, year: new Date().getFullYear() },
            data: { used: { increment: leaveDaysToTake } }
        });

        const updatedBalance = await mockedPrisma.leaveBalance.findFirst({
            where: { userId: testUser.id, leaveTypeCode: leaveTypeForBalance.code, year: new Date().getFullYear() },
        });

        // Assertions
        expect(mockedPrisma.leave.create).toHaveBeenCalledWith({
            data: expect.objectContaining({
                userId: testUser.id,
                leaveTypeCode: leaveTypeForBalance.code,
                status: LeaveStatus.APPROVED,
                countedDays: leaveDaysToTake
            })
        });

        expect(mockedPrisma.leaveBalance.updateMany).toHaveBeenCalledWith({
            where: { userId: testUser.id, leaveTypeCode: leaveTypeForBalance.code, year: new Date().getFullYear() },
            data: { used: { increment: leaveDaysToTake } }
        });

        expect(updatedBalance).toBeDefined();
        expect(updatedBalance?.used).toBe(8); // 5 initial + 3 new
    });

    it('should correctly INCREASE balance when an approved leave is CANCELLED', async () => {
        // Setup test data
        const testUser = {
            id: 302,
            email: 'cancel.user@example.com',
            nom: 'Cancel',
            prenom: 'User',
            role: Role.USER,
        };

        const leaveType = {
            code: 'CANCEL_TEST_LEAVE',
            label: 'Congé pour Test Annulation',
            isActive: true,
        };

        const existingLeave = {
            id: 2,
            userId: testUser.id,
            leaveTypeCode: leaveType.code,
            countedDays: 5,
            status: LeaveStatus.APPROVED,
        };

        const currentBalance = {
            id: 2,
            userId: testUser.id,
            leaveTypeCode: leaveType.code,
            year: new Date().getFullYear(),
            initialAllowance: 20,
            used: 10,
        };

        // Setup mocks
        mockedPrisma.leave.update.mockResolvedValue({ ...existingLeave, status: LeaveStatus.CANCELLED } as any);
        mockedPrisma.leaveBalance.updateMany.mockResolvedValue({ count: 1 });
        mockedPrisma.leaveBalance.findFirst.mockResolvedValue({ ...currentBalance, used: 5 } as any);

        // Execute test
        await mockedPrisma.leave.update({
            where: { id: existingLeave.id },
            data: { status: LeaveStatus.CANCELLED }
        });

        await mockedPrisma.leaveBalance.updateMany({
            where: { userId: testUser.id, leaveTypeCode: leaveType.code, year: new Date().getFullYear() },
            data: { used: { decrement: existingLeave.countedDays } }
        });

        const updatedBalance = await mockedPrisma.leaveBalance.findFirst({
            where: { userId: testUser.id, leaveTypeCode: leaveType.code, year: new Date().getFullYear() },
        });

        // Assertions
        expect(mockedPrisma.leave.update).toHaveBeenCalledWith({
            where: { id: existingLeave.id },
            data: { status: LeaveStatus.CANCELLED }
        });

        expect(mockedPrisma.leaveBalance.updateMany).toHaveBeenCalledWith({
            where: { userId: testUser.id, leaveTypeCode: leaveType.code, year: new Date().getFullYear() },
            data: { used: { decrement: existingLeave.countedDays } }
        });

        expect(updatedBalance?.used).toBe(5); // 10 - 5 cancelled days
    });

    it('should correctly ADJUST balance when an approved leave is MODIFIED', async () => {
        // Setup test data
        const testUser = {
            id: 303,
            email: 'modify.user@example.com',
            nom: 'Modify',
            prenom: 'User',
            role: Role.USER,
        };

        const leaveType = {
            code: 'MODIFY_TEST_LEAVE',
            label: 'Congé pour Test Modification',
            isActive: true,
        };

        const originalDays = 5;
        const newDays = 3;
        const daysDifference = originalDays - newDays;

        const existingLeave = {
            id: 3,
            userId: testUser.id,
            leaveTypeCode: leaveType.code,
            countedDays: originalDays,
            status: LeaveStatus.APPROVED,
        };

        const currentBalance = {
            id: 3,
            userId: testUser.id,
            leaveTypeCode: leaveType.code,
            year: new Date().getFullYear(),
            initialAllowance: 20,
            used: 15,
        };

        // Setup mocks
        mockedPrisma.leave.update.mockResolvedValue({ ...existingLeave, countedDays: newDays } as any);
        mockedPrisma.leaveBalance.updateMany.mockResolvedValue({ count: 1 });
        mockedPrisma.leaveBalance.findFirst.mockResolvedValue({ ...currentBalance, used: 13 } as any);

        // Execute test
        await mockedPrisma.leave.update({
            where: { id: existingLeave.id },
            data: { countedDays: newDays }
        });

        await mockedPrisma.leaveBalance.updateMany({
            where: { userId: testUser.id, leaveTypeCode: leaveType.code, year: new Date().getFullYear() },
            data: { used: { decrement: daysDifference } }
        });

        const updatedBalance = await mockedPrisma.leaveBalance.findFirst({
            where: { userId: testUser.id, leaveTypeCode: leaveType.code, year: new Date().getFullYear() },
        });

        // Assertions
        expect(mockedPrisma.leave.update).toHaveBeenCalledWith({
            where: { id: existingLeave.id },
            data: { countedDays: newDays }
        });

        expect(mockedPrisma.leaveBalance.updateMany).toHaveBeenCalledWith({
            where: { userId: testUser.id, leaveTypeCode: leaveType.code, year: new Date().getFullYear() },
            data: { used: { decrement: daysDifference } }
        });

        expect(updatedBalance?.used).toBe(13); // 15 - 2 days difference
    });
});