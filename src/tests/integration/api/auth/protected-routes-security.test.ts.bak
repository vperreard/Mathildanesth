/**
 * @file Protected Routes Security Integration Tests
 * @description Tests middleware auth protection on various API routes
 * Tests authorization, role-based access, and route protection vulnerabilities
 */

/**
 * @jest-environment node
 */

import { NextRequest } from 'next/server';
import { Role, UserStatus } from '@prisma/client';

// Mock auth dependencies
jest.mock('@/lib/auth', () => ({
    getUserFromCookie: jest.fn()
}));
jest.mock('@/lib/prisma');
jest.mock('@/lib/rateLimit', () => ({
    withAuthRateLimit: (handler: Function) => handler,
    withUserRateLimit: (handler: Function) => handler,
    withPublicRateLimit: (handler: Function) => handler,
    withAdminRateLimit: (handler: Function) => handler,
    withSensitiveRateLimit: (handler: Function) => handler
}));

const mockedGetUserFromCookie = require('@/lib/auth').getUserFromCookie;

// Mock NextResponse
jest.mock('next/server', () => ({
    NextRequest: jest.requireActual('next/server').NextRequest,
    NextResponse: {
        json: (data: any, init?: ResponseInit) => {
            const response = new Response(JSON.stringify(data), {
                ...init,
                headers: {
                    'content-type': 'application/json',
                    ...(init?.headers || {})
                }
            });
            return response;
        },
        redirect: (url: string, init?: ResponseInit) => {
            return new Response(null, {
                status: 302,
                headers: {
                    'Location': url,
                    ...(init?.headers || {})
                }
            });
        }
    }
}));

describe('Protected Routes Security Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    const MEDICAL_ROLES = {
        MAR: 'MAR',
        IADE: 'IADE',
        ADMIN_TOTAL: Role.ADMIN_TOTAL,
        ADMIN_PARTIEL: Role.ADMIN_PARTIEL,
        USER: Role.USER,
        CHIRURGIEN: 'CHIRURGIEN'
    };

    const createMockUser = (role: Role, professionalRole?: string) => ({
        id: 1,
        email: 'test@example.com',
        nom: 'Test',
        prenom: 'User',
        role,
        userStatus: UserStatus.ACTIF,
        professionalRole: professionalRole || 'MAR',
        sites: [{ id: 1, name: 'Site A' }]
    });

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    describe('Authentication Token Validation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should reject requests without authentication tokens', async () => {
            mockedGetUserFromCookie.mockResolvedValue(null);

            const protectedEndpoints = [
                '/api/auth/me',
                '/api/leaves',
                '/api/planning',
                '/api/admin/users'
            ];

            for (const endpoint of protectedEndpoints) {
                const request = new NextRequest(`http://localhost:3000${endpoint}`, {
                    method: 'GET'
                });

                // Since we're testing middleware behavior, we'll test the me endpoint
                // which requires authentication
                if (endpoint === '/api/auth/me') {
                    const route = await import('@/app/api/auth/me/route');
                    const response = await route.GET(request);
                    
                    expect(response.status).toBe(401);
                    const data = await response.json();
                    expect(data.error).toBe('Non autorisé');
                }
            }
        });

        it('should reject requests with malformed auth cookies', async () => {
            const malformedCookies = [
                'auth_token=',
                'auth_token=invalid.jwt.format',
                'auth_token=corrupted_base64_!@#$%',
                'auth_token=null',
                'auth_token=undefined'
            ];

            for (const malformedCookie of malformedCookies) {
                mockedGetUserFromCookie.mockRejectedValue(new Error('Invalid token'));

                const request = new NextRequest('http://localhost:3000/api/auth/me', {
                    method: 'GET',
                    headers: {
                        'cookie': malformedCookie
                    }
                });

                const route = await import('@/app/api/auth/me/route');
                const response = await route.GET(request);
                
                expect(response.status).toBe(401);
            }
        });
    });

    describe('Role-Based Access Control Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should enforce admin-only access to admin endpoints', async () => {
            const userRoles = [
                { role: Role.USER, shouldHaveAccess: false },
                { role: Role.ADMIN_PARTIEL, shouldHaveAccess: true },
                { role: Role.ADMIN_TOTAL, shouldHaveAccess: true }
            ];

            for (const { role, shouldHaveAccess } of userRoles) {
                const mockUser = createMockUser(role);
                mockedGetUserFromCookie.mockResolvedValue(mockUser as any);

                // Test basic authenticated endpoint (should always work for authenticated users)
                const meRequest = new NextRequest('http://localhost:3000/api/auth/me', {
                    method: 'GET',
                    headers: {
                        'cookie': 'auth_token=valid_token'
                    }
                });

                const meRoute = await import('@/app/api/auth/me/route');
                const meResponse = await meRoute.GET(meRequest);
                
                // All authenticated users should be able to access /me
                expect(meResponse.status).toBe(200);
                
                const userData = await meResponse.json();
                expect(userData.role).toBe(role);
                
                // Admin-specific functionality should be controlled in the business logic
                if (shouldHaveAccess) {
                    expect([Role.ADMIN_TOTAL, Role.ADMIN_PARTIEL]).toContain(userData.role);
                } else {
                    expect(userData.role).toBe(Role.USER);
                }
            }
        });

        it('should validate medical professional roles', async () => {
            const medicalRoles = [
                { professionalRole: 'MAR', role: Role.USER },
                { professionalRole: 'IADE', role: Role.USER },
                { professionalRole: 'CHIRURGIEN', role: Role.USER },
                { professionalRole: 'INVALID_ROLE', role: Role.USER }
            ];

            for (const { professionalRole, role } of medicalRoles) {
                const mockUser = createMockUser(role, professionalRole);
                mockedGetUserFromCookie.mockResolvedValue(mockUser as any);

                const request = new NextRequest('http://localhost:3000/api/auth/me', {
                    method: 'GET',
                    headers: {
                        'cookie': 'auth_token=valid_token'
                    }
                });

                const route = await import('@/app/api/auth/me/route');
                const response = await route.GET(request);
                
                expect(response.status).toBe(200);
                
                const userData = await response.json();
                expect(userData.professionalRole).toBe(professionalRole);
                
                // Validate professional role is appropriate for medical context
                if (['MAR', 'IADE', 'CHIRURGIEN'].includes(professionalRole)) {
                    expect(['MAR', 'IADE', 'CHIRURGIEN']).toContain(userData.professionalRole);
                }
            }
        });
    });

    describe('Session Security and Hijacking Prevention', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should validate session integrity', async () => {
            const validUser = createMockUser(Role.USER);
            mockedGetUserFromCookie.mockResolvedValue(validUser as any);

            const request = new NextRequest('http://localhost:3000/api/auth/me', {
                method: 'GET',
                headers: {
                    'cookie': 'auth_token=valid_token',
                    'user-agent': 'TestBrowser/1.0'
                }
            });

            const route = await import('@/app/api/auth/me/route');
            const response = await route.GET(request);
            
            expect(response.status).toBe(200);
            
            // Verify user data consistency
            const userData = await response.json();
            expect(userData.id).toBe(validUser.id);
            expect(userData.email).toBe(validUser.email);
        });

        it('should handle concurrent authentication attempts', async () => {
            const validUser = createMockUser(Role.USER);
            mockedGetUserFromCookie.mockResolvedValue(validUser as any);

            // Simulate multiple concurrent requests from the same user
            const requests = Array.from({ length: 5 }, (_, i) => 
                new NextRequest('http://localhost:3000/api/auth/me', {
                    method: 'GET',
                    headers: {
                        'cookie': 'auth_token=valid_token',
                        'x-request-id': `request-${i}`
                    }
                })
            );

            const route = await import('@/app/api/auth/me/route');
            const responses = await Promise.all(
                requests.map(request => route.GET(request))
            );

            // All requests should succeed for valid concurrent access
            responses.forEach(response => {
                expect(response.status).toBe(200);
            });

            // Verify getUserFromCookie was called for each request
            expect(mockedGetUserFromCookie).toHaveBeenCalledTimes(5);
        });
    });

    describe('Medical Data Access Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should enforce site-based access control', async () => {
            const userWithSites = {
                ...createMockUser(Role.USER),
                sites: [
                    { id: 1, name: 'Site A' },
                    { id: 2, name: 'Site B' }
                ]
            };

            mockedGetUserFromCookie.mockResolvedValue(userWithSites as any);

            const request = new NextRequest('http://localhost:3000/api/auth/me', {
                method: 'GET',
                headers: {
                    'cookie': 'auth_token=valid_token'
                }
            });

            const route = await import('@/app/api/auth/me/route');
            const response = await route.GET(request);
            
            expect(response.status).toBe(200);
            
            const userData = await response.json();
            expect(userData.sites).toHaveLength(2);
            expect(userData.sites[0].name).toBe('Site A');
            expect(userData.sites[1].name).toBe('Site B');
        });

        it('should handle users without site assignments', async () => {
            const userWithoutSites = {
                ...createMockUser(Role.USER),
                sites: []
            };

            mockedGetUserFromCookie.mockResolvedValue(userWithoutSites as any);

            const request = new NextRequest('http://localhost:3000/api/auth/me', {
                method: 'GET',
                headers: {
                    'cookie': 'auth_token=valid_token'
                }
            });

            const route = await import('@/app/api/auth/me/route');
            const response = await route.GET(request);
            
            expect(response.status).toBe(200);
            
            const userData = await response.json();
            expect(userData.sites).toEqual([]);
        });
    });

    describe('Security Headers and CSRF Protection', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should include security headers in authenticated responses', async () => {
            const validUser = createMockUser(Role.USER);
            mockedGetUserFromCookie.mockResolvedValue(validUser as any);

            const request = new NextRequest('http://localhost:3000/api/auth/me', {
                method: 'GET',
                headers: {
                    'cookie': 'auth_token=valid_token'
                }
            });

            const route = await import('@/app/api/auth/me/route');
            const response = await route.GET(request);
            
            expect(response.status).toBe(200);
            expect(response.headers.get('content-type')).toBe('application/json');
        });

        it('should prevent CSRF attacks on state-changing operations', async () => {
            // Test that GET requests work without CSRF tokens (read-only)
            const validUser = createMockUser(Role.USER);
            mockedGetUserFromCookie.mockResolvedValue(validUser as any);

            const getRequest = new NextRequest('http://localhost:3000/api/auth/me', {
                method: 'GET',
                headers: {
                    'cookie': 'auth_token=valid_token'
                }
            });

            const route = await import('@/app/api/auth/me/route');
            const response = await route.GET(getRequest);
            
            expect(response.status).toBe(200);
            
            // POST/PUT/DELETE requests should ideally include CSRF protection
            // This is more of a business logic test than middleware test
        });
    });

    describe('User Status and Account State Validation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should handle different user statuses', async () => {
            const userStatuses = [
                UserStatus.ACTIF,
                UserStatus.INACTIF,
                UserStatus.SUSPENDU
            ];

            for (const status of userStatuses) {
                const userWithStatus = {
                    ...createMockUser(Role.USER),
                    userStatus: status
                };

                mockedGetUserFromCookie.mockResolvedValue(userWithStatus as any);

                const request = new NextRequest('http://localhost:3000/api/auth/me', {
                    method: 'GET',
                    headers: {
                        'cookie': 'auth_token=valid_token'
                    }
                });

                const route = await import('@/app/api/auth/me/route');
                const response = await route.GET(request);
                
                // The auth middleware should handle this at the authentication level
                // Here we're just testing that the data is properly returned
                if (status === UserStatus.ACTIF) {
                    expect(response.status).toBe(200);
                    const userData = await response.json();
                    expect(userData.userStatus).toBe(status);
                } else {
                    // For inactive/suspended users, this should be handled at auth level
                    expect(response.status).toBe(200); // Still 200 if auth passed
                    const userData = await response.json();
                    expect(userData.userStatus).toBe(status);
                }
            }
        });
    });

    describe('Error Handling and Information Disclosure', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should not leak sensitive information in error responses', async () => {
            mockedGetUserFromCookie.mockRejectedValue(new Error('Database connection failed: password=secret123'));

            const request = new NextRequest('http://localhost:3000/api/auth/me', {
                method: 'GET',
                headers: {
                    'cookie': 'auth_token=corrupted_token'
                }
            });

            const route = await import('@/app/api/auth/me/route');
            const response = await route.GET(request);
            
            expect(response.status).toBe(401);
            const data = await response.json();
            
            // Should not leak database connection details
            expect(data.error).toBe('Non autorisé');
            expect(data.error).not.toContain('Database');
            expect(data.error).not.toContain('password');
            expect(data.error).not.toContain('secret123');
        });

        it('should handle authentication timeout gracefully', async () => {
            mockedGetUserFromCookie.mockImplementation(() => 
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), 1)
                )
            );

            const request = new NextRequest('http://localhost:3000/api/auth/me', {
                method: 'GET',
                headers: {
                    'cookie': 'auth_token=slow_token'
                }
            });

            const route = await import('@/app/api/auth/me/route');
            const response = await route.GET(request);
            
            expect(response.status).toBe(401);
            const data = await response.json();
            expect(data.error).toBe('Non autorisé');
        });
    });
});