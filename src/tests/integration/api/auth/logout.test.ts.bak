import { NextRequest } from 'next/server';

// Mock dependencies
jest.mock('@/lib/auth-utils', () => ({
    removeAuthToken: jest.fn()
}));
jest.mock('@/services/OptimizedAuditService', () => ({
    auditService: {
        logLogout: jest.fn()
    }
}));
jest.mock('@/lib/auth-server-utils', () => ({
    verifyAuthToken: jest.fn()
}));
jest.mock('@/lib/rateLimit', () => ({
    withAuthRateLimit: (handler: Function) => handler,
    withUserRateLimit: (handler: Function) => handler,
    withPublicRateLimit: (handler: Function) => handler,
    withAdminRateLimit: (handler: Function) => handler,
    withSensitiveRateLimit: (handler: Function) => handler
}));

// Mock NextResponse
jest.mock('next/server', () => ({
    NextRequest: jest.requireActual('next/server').NextRequest,
    NextResponse: {
        json: (data: any, init?: ResponseInit) => {
            const response = new Response(JSON.stringify(data), {
                ...init,
                headers: {
                    'content-type': 'application/json',
                    ...(init?.headers || {})
                }
            });
            return response;
        }
    }
}));

describe('POST /api/auth/logout', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    let handler: any;

    beforeEach(async () => {
        jest.clearAllMocks();
        const route = await import('@/app/api/auth/logout/route');
        handler = route.POST;
    });

    const createRequest = (authHeader?: string) => {
        return new NextRequest('http://localhost:3000/api/auth/logout', {
            method: 'POST',
            headers: {
                ...(authHeader ? { 'authorization': authHeader } : {}),
            },
        });
    };

    it('should successfully logout and clear authentication', async () => {
        const mockVerifyAuthToken = require('@/lib/auth-server-utils').verifyAuthToken;
        const mockRemoveAuthToken = require('@/lib/auth-utils').removeAuthToken;
        const mockAuditService = require('@/services/OptimizedAuditService').auditService;

        mockVerifyAuthToken.mockResolvedValue({
            authenticated: true,
            userId: 1
        });

        const request = createRequest('Bearer valid_token');
        const response = await handler(request);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.message).toBe('Déconnexion réussie');
        expect(mockRemoveAuthToken).toHaveBeenCalled();
        expect(mockAuditService.logLogout).toHaveBeenCalledWith(1);
    });

    it('should handle logout even without existing auth token', async () => {
        const mockRemoveAuthToken = require('@/lib/auth-utils').removeAuthToken;

        const request = createRequest();
        const response = await handler(request);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.message).toBe('Déconnexion réussie');
        expect(mockRemoveAuthToken).toHaveBeenCalled();
    });

    it('should handle invalid auth tokens gracefully', async () => {
        const mockVerifyAuthToken = require('@/lib/auth-server-utils').verifyAuthToken;
        const mockRemoveAuthToken = require('@/lib/auth-utils').removeAuthToken;

        mockVerifyAuthToken.mockResolvedValue({
            authenticated: false,
            userId: null
        });

        const request = createRequest('Bearer invalid_token');
        const response = await handler(request);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.message).toBe('Déconnexion réussie');
        expect(mockRemoveAuthToken).toHaveBeenCalled();
    });

    it('should handle server errors gracefully', async () => {
        const mockRemoveAuthToken = require('@/lib/auth-utils').removeAuthToken;
        mockRemoveAuthToken.mockRejectedValue(new Error('Server error'));

        const request = createRequest();
        const response = await handler(request);
        const data = await response.json();

        expect(response.status).toBe(500);
        expect(data.message).toBe('Erreur interne du serveur lors de la déconnexion');
    });
});