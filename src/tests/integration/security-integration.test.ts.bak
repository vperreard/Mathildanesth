/**
 * @jest-environment node
 * Comprehensive Security Integration Tests
 * Medical Application - Critical Security Requirements
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authService } from '@/services/authService';
import { prisma } from '@/lib/prisma';

jest.mock('next-auth');
jest.mock('@/services/authService');
jest.mock('@/lib/prisma');

const mockGetServerSession = getServerSession as jest.MockedFunction<typeof getServerSession>;
const mockAuthService = authService as jest.Mocked<typeof authService>;
const mockPrisma = prisma as jest.Mocked<typeof prisma>;

// Medical roles for testing
const MEDICAL_ROLES = {
  MAR: 'MAR', // MÃ©decin AnesthÃ©siste RÃ©animateur
  IADE: 'IADE', // Infirmier AnesthÃ©siste DiplÃ´mÃ© d'Ã‰tat
  ADMIN_TOTAL: 'ADMIN_TOTAL',
  ADMIN_PARTIEL: 'ADMIN_PARTIEL',
  CHIRURGIEN: 'CHIRURGIEN',
  USER: 'USER'
} as const;

// Test users for different scenarios
const TEST_USERS = {
  mar: {
    id: 1,
    email: 'dr.martin@hospital.com',
    role: MEDICAL_ROLES.MAR,
    name: 'Dr. Martin',
    active: true
  },
  iade: {
    id: 2,
    email: 'nurse.jane@hospital.com',
    role: MEDICAL_ROLES.IADE,
    name: 'Nurse Jane',
    active: true
  },
  admin: {
    id: 3,
    email: 'admin@hospital.com',
    role: MEDICAL_ROLES.ADMIN_TOTAL,
    name: 'Administrator',
    active: true
  },
  user: {
    id: 4,
    email: 'user@hospital.com',
    role: MEDICAL_ROLES.USER,
    name: 'Basic User',
    active: true
  },
  inactive: {
    id: 5,
    email: 'inactive@hospital.com',
    role: MEDICAL_ROLES.USER,
    name: 'Inactive User',
    active: false
  }
};

// Mock API route handler
const createMockApiHandler = (
  requiredRoles: string[] = [],
  handler: (req: NextRequest, session: any) => Promise<Response>
) => {
  return async (req: NextRequest): Promise<Response> => {
    try {
      const session = await mockGetServerSession();
      
      if (!session?.user) {
        return new Response(
          JSON.stringify({ error: 'Authentication required' }),
          { status: 401, headers: { 'Content-Type': 'application/json' } }
        );
      }

      if (requiredRoles.length > 0 && !requiredRoles.includes(session.user.role)) {
        return new Response(
          JSON.stringify({ error: 'Insufficient permissions' }),
          { status: 403, headers: { 'Content-Type': 'application/json' } }
        );
      }

      return await handler(req, session);
    } catch (error) {
      return new Response(
        JSON.stringify({ error: 'Internal server error' }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }
  };
};

describe('ðŸ”’ Comprehensive Security Integration Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('ðŸ” End-to-End Authentication Flow', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should complete secure login flow for MAR (medical staff)', async () => {
      const loginCredentials = {
        email: 'dr.martin@hospital.com',
        password: 'SecurePassword123!'
      };

      // Mock successful authentication
      mockAuthService.login.mockResolvedValue({
        user: TEST_USERS.mar,
        token: 'secure-jwt-token'
      });

      // Simulate login API call
      const result = await mockAuthService.login(
        loginCredentials.email,
        loginCredentials.password
      );

      expect(result.user.role).toBe(MEDICAL_ROLES.MAR);
      expect(result.token).toBeDefined();
      expect(mockAuthService.login).toHaveBeenCalledWith(
        loginCredentials.email,
        loginCredentials.password
      );
    });

    it('should handle authentication with session validation', async () => {
      // Mock session validation
      mockGetServerSession.mockResolvedValue({
        user: TEST_USERS.mar
      });

      mockAuthService.validateToken.mockResolvedValue({
        userId: TEST_USERS.mar.id,
        role: TEST_USERS.mar.role,
        exp: Math.floor(Date.now() / 1000) + 3600
      });

      // Simulate protected route access
      const handler = createMockApiHandler(
        [MEDICAL_ROLES.MAR, MEDICAL_ROLES.ADMIN_TOTAL],
        async (req, session) => {
          return new Response(
            JSON.stringify({ success: true, user: session.user }),
            { status: 200, headers: { 'Content-Type': 'application/json' } }
          );
        }
      );

      const mockRequest = new NextRequest('http://localhost/api/protected');
      const response = await handler(mockRequest);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.user.role).toBe(MEDICAL_ROLES.MAR);
    });

    it('should enforce logout and token invalidation', async () => {
      const token = 'valid-jwt-token';

      mockAuthService.logout.mockResolvedValue(undefined);

      await mockAuthService.logout(token);

      expect(mockAuthService.logout).toHaveBeenCalledWith(token);
    });
  });

  describe('ðŸ›¡ï¸ Role-Based Access Control (RBAC) Integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    describe('MAR (MÃ©decin AnesthÃ©siste) Access Control', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

      it('should allow MAR to access planning management', async () => {
        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.mar
        });

        const handler = createMockApiHandler(
          [MEDICAL_ROLES.MAR, MEDICAL_ROLES.ADMIN_TOTAL],
          async (req, session) => {
            return new Response(
              JSON.stringify({ 
                success: true, 
                planning: 'planning-data',
                userRole: session.user.role 
              }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const mockRequest = new NextRequest('http://localhost/api/planning');
        const response = await handler(mockRequest);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.userRole).toBe(MEDICAL_ROLES.MAR);
      });

      it('should allow MAR to approve leave requests', async () => {
        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.mar
        });

        mockPrisma.leave.update.mockResolvedValue({
          id: 1,
          status: 'APPROVED',
          approvedBy: TEST_USERS.mar.id
        } as any);

        const handler = createMockApiHandler(
          [MEDICAL_ROLES.MAR, MEDICAL_ROLES.ADMIN_TOTAL],
          async (req, session) => {
            // Simulate leave approval
            await mockPrisma.leave.update({
              where: { id: 1 },
              data: { 
                status: 'APPROVED',
                approvedBy: session.user.id 
              }
            });

            return new Response(
              JSON.stringify({ success: true, approved: true }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const mockRequest = new NextRequest('http://localhost/api/leaves/1/approve');
        const response = await handler(mockRequest);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(mockPrisma.leave.update).toHaveBeenCalled();
      });
    });

    describe('IADE (Infirmier AnesthÃ©siste) Access Control', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

      it('should allow IADE to view planning but not modify', async () => {
        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.iade
        });

        // IADE should be able to view planning
        const viewHandler = createMockApiHandler(
          [MEDICAL_ROLES.MAR, MEDICAL_ROLES.IADE, MEDICAL_ROLES.ADMIN_TOTAL],
          async (req, session) => {
            return new Response(
              JSON.stringify({ 
                success: true, 
                planning: 'readonly-planning-data',
                permissions: ['view']
              }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const viewRequest = new NextRequest('http://localhost/api/planning/view');
        const viewResponse = await viewHandler(viewRequest);
        const viewData = await viewResponse.json();

        expect(viewResponse.status).toBe(200);
        expect(viewData.success).toBe(true);
        expect(viewData.permissions).toContain('view');

        // IADE should NOT be able to modify planning
        const modifyHandler = createMockApiHandler(
          [MEDICAL_ROLES.MAR, MEDICAL_ROLES.ADMIN_TOTAL], // IADE not included
          async (req, session) => {
            return new Response(
              JSON.stringify({ success: true, modified: true }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const modifyRequest = new NextRequest('http://localhost/api/planning/modify');
        const modifyResponse = await modifyHandler(modifyRequest);

        expect(modifyResponse.status).toBe(403); // Forbidden
      });

      it('should deny IADE access to user management', async () => {
        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.iade
        });

        const handler = createMockApiHandler(
          [MEDICAL_ROLES.ADMIN_TOTAL], // Only total admin
          async (req, session) => {
            return new Response(
              JSON.stringify({ success: true, users: [] }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const mockRequest = new NextRequest('http://localhost/api/admin/users');
        const response = await handler(mockRequest);

        expect(response.status).toBe(403); // Forbidden
      });
    });

    describe('Admin Access Control', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

      it('should allow ADMIN_TOTAL full system access', async () => {
        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.admin
        });

        const restrictedEndpoints = [
          '/api/admin/users',
          '/api/admin/system-config',
          '/api/admin/audit-logs',
          '/api/admin/security-settings'
        ];

        for (const endpoint of restrictedEndpoints) {
          const handler = createMockApiHandler(
            [MEDICAL_ROLES.ADMIN_TOTAL],
            async (req, session) => {
              return new Response(
                JSON.stringify({ 
                  success: true, 
                  endpoint,
                  adminLevel: 'total' 
                }),
                { status: 200, headers: { 'Content-Type': 'application/json' } }
              );
            }
          );

          const mockRequest = new NextRequest(`http://localhost${endpoint}`);
          const response = await handler(mockRequest);
          const data = await response.json();

          expect(response.status).toBe(200);
          expect(data.success).toBe(true);
          expect(data.adminLevel).toBe('total');
        }
      });

      it('should enforce ADMIN_PARTIEL limitations', async () => {
        const partialAdminUser = {
          ...TEST_USERS.admin,
          role: MEDICAL_ROLES.ADMIN_PARTIEL
        };

        mockGetServerSession.mockResolvedValue({
          user: partialAdminUser
        });

        // Should allow some admin functions
        const allowedHandler = createMockApiHandler(
          [MEDICAL_ROLES.ADMIN_TOTAL, MEDICAL_ROLES.ADMIN_PARTIEL],
          async (req, session) => {
            return new Response(
              JSON.stringify({ success: true, accessible: true }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const allowedRequest = new NextRequest('http://localhost/api/admin/reports');
        const allowedResponse = await allowedHandler(allowedRequest);

        expect(allowedResponse.status).toBe(200);

        // Should deny critical admin functions
        const restrictedHandler = createMockApiHandler(
          [MEDICAL_ROLES.ADMIN_TOTAL], // Only total admin
          async (req, session) => {
            return new Response(
              JSON.stringify({ success: true, systemConfig: {} }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const restrictedRequest = new NextRequest('http://localhost/api/admin/system-config');
        const restrictedResponse = await restrictedHandler(restrictedRequest);

        expect(restrictedResponse.status).toBe(403); // Forbidden
      });
    });
  });

  describe('ðŸš« Security Attack Scenario Testing', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    describe('Session Hijacking Prevention', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

      it('should reject tampered session tokens', async () => {
        const tamperedSession = {
          user: {
            ...TEST_USERS.user,
            role: MEDICAL_ROLES.ADMIN_TOTAL // Elevated privilege
          }
        };

        mockGetServerSession.mockResolvedValue(tamperedSession);
        mockAuthService.validateToken.mockRejectedValue(new Error('Invalid token'));

        const handler = createMockApiHandler(
          [MEDICAL_ROLES.ADMIN_TOTAL],
          async (req, session) => {
            // Validate token before processing
            await mockAuthService.validateToken('tampered-token');
            
            return new Response(
              JSON.stringify({ success: true }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const mockRequest = new NextRequest('http://localhost/api/admin/sensitive');
        
        try {
          await handler(mockRequest);
        } catch (error) {
          expect(error).toBeDefined();
        }

        expect(mockAuthService.validateToken).toHaveBeenCalledWith('tampered-token');
      });

      it('should detect concurrent session anomalies', async () => {
        const suspiciousRequests = [
          { ip: '192.168.1.1', userAgent: 'Browser A' },
          { ip: '10.0.0.1', userAgent: 'Browser B' },
          { ip: '172.16.0.1', userAgent: 'Browser C' }
        ];

        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.mar
        });

        for (const requestInfo of suspiciousRequests) {
          const handler = createMockApiHandler(
            [MEDICAL_ROLES.MAR],
            async (req, session) => {
              // Simulate session validation that would detect anomalies
              const clientIp = req.headers.get('x-forwarded-for') || '127.0.0.1';
              const userAgent = req.headers.get('user-agent') || '';

              // In real implementation, this would check against stored session info
              return new Response(
                JSON.stringify({ 
                  success: true, 
                  sessionInfo: { ip: clientIp, userAgent } 
                }),
                { status: 200, headers: { 'Content-Type': 'application/json' } }
              );
            }
          );

          const mockRequest = new NextRequest('http://localhost/api/protected', {
            headers: {
              'x-forwarded-for': requestInfo.ip,
              'user-agent': requestInfo.userAgent
            }
          });

          const response = await handler(mockRequest);
          expect(response.status).toBe(200);
        }
      });
    });

    describe('Privilege Escalation Prevention', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

      it('should prevent horizontal privilege escalation', async () => {
        // User trying to access another user's data
        const attackerUser = TEST_USERS.user;
        const targetUserId = TEST_USERS.mar.id;

        mockGetServerSession.mockResolvedValue({
          user: attackerUser
        });

        const handler = createMockApiHandler(
          [], // No specific role requirement
          async (req, session) => {
            const url = new URL(req.url);
            const requestedUserId = parseInt(url.pathname.split('/')[3]);

            // Check if user can access this data
            if (session.user.id !== requestedUserId && 
                ![MEDICAL_ROLES.ADMIN_TOTAL, MEDICAL_ROLES.ADMIN_PARTIEL].includes(session.user.role)) {
              return new Response(
                JSON.stringify({ error: 'Access denied to user data' }),
                { status: 403, headers: { 'Content-Type': 'application/json' } }
              );
            }

            return new Response(
              JSON.stringify({ success: true, userData: {} }),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
        );

        const mockRequest = new NextRequest(`http://localhost/api/users/${targetUserId}/profile`);
        const response = await handler(mockRequest);

        expect(response.status).toBe(403);
      });

      it('should prevent vertical privilege escalation', async () => {
        // Regular user trying to perform admin actions
        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.user
        });

        const adminActions = [
          '/api/admin/users/create',
          '/api/admin/system/config',
          '/api/admin/users/delete',
          '/api/admin/audit/logs'
        ];

        for (const action of adminActions) {
          const handler = createMockApiHandler(
            [MEDICAL_ROLES.ADMIN_TOTAL, MEDICAL_ROLES.ADMIN_PARTIEL],
            async (req, session) => {
              return new Response(
                JSON.stringify({ success: true, action: 'completed' }),
                { status: 200, headers: { 'Content-Type': 'application/json' } }
              );
            }
          );

          const mockRequest = new NextRequest(`http://localhost${action}`);
          const response = await handler(mockRequest);

          expect(response.status).toBe(403);
        }
      });
    });

    describe('Data Injection Attack Prevention', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

      it('should safely handle malicious input in API requests', async () => {
        mockGetServerSession.mockResolvedValue({
          user: TEST_USERS.admin
        });

        const maliciousPayloads = [
          {
            name: "'; DROP TABLE users; --",
            email: "test@test.com<script>alert(1)</script>",
            role: "ADMIN'; INSERT INTO audit_logs VALUES ('hacked'); --"
          },
          {
            searchQuery: "'; DELETE FROM patients; --",
            filterBy: "<script>steal_data()</script>",
            sortOrder: "name'; UPDATE users SET role='ADMIN'; --"
          }
        ];

        for (const payload of maliciousPayloads) {
          const handler = createMockApiHandler(
            [MEDICAL_ROLES.ADMIN_TOTAL],
            async (req, session) => {
              const body = await req.json();
              
              // Simulate input validation/sanitization
              for (const [key, value] of Object.entries(body)) {
                if (typeof value === 'string') {
                  if (value.includes('DROP TABLE') || 
                      value.includes('<script>') || 
                      value.includes('DELETE FROM') ||
                      value.includes('INSERT INTO')) {
                    return new Response(
                      JSON.stringify({ error: 'Invalid input detected' }),
                      { status: 400, headers: { 'Content-Type': 'application/json' } }
                    );
                  }
                }
              }

              return new Response(
                JSON.stringify({ success: true, processed: true }),
                { status: 200, headers: { 'Content-Type': 'application/json' } }
              );
            }
          );

          const mockRequest = new NextRequest('http://localhost/api/admin/process', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          const response = await handler(mockRequest);
          expect(response.status).toBe(400); // Bad request due to malicious input
        }
      });
    });
  });

  describe('ðŸ” Security Audit and Monitoring', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should log security events for audit trail', async () => {
      const securityEvents = [];

      const logSecurityEvent = (event: any) => {
        securityEvents.push({
          ...event,
          timestamp: new Date().toISOString()
        });
      };

      // Test various security events
      const events = [
        {
          type: 'AUTHENTICATION_SUCCESS',
          userId: TEST_USERS.mar.id,
          ip: '192.168.1.100',
          userAgent: 'Medical-App/1.0'
        },
        {
          type: 'AUTHENTICATION_FAILURE',
          email: 'attacker@evil.com',
          ip: '10.0.0.1',
          reason: 'Invalid credentials'
        },
        {
          type: 'AUTHORIZATION_DENIED',
          userId: TEST_USERS.user.id,
          resource: '/api/admin/users',
          reason: 'Insufficient privileges'
        },
        {
          type: 'SUSPICIOUS_ACTIVITY',
          userId: TEST_USERS.iade.id,
          activity: 'Multiple failed login attempts',
          ip: '172.16.0.1'
        }
      ];

      for (const event of events) {
        logSecurityEvent(event);
      }

      expect(securityEvents).toHaveLength(4);
      expect(securityEvents[0].type).toBe('AUTHENTICATION_SUCCESS');
      expect(securityEvents[1].type).toBe('AUTHENTICATION_FAILURE');
      expect(securityEvents[2].type).toBe('AUTHORIZATION_DENIED');
      expect(securityEvents[3].type).toBe('SUSPICIOUS_ACTIVITY');

      // All events should have timestamps
      securityEvents.forEach(event => {
        expect(event.timestamp).toBeDefined();
        expect(new Date(event.timestamp)).toBeInstanceOf(Date);
      });
    });

    it('should detect and respond to brute force attacks', async () => {
      const failedAttempts = new Map<string, number>();
      const lockoutTime = new Map<string, Date>();

      const checkBruteForce = (email: string): boolean => {
        const attempts = failedAttempts.get(email) || 0;
        const locked = lockoutTime.get(email);

        if (locked && locked > new Date()) {
          return false; // Still locked
        }

        if (attempts >= 5) {
          lockoutTime.set(email, new Date(Date.now() + 30 * 60 * 1000)); // 30 min lockout
          return false;
        }

        return true;
      };

      const recordFailedAttempt = (email: string) => {
        const attempts = (failedAttempts.get(email) || 0) + 1;
        failedAttempts.set(email, attempts);
      };

      // Simulate brute force attack
      const attackEmail = 'victim@hospital.com';
      
      for (let i = 0; i < 10; i++) {
        if (!checkBruteForce(attackEmail)) {
          break; // Account locked
        }
        recordFailedAttempt(attackEmail);
      }

      expect(failedAttempts.get(attackEmail)).toBe(5);
      expect(lockoutTime.has(attackEmail)).toBe(true);
      expect(checkBruteForce(attackEmail)).toBe(false); // Account should be locked
    });
  });

  describe('ðŸŒ Cross-Origin and CORS Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should enforce proper CORS policies', async () => {
      const allowedOrigins = [
        'https://hospital.com',
        'https://medical.app.com',
        'https://localhost:3000'
      ];

      const maliciousOrigins = [
        'https://evil.com',
        'http://attacker.org',
        'https://phishing-hospital.com',
        'null'
      ];

      const checkCorsPolicy = (origin: string): boolean => {
        return allowedOrigins.includes(origin);
      };

      // Test allowed origins
      for (const origin of allowedOrigins) {
        expect(checkCorsPolicy(origin)).toBe(true);
      }

      // Test malicious origins
      for (const origin of maliciousOrigins) {
        expect(checkCorsPolicy(origin)).toBe(false);
      }
    });

    it('should validate content-type headers', async () => {
      mockGetServerSession.mockResolvedValue({
        user: TEST_USERS.admin
      });

      const handler = createMockApiHandler(
        [MEDICAL_ROLES.ADMIN_TOTAL],
        async (req, session) => {
          const contentType = req.headers.get('content-type');
          
          if (!contentType || !contentType.includes('application/json')) {
            return new Response(
              JSON.stringify({ error: 'Invalid content type' }),
              { status: 400, headers: { 'Content-Type': 'application/json' } }
            );
          }

          return new Response(
            JSON.stringify({ success: true }),
            { status: 200, headers: { 'Content-Type': 'application/json' } }
          );
        }
      );

      // Test with valid content type
      const validRequest = new NextRequest('http://localhost/api/admin/data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data: 'test' })
      });

      const validResponse = await handler(validRequest);
      expect(validResponse.status).toBe(200);

      // Test with invalid content type
      const invalidRequest = new NextRequest('http://localhost/api/admin/data', {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: 'malicious data'
      });

      const invalidResponse = await handler(invalidRequest);
      expect(invalidResponse.status).toBe(400);
    });
  });

  describe('ðŸ” Data Protection and Privacy', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should protect sensitive medical data', async () => {
      mockGetServerSession.mockResolvedValue({
        user: TEST_USERS.mar
      });

      const sensitiveData = {
        patientName: 'John Doe',
        medicalRecord: 'Confidential medical information',
        socialSecurityNumber: '123-45-6789',
        diagnosis: 'Private diagnosis'
      };

      const handler = createMockApiHandler(
        [MEDICAL_ROLES.MAR, MEDICAL_ROLES.ADMIN_TOTAL],
        async (req, session) => {
          // Simulate data access logging
          const accessLog = {
            userId: session.user.id,
            resource: 'patient_data',
            action: 'read',
            timestamp: new Date().toISOString()
          };

          // Redact sensitive information for non-medical staff
          let responseData = { ...sensitiveData };
          if (![MEDICAL_ROLES.MAR, MEDICAL_ROLES.CHIRURGIEN].includes(session.user.role)) {
            responseData = {
              ...responseData,
              socialSecurityNumber: '***-**-****',
              diagnosis: '[REDACTED]'
            };
          }

          return new Response(
            JSON.stringify({ 
              success: true, 
              data: responseData,
              accessLogged: true 
            }),
            { status: 200, headers: { 'Content-Type': 'application/json' } }
          );
        }
      );

      const mockRequest = new NextRequest('http://localhost/api/patients/123');
      const response = await handler(mockRequest);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.accessLogged).toBe(true);
      expect(data.data.patientName).toBe('John Doe'); // Should be visible to MAR
    });
  });
});