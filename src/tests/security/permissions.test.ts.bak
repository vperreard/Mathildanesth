import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { NextRequest } from 'next/server';

// Mock des dépendances d'abord
const mockVerifyAuthToken = jest.fn();
const mockPrismaUserFindUnique = jest.fn();

jest.mock('@/lib/auth-server-utils', () => ({
    verifyAuthToken: mockVerifyAuthToken
}));

jest.mock('@/lib/prisma', () => ({
    prisma: {
        user: {
            findUnique: mockPrismaUserFindUnique
        },
        auditSecurityLog: {
            create: jest.fn()
        }
    }
}));

// Mock le middleware d'autorisation
const mockWithAuth = jest.fn((config: any = {}) => {
    return (handler: any) => {
        return async (req: NextRequest) => {
            const { requireAuth = true, allowedRoles = [], customCheck } = config;
            
            // Si l'authentification n'est pas requise, continuer
            if (!requireAuth) {
                return handler(req);
            }

            // Vérifier le token JWT
            const authHeader = req.headers.get('authorization');
            const token = authHeader?.startsWith('Bearer ') 
                ? authHeader.substring(7) 
                : null;

            if (!token) {
                return new Response(JSON.stringify({ error: 'Authentication required' }), { 
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }

            // Mock de verifyAuthToken
            const authResult = await mockVerifyAuthToken(token);
            
            if (!authResult || !authResult.authenticated) {
                return new Response(JSON.stringify({ error: authResult?.error || 'Invalid token' }), { 
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }

            // Mock de prisma user lookup
            const user = await mockPrismaUserFindUnique({ where: { id: authResult.userId } });

            if (!user || !user.actif) {
                return new Response(JSON.stringify({ error: 'User not found or inactive' }), { 
                    status: 403,
                    headers: { 'Content-Type': 'application/json' }
                });
            }

            // Vérifier les rôles autorisés
            if (allowedRoles.length > 0 && !allowedRoles.includes(user.role)) {
                return new Response(JSON.stringify({ error: 'Insufficient permissions' }), { 
                    status: 403,
                    headers: { 'Content-Type': 'application/json' }
                });
            }

            // Vérification personnalisée
            if (customCheck) {
                const authContext = { userId: user.id, role: user.role, user };
                const allowed = await customCheck(authContext, req);
                if (!allowed) {
                    return new Response(JSON.stringify({ error: 'Access denied' }), { 
                        status: 403,
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            }

            return handler(req);
        };
    };
});

const mockSecurityChecks = {
    isAdmin: jest.fn((context: any) => {
        return context.role === 'ADMIN_TOTAL' || context.role === 'ADMIN_PARTIEL';
    }),
    isOwner: jest.fn((context: any, resourceUserId: string) => {
        return context.userId === parseInt(resourceUserId);
    }),
    hasAccessToSite: jest.fn((context: any, siteId: string) => {
        if (context.role === 'ADMIN_TOTAL') return true;
        return context.user?.siteIds?.includes(siteId) || false;
    }),
    hasPermission: jest.fn((context: any, permission: string) => {
        if (context.role === 'ADMIN_TOTAL') return true;
        return context.user?.permissions?.includes(permission) || false;
    })
};

jest.mock('@/middleware/authorization', () => ({
    withAuth: mockWithAuth,
    SecurityChecks: mockSecurityChecks
}));

// Import après les mocks
const { verifyAuthToken } = require('@/lib/auth-server-utils');
const { withAuth, SecurityChecks } = require('@/middleware/authorization');

describe('Permission System Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    const createMockRequest = (token: string = 'valid-token') => {
        return new NextRequest('http://localhost/api/test', {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
    };

    beforeEach(() => {
    jest.clearAllMocks();
        jest.resetAllMocks();
        // Setup default mocks for successful authentication
        mockVerifyAuthToken.mockResolvedValue({
            authenticated: true,
            userId: 1
        });
        mockPrismaUserFindUnique.mockResolvedValue({
            id: 1,
            role: 'USER',
            actif: true
        });
    });

    describe('Authentication Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should reject requests without token', async () => {
            const handler = withAuth({ requireAuth: true })(async () => {
                return new Response('Success');
            });

            const req = new NextRequest('http://localhost/api/test');
            const response = await handler(req);

            expect(response.status).toBe(401);
            const data = await response.json();
            expect(data.error).toBe('Authentication required');
        });

        it('should reject requests with invalid token', async () => {
            mockVerifyAuthToken.mockResolvedValue({
                authenticated: false,
                error: 'Invalid token'
            });

            const handler = withAuth({ requireAuth: true })(async () => {
                return new Response('Success');
            });

            const req = new NextRequest('http://localhost/api/test', {
                headers: {
                    'Authorization': 'Bearer invalid-token'
                }
            });
            
            const response = await handler(req);
            expect(response.status).toBe(401);
        });
    });

    describe('Role-Based Access Control', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });


        it('should allow admin access to admin-only routes', async () => {
            mockVerifyAuthToken.mockResolvedValue({
                authenticated: true,
                userId: 1,
                role: 'ADMIN_TOTAL'
            });

            mockPrismaUserFindUnique.mockResolvedValue({
                id: 1,
                role: 'ADMIN_TOTAL',
                actif: true
            });

            const handler = withAuth({
                requireAuth: true,
                allowedRoles: ['ADMIN_TOTAL']
            })(async () => {
                return new Response('Admin content');
            });

            const req = createMockRequest();
            const response = await handler(req);

            expect(response.status).toBe(200);
        });

        it('should deny regular user access to admin routes', async () => {
            mockVerifyAuthToken.mockResolvedValue({
                authenticated: true,
                userId: 2,
                role: 'USER'
            });

            mockPrismaUserFindUnique.mockResolvedValue({
                id: 2,
                role: 'USER',
                actif: true
            });

            const handler = withAuth({
                requireAuth: true,
                allowedRoles: ['ADMIN_TOTAL', 'ADMIN_PARTIEL']
            })(async () => {
                return new Response('Admin content');
            });

            const req = createMockRequest();
            const response = await handler(req);

            expect(response.status).toBe(403);
            const data = await response.json();
            expect(data.error).toBe('Insufficient permissions');
        });

        it('should allow partial admin access when appropriate', async () => {
            mockVerifyAuthToken.mockResolvedValue({
                authenticated: true,
                userId: 3,
                role: 'ADMIN_PARTIEL'
            });

            mockPrismaUserFindUnique.mockResolvedValue({
                id: 3,
                role: 'ADMIN_PARTIEL',
                actif: true
            });

            const handler = withAuth({
                requireAuth: true,
                allowedRoles: ['ADMIN_TOTAL', 'ADMIN_PARTIEL']
            })(async () => {
                return new Response('Admin content');
            });

            const req = createMockRequest();
            const response = await handler(req);

            expect(response.status).toBe(200);
        });
    });

    describe('Custom Permission Checks', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should run custom permission checks', async () => {
            mockVerifyAuthToken.mockResolvedValue({
                authenticated: true,
                userId: 1,
                role: 'USER'
            });

            mockPrismaUserFindUnique.mockResolvedValue({
                id: 1,
                role: 'USER',
                actif: true,
                siteIds: ['site-1', 'site-2']
            });

            const customCheck = jest.fn().mockResolvedValue(true);

            const handler = withAuth({
                requireAuth: true,
                customCheck
            })(async () => {
                return new Response('Success');
            });

            const req = createMockRequest();
            const response = await handler(req);

            expect(customCheck).toHaveBeenCalled();
            expect(response.status).toBe(200);
        });

        it('should deny access when custom check fails', async () => {
            mockVerifyAuthToken.mockResolvedValue({
                authenticated: true,
                userId: 1,
                role: 'USER'
            });

            mockPrismaUserFindUnique.mockResolvedValue({
                id: 1,
                role: 'USER',
                actif: true
            });

            const customCheck = jest.fn().mockResolvedValue(false);

            const handler = withAuth({
                requireAuth: true,
                customCheck
            })(async () => {
                return new Response('Success');
            });

            const req = createMockRequest();
            const response = await handler(req);

            expect(response.status).toBe(403);
        });
    });

    describe('Security Helpers', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should correctly identify admin users', () => {
            expect(SecurityChecks.isAdmin({ 
                userId: 1, 
                role: 'ADMIN_TOTAL' as any,
                user: {} 
            })).toBe(true);

            expect(SecurityChecks.isAdmin({ 
                userId: 1, 
                role: 'ADMIN_PARTIEL' as any,
                user: {} 
            })).toBe(true);

            expect(SecurityChecks.isAdmin({ 
                userId: 1, 
                role: 'USER' as any,
                user: {} 
            })).toBe(false);
        });

        it('should check site access correctly', async () => {
            const adminContext = {
                userId: 1,
                role: 'ADMIN_TOTAL' as any,
                user: { siteIds: [] }
            };

            // Les admins ont accès à tous les sites
            expect(await SecurityChecks.hasAccessToSite(adminContext, 'any-site')).toBe(true);

            const userContext = {
                userId: 2,
                role: 'USER' as any,
                user: { siteIds: ['site-1', 'site-2'] }
            };

            // Les utilisateurs n'ont accès qu'à leurs sites
            expect(await SecurityChecks.hasAccessToSite(userContext, 'site-1')).toBe(true);
            expect(await SecurityChecks.hasAccessToSite(userContext, 'site-3')).toBe(false);
        });

        it('should check specific permissions', () => {
            const context = {
                userId: 1,
                role: 'USER' as any,
                user: { permissions: ['manage_leaves', 'view_reports'] }
            };

            expect(SecurityChecks.hasPermission(context, 'manage_leaves')).toBe(true);
            expect(SecurityChecks.hasPermission(context, 'delete_users')).toBe(false);

            // Admin total a toutes les permissions
            const adminContext = {
                userId: 2,
                role: 'ADMIN_TOTAL' as any,
                user: { permissions: [] }
            };

            expect(SecurityChecks.hasPermission(adminContext, 'any_permission')).toBe(true);
        });
    });
});