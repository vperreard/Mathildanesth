/**
 * Tests de Performance - Modules Critiques
 * 
 * Valide que les fonctions critiques respectent les seuils de performance
 */

import { performanceMonitor } from '../../lib/monitoring';

describe('Performance Tests - Modules Critiques', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
        performanceMonitor.reset();
    });

    describe('Performance Baseline', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should record metrics correctly', () => {
            const metric = performanceMonitor.recordMetric('test_metric', 100, 'ms', { test: true });

            expect(metric.name).toBe('test_metric');
            expect(metric.value).toBe(100);
            expect(metric.unit).toBe('ms');
            expect(metric.context?.test).toBe(true);
        });

        it('should calculate stats correctly', () => {
            // Enregistrer quelques métriques de test
            performanceMonitor.recordMetric('api_response_time', 150, 'ms');
            performanceMonitor.recordMetric('api_response_time', 200, 'ms');
            performanceMonitor.recordMetric('api_response_time', 100, 'ms');

            const stats = performanceMonitor.getMetricStats('api_response_time');

            expect(stats.count).toBe(3);
            expect(stats.average).toBe(150);
            expect(stats.min).toBe(100);
            expect(stats.max).toBe(200);
        });

        it('should export data correctly', () => {
            performanceMonitor.recordMetric('test_metric', 100, 'ms');

            const exportData = performanceMonitor.exportData();

            expect(exportData.metrics).toHaveLength(1);
            expect(exportData.alerts).toBeDefined();
            expect(exportData.summary).toBeDefined();
        });
    });

    describe('Performance Thresholds', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should meet API response time requirements (< 200ms)', async () => {
            const startTime = performance.now();

            // Simulation d'un calcul rapide
            await new Promise(resolve => setTimeout(resolve, 50));

            const duration = performance.now() - startTime;

            expect(duration).toBeLessThan(200);
        });

        it('should handle concurrent operations efficiently', async () => {
            const startTime = performance.now();

            // Simulation de 10 opérations concurrentes
            const operations = Array.from({ length: 10 }, () =>
                new Promise(resolve => setTimeout(resolve, 10))
            );

            await Promise.all(operations);

            const duration = performance.now() - startTime;

            // Toutes les opérations en moins de 100ms
            expect(duration).toBeLessThan(100);
        });

        it('should process large datasets efficiently', () => {
            const startTime = performance.now();

            // Simulation de traitement d'un grand dataset
            const largeArray = Array.from({ length: 10000 }, (_, i) => i);
            const processed = largeArray
                .filter(n => n % 2 === 0)
                .map(n => n * 2)
                .reduce((sum, n) => sum + n, 0);

            const duration = performance.now() - startTime;

            expect(processed).toBeGreaterThan(0);
            expect(duration).toBeLessThan(50); // Moins de 50ms pour 10k éléments
        });
    });

    describe('Memory Performance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should not create memory leaks in repeated operations', () => {
            const initialMemory = process.memoryUsage().heapUsed;

            // Simulation de 1000 opérations répétées
            for (let i = 0; i < 1000; i++) {
                const data = { id: i, value: Math.random() };
                // Simulation de traitement et nettoyage
                JSON.stringify(data);
            }

            // Force garbage collection si disponible
            if (global.gc) {
                global.gc();
            }

            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;

            // L'augmentation de mémoire ne devrait pas être excessive
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // Moins de 10MB
        });
    });

    describe('Monitoring Integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should track page load times', () => {
            const stopMeasuring = performanceMonitor.measurePageLoad('test-page');

            // Simulation d'un délai de chargement
            setTimeout(() => {
                stopMeasuring();

                const metrics = performanceMonitor.getRecentMetrics('page_load_time');
                expect(metrics).toHaveLength(1);
                expect(metrics[0].context?.page).toBe('test-page');
            }, 10);
        });

        it('should track API call times', () => {
            const stopMeasuring = performanceMonitor.measureApiCall('/api/test', 'GET');

            // Simulation d'un appel API
            setTimeout(() => {
                stopMeasuring();

                const metrics = performanceMonitor.getRecentMetrics('api_response_time');
                expect(metrics).toHaveLength(1);
                expect(metrics[0].context?.endpoint).toBe('/api/test');
            }, 10);
        });
    });
}); 