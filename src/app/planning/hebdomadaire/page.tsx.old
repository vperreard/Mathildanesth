"use client";

/**
 * Composant de Planning Hebdomadaire du Bloc Opératoire
 * 
 * Architecture de l'application:
 * - Ce module permet la visualisation et la gestion du planning hebdomadaire des salles d'opération
 * - Les salles sont organisées par secteurs (Hyperaseptique, Secteur 5-8, etc.)
 * - Chaque salle a un code couleur associé à son secteur
 * - Le planning affiche les assignations pour chaque jour (Lun-Ven) et chaque créneau (matin/après-midi)
 * 
 * Fonctionnalités principales:
 * - Deux modes d'affichage: par salle ou par chirurgien
 * - Mode édition pour modifier les assignations
 * - Détection automatique des conflits (même personnel assigné à plusieurs salles au même moment)
 * - Import/export du planning (CSV, Excel, PDF)
 * - Mode sombre
 * - Navigation entre les semaines
 * 
 * Structure des données:
 * - Salles: id, nom, numéro, secteur, code couleur
 * - Personnel: MAR (Médecin Anesthésiste Réanimateur) et IADE (Infirmier Anesthésiste)
 * - Chirurgiens: id, nom, prénom, spécialité
 * - Assignations: associent une salle, du personnel et un chirurgien pour un créneau horaire
 * 
 * La configuration des salles se fait dans le panneau d'administration (OperatingRoomsConfigPanel)
 * accessible depuis le menu Paramètres > Configuration
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { ChevronLeftIcon, ChevronRightIcon, PencilIcon, CheckIcon, XMarkIcon, MagnifyingGlassIcon, FunnelIcon, ArrowDownOnSquareIcon, ArrowsUpDownIcon, MoonIcon, SunIcon, ExclamationTriangleIcon, ShieldCheckIcon, Cog6ToothIcon } from '@heroicons/react/24/outline';
import { format as formatDate, startOfWeek, addDays, addWeeks, subWeeks, startOfDay, isToday, isSameDay } from 'date-fns';
import { fr } from 'date-fns/locale';

// Importer les types depuis le fichier partagé
import {
    UserRole,
    DisplayMode,
    PersonnelDisplayConfig,
    VacationColorConfig,
    DisplayConfig,
    User,
    Surgeon,
    Room,
    Shift,
    Assignment,
    AssignmentConflict
} from './types';

// Importer notre composant DisplayConfigPanel
import DisplayConfigPanel from './DisplayConfigPanel';
import { defaultDisplayConfig } from './DisplayConfigPanel';

// Données exemples (à remplacer par des appels API)
const SECTOR_COLORS: Record<string, string> = {
    'Hyperaseptique': '#3B82F6', // Bleu
    'Secteur 5-8': '#10B981',    // Vert
    'Secteur 9-12B': '#F97316',  // Orange
    'Ophtalmologie': '#EC4899',  // Rose
    'Endoscopie': '#4F46E5',     // Bleu roi
};

// Ajouter une fonction pour vérifier si un jour est férié
const isPublicHoliday = (date: Date): { isFerie: boolean, feteName: string } => {
    // Liste des jours fériés en France pour l'année 2024 (à adapter pour les années suivantes)
    const publicHolidays = [
        { date: new Date(2024, 0, 1), name: "Jour de l'An" },
        { date: new Date(2024, 3, 1), name: "Lundi de Pâques" },
        { date: new Date(2024, 4, 1), name: "Fête du Travail" },
        { date: new Date(2024, 4, 8), name: "Victoire 1945" },
        { date: new Date(2024, 4, 9), name: "Ascension" },
        { date: new Date(2024, 4, 20), name: "Lundi de Pentecôte" },
        { date: new Date(2024, 6, 14), name: "Fête Nationale" },
        { date: new Date(2024, 7, 15), name: "Assomption" },
        { date: new Date(2024, 10, 1), name: "Toussaint" },
        { date: new Date(2024, 10, 11), name: "Armistice 1918" },
        { date: new Date(2024, 11, 25), name: "Noël" }
    ];

    // Vérifier si la date passée correspond à un jour férié
    const matchingHoliday = publicHolidays.find(holiday =>
        holiday.date.getDate() === date.getDate() &&
        holiday.date.getMonth() === date.getMonth()
    );

    return {
        isFerie: !!matchingHoliday,
        feteName: matchingHoliday ? matchingHoliday.name : ''
    };
};

// Composant principal
const WeeklyPlanningPage: React.FC = () => {
    const startDay = startOfWeek(new Date(), { weekStartsOn: 1 });
    const initialWeek = Array.from({ length: 5 }, (_, i) => addDays(startDay, i));
    const [currentWeek, setCurrentWeek] = useState<Date[]>(initialWeek);
    const [assignments, setAssignments] = useState<Assignment[]>([]);
    const [rooms, setRooms] = useState<Room[]>([]);
    const [users, setUsers] = useState<User[]>([]);
    const [surgeons, setSurgeons] = useState<Surgeon[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [showLegend, setShowLegend] = useState<boolean>(true);
    const [expandedRoom, setExpandedRoom] = useState<number | null>(null);

    // Nouveaux états
    const [editMode, setEditMode] = useState<boolean>(false);
    const [editingAssignment, setEditingAssignment] = useState<Assignment | null>(null);
    const [searchTerm, setSearchTerm] = useState<string>('');
    const [selectedSectors, setSelectedSectors] = useState<string[]>([]);
    const [showMAR, setShowMAR] = useState<boolean>(true);
    const [showIADE, setShowIADE] = useState<boolean>(true);
    const [showSurgeons, setShowSurgeons] = useState<boolean>(true);
    const [viewMode, setViewMode] = useState<'rooms' | 'surgeons'>('rooms');
    const [displayMode, setDisplayMode] = useState<DisplayMode>('normal');
    const [showFilters, setShowFilters] = useState<boolean>(false);

    // Nouveaux états pour les fonctionnalités 5 et 6
    const [darkMode, setDarkMode] = useState<boolean>(false);
    const [isMobileView, setIsMobileView] = useState<boolean>(false);
    const [assignmentConflicts, setAssignmentConflicts] = useState<AssignmentConflict[]>([]);
    const [planningValidated, setPlanningValidated] = useState<boolean>(false);
    const [showValidationModal, setShowValidationModal] = useState<boolean>(false);
    const [validationErrors, setValidationErrors] = useState<string[]>([]);
    const [recentlyModified, setRecentlyModified] = useState<number[]>([]); // IDs des assignations récemment modifiées

    // Nouveaux états pour la gestion des conflits
    const [conflicts, setConflicts] = useState<{ [key: string]: Assignment[] }>({});
    const [recentChanges, setRecentChanges] = useState<{ [key: string]: Date }>({});

    // États supplémentaires pour la vue
    const [searchQuery, setSearchQuery] = useState<string>('');

    // Configuration d'affichage du planning
    const defaultDisplayConfig: DisplayConfig = {
        personnel: {
            chirurgien: {
                format: 'nom',
                style: 'bold',
                casse: 'uppercase',
                fontSize: 'sm',
                colorCode: '#4F46E5' // indigo-600
            },
            mar: {
                format: 'initiale-nom',
                style: 'normal',
                casse: 'default',
                fontSize: 'xs',
                colorCode: '#2563EB' // blue-600
            },
            iade: {
                format: 'nomPrenom',
                style: 'italic',
                casse: 'default',
                fontSize: 'xs',
                colorCode: '#059669' // emerald-600
            }
        },
        vacation: {
            matin: '#EFF6FF', // blue-50
            apresmidi: '#FEF3C7', // amber-100
            full: '#E0E7FF', // indigo-100
            conflit: '#FEE2E2', // red-100
            recent: '#ECFDF5', // green-50
            vide: '#F3F4F6', // gray-100
            border: '#E5E7EB' // gray-200
        },
        backgroundOpacity: 0.8,
        borderStyle: 'solid',
        borderWidth: 'medium',
        cardStyle: 'shadowed',
        showRole: true
    };

    const [displayConfig, setDisplayConfig] = useState<DisplayConfig>(defaultDisplayConfig);
    const [showDisplayConfig, setShowDisplayConfig] = useState<boolean>(false);

    // Jours de la semaine (lundi à vendredi)
    const weekDays = Array.from({ length: 5 }, (_, i) => addDays(currentWeek[0], i));

    // Référence pour le conteneur principal (pour le support des raccourcis clavier)
    const mainContainerRef = useRef<HTMLDivElement>(null);

    // Détecter le mode sombre du système et la taille d'écran
    useEffect(() => {
        // Détecter le mode sombre du système
        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        setDarkMode(darkModeMediaQuery.matches);

        const handleDarkModeChange = (e: MediaQueryListEvent) => {
            setDarkMode(e.matches);
        };

        darkModeMediaQuery.addEventListener('change', handleDarkModeChange);

        // Détecter la taille d'écran pour la vue mobile
        const checkIfMobile = () => {
            setIsMobileView(window.innerWidth < 768);
        };

        checkIfMobile();
        window.addEventListener('resize', checkIfMobile);

        return () => {
            darkModeMediaQuery.removeEventListener('change', handleDarkModeChange);
            window.removeEventListener('resize', checkIfMobile);
        };
    }, []);

    // Simuler le chargement des données
    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);

            try {
                // Dans un environnement réel, ces données viendraient d'API
                // Exemple de salles basées sur les secteurs définis
                const mockRooms: Room[] = [
                    // Hyperaseptique
                    { id: 1, name: 'Salle 1', number: '1', sector: 'Hyperaseptique', colorCode: SECTOR_COLORS['Hyperaseptique'] },
                    { id: 2, name: 'Salle 2', number: '2', sector: 'Hyperaseptique', colorCode: SECTOR_COLORS['Hyperaseptique'] },
                    { id: 3, name: 'Salle 3', number: '3', sector: 'Hyperaseptique', colorCode: SECTOR_COLORS['Hyperaseptique'] },
                    { id: 4, name: 'Salle 4', number: '4', sector: 'Hyperaseptique', colorCode: SECTOR_COLORS['Hyperaseptique'] },

                    // Secteur 5-8
                    { id: 5, name: 'Salle 5', number: '5', sector: 'Secteur 5-8', colorCode: SECTOR_COLORS['Secteur 5-8'] },
                    { id: 6, name: 'Salle 6', number: '6', sector: 'Secteur 5-8', colorCode: SECTOR_COLORS['Secteur 5-8'] },
                    { id: 7, name: 'Salle 7', number: '7', sector: 'Secteur 5-8', colorCode: SECTOR_COLORS['Secteur 5-8'] },
                    { id: 8, name: 'Césarienne', number: '8', sector: 'Secteur 5-8', colorCode: SECTOR_COLORS['Secteur 5-8'] },

                    // Secteur 9-12B
                    { id: 9, name: 'Salle 9', number: '9', sector: 'Secteur 9-12B', colorCode: SECTOR_COLORS['Secteur 9-12B'] },
                    { id: 10, name: 'Salle 10', number: '10', sector: 'Secteur 9-12B', colorCode: SECTOR_COLORS['Secteur 9-12B'] },
                    // ... autres salles
                ];

                // Exemple d'utilisateurs (MARs et IADEs)
                const mockUsers: User[] = [
                    { id: 1, nom: 'Dupont', prenom: 'Jean', role: 'MAR' },
                    { id: 2, nom: 'Martin', prenom: 'Sophie', role: 'MAR' },
                    { id: 3, nom: 'Petit', prenom: 'Thomas', role: 'MAR' },
                    { id: 4, nom: 'Durand', prenom: 'Marie', role: 'IADE' },
                    { id: 5, nom: 'Leroy', prenom: 'Lucas', role: 'IADE' },
                    // ... autres utilisateurs
                ];

                // Exemple de chirurgiens
                const mockSurgeons: Surgeon[] = [
                    { id: 1, nom: 'Garcia', prenom: 'Léa', specialite: 'Orthopédie' },
                    { id: 2, nom: 'Bernard', prenom: 'Michel', specialite: 'Cardiologie' },
                    { id: 3, nom: 'Moreau', prenom: 'Claire', specialite: 'Ophtalmologie' },
                    // ... autres chirurgiens
                ];

                // Générer quelques assignations pour la semaine
                const mockAssignments: Assignment[] = generateMockAssignments(mockRooms, mockUsers, mockSurgeons, weekDays);

                setRooms(mockRooms);
                setUsers(mockUsers);
                setSurgeons(mockSurgeons);
                setAssignments(mockAssignments);
            } catch (error) {
                console.error("Erreur lors du chargement des données:", error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [currentWeek]); // Recharger lorsque la semaine change

    // Générer des assignations fictives pour la démo
    const generateMockAssignments = (
        rooms: Room[],
        users: User[],
        surgeons: Surgeon[],
        days: Date[]
    ): Assignment[] => {
        const result: Assignment[] = [];
        let id = 1;

        // Pour chaque jour
        days.forEach(day => {
            // Pour chaque salle
            rooms.forEach(room => {
                // Décider aléatoirement si on assigne du personnel
                const assignMorning = Math.random() > 0.3;
                const assignAfternoon = Math.random() > 0.3;

                if (assignMorning) {
                    const marUser = users.filter(u => u.role === 'MAR')[Math.floor(Math.random() * users.filter(u => u.role === 'MAR').length)];
                    const surgeon = surgeons[Math.floor(Math.random() * surgeons.length)];

                    result.push({
                        id: id++,
                        roomId: room.id,
                        userId: marUser.id,
                        surgeonId: surgeon.id,
                        date: day,
                        shift: 'matin'
                    });
                }

                if (assignAfternoon) {
                    const iadeUser = users.filter(u => u.role === 'IADE')[Math.floor(Math.random() * users.filter(u => u.role === 'IADE').length)];
                    const surgeon = surgeons[Math.floor(Math.random() * surgeons.length)];

                    result.push({
                        id: id++,
                        roomId: room.id,
                        userId: iadeUser.id,
                        surgeonId: surgeon.id,
                        date: day,
                        shift: 'apresmidi'
                    });
                }
            });
        });

        return result;
    };

    // Navigation entre les semaines
    const goToPreviousWeek = () => {
        const newStartDay = subWeeks(currentWeek[0], 1);
        const newWeek = Array.from({ length: 5 }, (_, i) => addDays(newStartDay, i));
        setCurrentWeek(newWeek);
    };

    const goToNextWeek = () => {
        const newStartDay = addWeeks(currentWeek[0], 1);
        const newWeek = Array.from({ length: 5 }, (_, i) => addDays(newStartDay, i));
        setCurrentWeek(newWeek);
    };

    const goToCurrentWeek = () => {
        const startDay = startOfWeek(new Date(), { weekStartsOn: 1 });
        const newWeek = Array.from({ length: 5 }, (_, i) => addDays(startDay, i));
        setCurrentWeek(newWeek);
    };

    // Fonction pour trouver les assignations d'une salle pour une journée et un créneau
    const findAssignments = (roomId: number, day: Date, shift: Shift): Assignment | undefined => {
        const dayStart = startOfDay(day);
        return assignments.find(a =>
            a.roomId === roomId &&
            a.shift === shift &&
            startOfDay(new Date(a.date)).getTime() === dayStart.getTime()
        );
    };

    // Fonction pour obtenir les informations de l'utilisateur assigné
    const getUserInfo = (userId: number | null): User | undefined => {
        if (!userId) return undefined;
        return users.find(user => user.id === userId);
    };

    // Fonction pour obtenir les informations du chirurgien assigné
    const getSurgeonInfo = (surgeonId: number | null): Surgeon | undefined => {
        if (!surgeonId) return undefined;
        return surgeons.find(surgeon => surgeon.id === surgeonId);
    };

    // Toggle pour l'expansion des détails d'une salle
    const toggleRoomExpand = (roomId: number) => {
        if (expandedRoom === roomId) {
            setExpandedRoom(null);
        } else {
            setExpandedRoom(roomId);
        }
    };

    // Fonction pour détecter les conflits d'assignation
    const detectConflicts = useCallback(() => {
        const newConflicts: { [key: string]: Assignment[] } = {};

        // Parcourir toutes les assignations pour trouver les conflits
        assignments.forEach(assignment => {
            // Pour chaque personne assignée, vérifier si elle est assignée ailleurs au même moment
            const checkPerson = (personId: number | null, role: string) => {
                if (!personId) return;

                const conflictingAssignments = assignments.filter(a =>
                    a.id !== assignment.id &&
                    a.date.toString() === assignment.date.toString() &&
                    (
                        (role === 'surgeon' && a.surgeonId === personId) ||
                        (role === 'mar' && a.userId === personId) ||
                        (role === 'iade' && a.userId === personId)
                    ) &&
                    (
                        // Vérifier si les horaires se chevauchent
                        (a.shift === assignment.shift) ||
                        (a.shift === 'matin' && assignment.shift === 'full') ||
                        (a.shift === 'apresmidi' && assignment.shift === 'full') ||
                        (a.shift === 'full' && (assignment.shift === 'matin' || assignment.shift === 'apresmidi'))
                    )
                );

                if (conflictingAssignments.length > 0) {
                    const key = `${personId}-${assignment.date}-${assignment.shift}`;
                    newConflicts[key] = [assignment, ...conflictingAssignments];
                }
            };

            checkPerson(assignment.surgeonId, 'surgeon');
            checkPerson(assignment.userId, 'mar');
            checkPerson(assignment.userId, 'iade');
        });

        setConflicts(newConflicts);
    }, [assignments]);

    // Exécuter la détection des conflits quand les assignations changent
    useEffect(() => {
        detectConflicts();
    }, [assignments, detectConflicts]);

    // Fonction pour valider le planning
    const validatePlanning = () => {
        const errors: string[] = [];

        // Vérifier les conflits
        if (Object.keys(conflicts).length > 0) {
            errors.push(`${Object.keys(conflicts).length} conflit(s) d'assignation détecté(s)`);
        }

        // Vérifier les salles sans chirurgien
        const roomsWithoutSurgeon = assignments.filter(a => !a.surgeonId);
        if (roomsWithoutSurgeon.length > 0) {
            errors.push(`${roomsWithoutSurgeon.length} salle(s) sans chirurgien assigné`);
        }

        // Vérifier les salles sans MAR
        const roomsWithoutMAR = assignments.filter(a => !a.userId);
        if (roomsWithoutMAR.length > 0) {
            errors.push(`${roomsWithoutMAR.length} salle(s) sans MAR assigné`);
        }

        setValidationErrors(errors);

        if (errors.length === 0) {
            setPlanningValidated(true);
            return true;
        } else {
            setShowValidationModal(true);
            return false;
        }
    };

    // Fonction pour marquer une assignation comme récemment modifiée
    const markAsRecentlyChanged = (assignmentId: string) => {
        setRecentChanges(prev => ({
            ...prev,
            [assignmentId]: new Date()
        }));
    };

    // Effacer les modifications récentes après 24h
    useEffect(() => {
        const interval = setInterval(() => {
            const now = new Date();
            const updatedChanges = { ...recentChanges };
            let hasChanges = false;

            Object.entries(updatedChanges).forEach(([id, timestamp]) => {
                // Supprimer si plus de 24h
                if (now.getTime() - timestamp.getTime() > 24 * 60 * 60 * 1000) {
                    delete updatedChanges[id];
                    hasChanges = true;
                }
            });

            if (hasChanges) {
                setRecentChanges(updatedChanges);
            }
        }, 60 * 60 * 1000); // Vérifier toutes les heures

        return () => clearInterval(interval);
    }, [recentChanges]);

    // Filtrer les salles et assignations en fonction des critères de recherche
    const filteredRooms = rooms.filter(room => {
        // Filtre par secteur
        if (selectedSectors.length > 0 && !selectedSectors.includes(room.sector)) {
            return false;
        }

        // Filtre par terme de recherche
        if (searchTerm) {
            const lowerSearchTerm = searchTerm.toLowerCase();
            if (
                !room.name.toLowerCase().includes(lowerSearchTerm) &&
                !room.number.toLowerCase().includes(lowerSearchTerm) &&
                !room.sector.toLowerCase().includes(lowerSearchTerm)
            ) {
                // Recherche dans les assignations de cette salle
                const roomAssignments = assignments.filter(a => a.roomId === room.id);
                const foundInAssignments = roomAssignments.some(assignment => {
                    const surgeon = getSurgeonInfo(assignment.surgeonId);
                    const user = getUserInfo(assignment.userId);

                    return (
                        surgeon?.nom.toLowerCase().includes(lowerSearchTerm) ||
                        surgeon?.prenom.toLowerCase().includes(lowerSearchTerm) ||
                        user?.nom.toLowerCase().includes(lowerSearchTerm) ||
                        user?.prenom.toLowerCase().includes(lowerSearchTerm)
                    );
                });

                if (!foundInAssignments) {
                    return false;
                }
            }
        }

        return true;
    });

    // Basculer le mode d'édition
    const toggleEditMode = () => {
        setEditMode(!editMode);
        if (editMode) {
            setEditingAssignment(null);
        }
    };

    // Gérer le clic sur une assignation en mode édition
    const handleAssignmentClick = (assignment: Assignment | undefined, roomId: number, day: Date, shift: Shift) => {
        if (!editMode) return;

        if (assignment) {
            // Modifier une assignation existante
            setEditingAssignment({ ...assignment });
        } else {
            // Créer une nouvelle assignation
            const newAssignment: Assignment = {
                id: Date.now(), // ID temporaire
                roomId,
                userId: null,
                surgeonId: null,
                date: day,
                shift,
                notes: ''
            };
            setEditingAssignment(newAssignment);
        }
    };

    // Sauvegarder une assignation
    const saveAssignment = (updatedAssignment: Assignment) => {
        setAssignments(prev => {
            const newAssignments = prev.map(a =>
                a.id === updatedAssignment.id ? updatedAssignment : a
            );
            return newAssignments;
        });

        // Marquer comme récemment modifié
        markAsRecentlyChanged(updatedAssignment.id.toString());

        // Réinitialiser la validation
        setPlanningValidated(false);

        setShowEditModal(false);
        setEditingAssignment(null);
    };

    // Supprimer une assignation
    const deleteAssignment = (assignmentId: number) => {
        setAssignments(assignments.filter(a => a.id !== assignmentId));
        if (editingAssignment?.id === assignmentId) {
            setEditingAssignment(null);
        }
    };

    // Exporter le planning
    const exportPlanning = (format: 'csv' | 'excel' | 'pdf') => {
        if (format === 'csv') {
            // Générer CSV
            const headers = ['Date', 'Jour', 'Salle', 'Secteur', 'Créneau', 'Chirurgien', 'MAR', 'IADE', 'Notes'];
            const rows = assignments.map(a => {
                const room = rooms.find(r => r.id === a.roomId);
                const surgeon = surgeons.find(s => s.id === a.surgeonId);
                const user = users.find(u => u.id === a.userId);

                return [
                    formatDate(new Date(a.date), 'yyyy-MM-dd'),
                    formatDate(new Date(a.date), 'EEEE', { locale: fr }),
                    room?.name || '',
                    room?.sector || '',
                    a.shift === 'matin' ? 'Matin' : 'Après-midi',
                    surgeon ? `${surgeon.prenom} ${surgeon.nom}` : '',
                    user?.role === 'MAR' ? `${user.prenom} ${user.nom}` : '',
                    user?.role === 'IADE' ? `${user.prenom} ${user.nom}` : '',
                    a.notes || ''
                ];
            });

            const csvContent = [
                headers.join(','),
                ...rows.map(row => row.join(','))
            ].join('\n');

            // Créer un lien de téléchargement
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `planning_${formatDate(new Date(), 'yyyy-MM-dd')}.csv`);
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            // Pour les autres formats, on pourrait appeler une API
            alert(`Export au format ${format} en cours... Cette fonctionnalité serait implémentée côté serveur.`);
        }
    };

    // Basculer entre vue normale et condensée
    const toggleDisplayMode = () => {
        setDisplayMode(displayMode === 'normal' ? 'condensed' : 'normal');
    };

    // Support pour les raccourcis clavier
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            // Si le focus est dans un champ de texte, ne pas déclencher les raccourcis
            if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
                return;
            }

            switch (e.key) {
                case 'e':
                    // Basculer le mode édition avec la touche "e"
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        toggleEditMode();
                    }
                    break;
                case 'f':
                    // Ouvrir les filtres avec la touche "f"
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        setShowFilters(prev => !prev);
                    }
                    break;
                case 'c':
                    // Basculer la vue condensée avec la touche "c"
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        toggleDisplayMode();
                    }
                    break;
                case 'Escape':
                    // Fermer les modales avec Escape
                    if (editingAssignment) {
                        setEditingAssignment(null);
                    } else if (showValidationModal) {
                        setShowValidationModal(false);
                    }
                    break;
            }
        };

        document.addEventListener('keydown', handleKeyDown);

        return () => {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, [editingAssignment, showValidationModal, toggleEditMode]);

    // Supprimer l'indication "récemment modifié" après un délai
    useEffect(() => {
        if (recentlyModified.length > 0) {
            const timer = setTimeout(() => {
                setRecentlyModified([]);
            }, 30000); // 30 secondes

            return () => clearTimeout(timer);
        }
    }, [recentlyModified]);

    // Rendu d'une assignation
    const renderAssignment = (roomId: number, day: Date, shift: Shift) => {
        const assignment = findAssignments(roomId, day, shift);

        // Style en fonction du mode de vue
        const minHeight = displayMode === 'condensed' ? 'min-h-[70px]' : 'min-h-[100px]';
        const padding = displayMode === 'condensed' ? 'p-1' : 'p-2';

        // Vérifier si l'assignation a un conflit ou a été modifiée récemment
        const hasConflict = assignment?.hasConflict || (assignment && Object.values(conflicts).some(conflictList =>
            conflictList.some(a => a.id === assignment.id)
        ));
        const isRecentlyModified = assignment && (recentlyModified.includes(assignment.id) || Object.keys(recentChanges).includes(assignment.id.toString()));

        // Obtenir les styles pour la vacation basés sur la configuration
        const { bg: bgColor, border: borderStyle } = getVacationStyle(assignment, !!hasConflict, !!isRecentlyModified, darkMode, displayConfig);
        const cardStyle = getCardStyleClasses(displayConfig);

        // Structure de la case, qu'elle soit remplie ou vide
        return (
            <div
                className={`w-full h-full ${minHeight} rounded-lg ${borderStyle} ${bgColor} ${cardStyle} overflow-hidden transition-all hover:shadow-md ${editMode ? 'cursor-pointer' : ''} relative`}
                onClick={() => editMode && handleAssignmentClick(assignment, roomId, day, shift)}
                role="button"
                tabIndex={0}
                aria-label={assignment
                    ? `Détails de l'assignation pour la salle ${roomId} le ${formatDate(day, 'dd/MM/yyyy')} ${shift === 'matin' ? 'matin' : 'après-midi'}`
                    : `Ajouter une assignation pour la salle ${roomId} le ${formatDate(day, 'dd/MM/yyyy')} ${shift === 'matin' ? 'matin' : 'après-midi'}`
                }
                onKeyDown={(e) => {
                    if (e.key === 'Enter' && editMode) {
                        handleAssignmentClick(assignment, roomId, day, shift);
                    }
                }}
            >
                {assignment ? (
                    <div className={`h-full flex flex-col ${padding}`}>
                        {/* Indicateurs d'état */}
                        <div className="flex justify-end space-x-1 mb-1">
                            {hasConflict && (
                                <span title="Conflit d'assignation" className="text-red-500">
                                    <ExclamationTriangleIcon className="h-4 w-4" />
                                </span>
                            )}

                            {isRecentlyModified && (
                                <span title="Récemment modifié" className="text-yellow-500">
                                    <span className="animate-pulse">●</span>
                                </span>
                            )}

                            {assignment.isNew && (
                                <span title="Nouvelle assignation" className="text-green-500">
                                    NEW
                                </span>
                            )}

                            {/* Option pour supprimer en mode édition */}
                            {editMode && (
                                <button
                                    className={`text-gray-400 hover:text-red-500 p-0.5 rounded-full hover:${darkMode ? 'bg-gray-600' : 'bg-gray-100'}`}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        deleteAssignment(assignment.id);
                                    }}
                                    aria-label="Supprimer cette assignation"
                                >
                                    <XMarkIcon className="h-3 w-3" />
                                </button>
                            )}
                        </div>

                        {/* Encadrement rouge en cas de conflit */}
                        <div className={hasConflict ? 'border-2 border-red-500 rounded-md p-1 flex-1' : 'flex-1'}>
                            {/* Ligne Chirurgien - conditionnellement affichée */}
                            {showSurgeons && (
                                <div className={`${chirBg} rounded-t-md p-1 mb-1 border-l-4 ${chirBorder}`}>
                                    <div className={`${textSize} font-medium ${chirText} truncate`}>
                                        Chir: {assignment.surgeonId
                                            ? `${getSurgeonInfo(assignment.surgeonId)?.prenom.charAt(0)}. ${getSurgeonInfo(assignment.surgeonId)?.nom}`
                                            : "Non assigné"}
                                    </div>
                                </div>
                            )}

                            {/* Ligne MAR - conditionnellement affichée */}
                            {showMAR && (
                                <div className={`${marBg} p-1 mb-1 border-l-4 ${marBorder}`}>
                                    <div className={`${textSize} font-medium ${marText} truncate`}>
                                        MAR: {assignment.userId && getUserInfo(assignment.userId)?.role === 'MAR'
                                            ? `${getUserInfo(assignment.userId)?.prenom.charAt(0)}. ${getUserInfo(assignment.userId)?.nom}`
                                            : "Non assigné"}
                                    </div>
                                </div>
                            )}

                            {/* Ligne IADE - conditionnellement affichée */}
                            {showIADE && (
                                <div className={`${iadeBg} rounded-b-md p-1 border-l-4 ${iadeBorder}`}>
                                    <div className={`${textSize} font-medium ${iadeText} truncate`}>
                                        IADE: {assignment.userId && getUserInfo(assignment.userId)?.role === 'IADE'
                                            ? `${getUserInfo(assignment.userId)?.prenom.charAt(0)}. ${getUserInfo(assignment.userId)?.nom}`
                                            : "Non assigné"}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                ) : (
                    <div className="h-full flex items-center justify-center">
                        {editMode ? (
                            <span className="text-xs text-blue-400 font-medium">+ Ajouter</span>
                        ) : (
                            <span className={`text-xs ${emptyCardText} italic`}>Libre</span>
                        )}
                    </div>
                )}
            </div>
        );
    };

    // Rendu par secteur
    const renderSectorRooms = (sector: string) => {
        const sectorRooms = filteredRooms.filter(room => room.sector === sector);

        // Ne pas afficher les secteurs sans salles après filtrage
        if (sectorRooms.length === 0) {
            return null;
        }

        return (
            <div key={sector} className="mb-4">
                <div
                    className="flex items-center py-2 px-4 rounded-t-lg font-semibold text-white"
                    style={{
                        backgroundColor: SECTOR_COLORS[sector],
                        boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                    }}
                >
                    <h3 className="text-lg">{sector}</h3>
                </div>

                <div className="divide-y divide-gray-200 rounded-b-lg overflow-hidden shadow-md bg-white">
                    {sectorRooms.map(room => (
                        <div key={room.id} className="transition-all hover:bg-gray-50">
                            {/* En-tête de la salle */}
                            <div className="flex items-center">
                                <div
                                    className={`flex-none ${displayMode === 'condensed' ? 'py-3 px-2 w-16' : 'py-5 px-4 w-24'} text-center font-semibold`}
                                    style={{
                                        backgroundColor: `${room.colorCode}20`,
                                        borderRight: `3px solid ${room.colorCode}`
                                    }}
                                >
                                    {displayMode === 'condensed' ? room.number : `Salle ${room.number}`}
                                </div>

                                {/* En-tête du tableau */}
                                <div className={`grid grid-cols-11 mb-2 ${displayMode === 'condensed' ? 'text-xs' : ''}`}>
                                    <div className="col-span-1"></div>
                                    {/* Affichage des jours de la semaine en une seule ligne */}
                                    <div className="col-span-10 grid grid-cols-5 mb-1">
                                        {weekDays.map(day => {
                                            const { isFerie, feteName } = isPublicHoliday(day);
                                            return (
                                                <div key={day.toISOString()} className="px-1">
                                                    <div className={`text-center font-semibold py-2 rounded-t-lg ${isFerie
                                                        ? 'bg-red-500 text-white'
                                                        : isToday(day)
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-100 text-gray-800'
                                                        }`}>
                                                        <div className="capitalize">{formatDate(day, 'EEEE', { locale: fr })}</div>
                                                        <div>{formatDate(day, 'dd/MM', { locale: fr })}</div>
                                                        {isFerie && <div className="text-xs font-normal italic">{feteName}</div>}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>

                                    {/* Deuxième ligne pour les créneaux matin et après-midi */}
                                    <div className="col-span-1"></div>
                                    {weekDays.map(day => (
                                        <div key={`slots-${day.toISOString()}`} className="col-span-2 grid grid-cols-2 text-center text-xs border-l border-r border-b border-gray-200 rounded-b-lg">
                                            <div className="py-1 bg-blue-50">Matin</div>
                                            <div className="py-1 bg-amber-50">Après-midi</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        );
    };

    // Fonction pour ouvrir le modal d'assignation en mode chirurgien
    const openSurgeonAssignmentModal = (date: string, surgeonId: number, timeSlot: string) => {
        // Créer une nouvelle assignation temporaire
        const newAssignment: Assignment = {
            id: Date.now(),
            roomId: 0, // À sélectionner dans le modal
            userId: null,
            surgeonId: surgeonId,
            date: new Date(date),
            shift: timeSlot === 'AM' ? 'matin' : 'apresmidi',
            notes: '',
            isNew: true
        };
        setEditingAssignment(newAssignment);
    };

    // Fonction pour ouvrir le modal d'assignation pour une salle
    const openAssignmentModal = (date: string, roomId: number, timeSlot: string, existingAssignment?: Assignment) => {
        if (existingAssignment) {
            setEditingAssignment(existingAssignment);
        } else {
            // Créer une nouvelle assignation
            const newAssignment: Assignment = {
                id: Date.now(),
                roomId: roomId,
                userId: null,
                surgeonId: null,
                date: new Date(date),
                shift: timeSlot === 'AM' ? 'matin' : 'apresmidi',
                notes: '',
                isNew: true
            };
            setEditingAssignment(newAssignment);
        }
    };

    // État pour le modal d'édition
    const [showEditModal, setShowEditModal] = useState<boolean>(false);

    // Ajout de la fonction pour afficher les assignations d'un chirurgien
    const renderSurgeonAssignment = (surgeonId: number, day: Date, shift: Shift) => {
        // Trouver toutes les assignations pour ce chirurgien à ce jour et ce créneau
        const dayString = formatDate(day, 'yyyy-MM-dd');
        const surgeonAssignments = assignments.filter(a =>
            a.surgeonId === surgeonId &&
            formatDate(new Date(a.date), 'yyyy-MM-dd') === dayString &&
            a.shift === shift
        );

        // Style en fonction du mode de vue
        const minHeight = displayMode === 'condensed' ? 'min-h-[70px]' : 'min-h-[100px]';
        const padding = displayMode === 'condensed' ? 'p-1' : 'p-2';
        const textSize = displayMode === 'condensed' ? 'text-xs' : 'text-xs';

        // Styles adaptés en fonction du mode sombre
        const emptyCardBg = darkMode ? 'bg-gray-800' : 'bg-gray-50';
        const emptyCardBorder = darkMode ? 'border-gray-700' : 'border-gray-300';
        const emptyCardText = darkMode ? 'text-gray-400' : 'text-gray-400';

        const filledCardBg = darkMode ? 'bg-gray-700' : 'bg-white';
        const filledCardShadow = darkMode ? 'shadow-gray-900' : 'shadow-sm';

        if (surgeonAssignments.length === 0) {
            // Aucune assignation pour ce chirurgien
            return (
                <div
                    className={`w-full h-full ${minHeight} rounded-lg border border-dashed ${emptyCardBorder} ${emptyCardBg} overflow-hidden transition-all`}
                    role="button"
                    tabIndex={0}
                    aria-label={`Aucune assignation pour ${getSurgeonInfo(surgeonId)?.prenom} ${getSurgeonInfo(surgeonId)?.nom} le ${formatDate(day, 'dd/MM/yyyy')} ${shift === 'matin' ? 'matin' : 'après-midi'}`}
                >
                    <div className="h-full flex items-center justify-center">
                        {editMode ? (
                            <span className="text-xs text-blue-400 font-medium cursor-pointer" onClick={() => openSurgeonAssignmentModal(dayString, surgeonId, shift === 'matin' ? 'AM' : 'PM')}>
                                + Ajouter
                            </span>
                        ) : (
                            <span className={`text-xs ${emptyCardText} italic`}>Libre</span>
                        )}
                    </div>
                </div>
            );
        }

        // Afficher les assignations existantes
        return (
            <div className="space-y-2">
                {surgeonAssignments.map(assignment => {
                    const room = rooms.find(r => r.id === assignment.roomId);
                    const hasConflict = Object.values(conflicts).some(conflictList =>
                        conflictList.some(a => a.id === assignment.id)
                    );
                    const isRecentlyModified = Object.keys(recentChanges).includes(assignment.id.toString());

                    return (
                        <div
                            key={assignment.id}
                            className={`w-full rounded-lg border ${filledCardBg} ${filledCardShadow} overflow-hidden transition-all ${hasConflict ? 'border-red-500 bg-red-50 dark:bg-red-900/20' :
                                isRecentlyModified ? 'border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20' :
                                    'border-gray-200 dark:border-gray-700'
                                } ${editMode ? 'cursor-pointer' : ''}`}
                            onClick={() => editMode && openAssignmentModal(dayString, assignment.roomId, shift === 'matin' ? 'AM' : 'PM', assignment)}
                        >
                            <div className={`${padding}`}>
                                <div className="font-medium flex items-center justify-between">
                                    <span>{room?.name || 'Salle inconnue'}</span>
                                    <div className="flex space-x-1">
                                        {hasConflict && (
                                            <span title="Conflit d'assignation" className="text-red-500">
                                                <ExclamationTriangleIcon className="h-4 w-4" />
                                            </span>
                                        )}
                                        {isRecentlyModified && (
                                            <span title="Récemment modifié" className="text-yellow-500">
                                                <span className="animate-pulse">●</span>
                                            </span>
                                        )}
                                    </div>
                                </div>
                                <div className="text-xs text-gray-500 dark:text-gray-400">
                                    MAR: {assignment.userId && getUserInfo(assignment.userId)?.role === 'MAR'
                                        ? `${getUserInfo(assignment.userId)?.prenom.charAt(0)}. ${getUserInfo(assignment.userId)?.nom}`
                                        : "Non assigné"}
                                </div>
                                <div className="text-xs text-gray-500 dark:text-gray-400">
                                    IADE: {assignment.userId && getUserInfo(assignment.userId)?.role === 'IADE'
                                        ? `${getUserInfo(assignment.userId)?.prenom.charAt(0)}. ${getUserInfo(assignment.userId)?.nom}`
                                        : "Non assigné"}
                                </div>
                                {editMode && (
                                    <div className="mt-2 flex justify-end space-x-1">
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                deleteAssignment(assignment.id);
                                            }}
                                            className="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 p-0.5"
                                            aria-label="Supprimer cette assignation"
                                        >
                                            <XMarkIcon className="h-3 w-3" />
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>
                    );
                })}
            </div>
        );
    };

    // Référence globale pour les assignations (utilisée dans le modal d'édition)
    useEffect(() => {
        // @ts-ignore - C'est un hack pour rendre les assignations accessibles au composant de modal
        window.weeklyPlanningAssignments = assignments;
        return () => {
            // @ts-ignore
            delete window.weeklyPlanningAssignments;
        };
    }, [assignments]);

    // Ajouter des états pour l'import/export
    const [showImportModal, setShowImportModal] = useState<boolean>(false);
    const [importData, setImportData] = useState<string>('');
    const [importPreview, setImportPreview] = useState<Assignment[]>([]);
    const [exportFormat, setExportFormat] = useState<'csv' | 'excel' | 'pdf'>('excel');
    const fileInputRef = useRef<HTMLInputElement>(null);

    // Fonction pour gérer l'import de données
    const handleImportFile = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const content = event.target?.result as string;
                setImportData(content);

                // Parser les données CSV basiques
                if (file.name.endsWith('.csv')) {
                    const lines = content.split('\n');
                    const headers = lines[0].split(',');

                    // Indices des colonnes
                    const dateIndex = headers.findIndex(h => h.includes('Date'));
                    const roomIndex = headers.findIndex(h => h.includes('Salle'));
                    const shiftIndex = headers.findIndex(h => h.includes('Créneau'));
                    const surgeonIndex = headers.findIndex(h => h.includes('Chirurgien'));
                    const marIndex = headers.findIndex(h => h.includes('MAR'));
                    const iadeIndex = headers.findIndex(h => h.includes('IADE'));

                    // Convertir en assignations
                    const newAssignments: Assignment[] = [];
                    for (let i = 1; i < lines.length; i++) {
                        if (!lines[i].trim()) continue;

                        const values = lines[i].split(',');
                        if (values.length < Math.max(dateIndex, roomIndex, shiftIndex) + 1) continue;

                        // Trouver les IDs correspondants
                        const foundRoom = rooms.find(r =>
                            values[roomIndex] && r.name && r.name.includes(values[roomIndex]));
                        const roomId = foundRoom ? foundRoom.id : 0;

                        let surgeonId = null;
                        if (values[surgeonIndex] && values[surgeonIndex].trim()) {
                            const surgeonName = values[surgeonIndex].split(' ');
                            const foundSurgeon = surgeons.find(s =>
                                s.nom && surgeonName.length > 0 &&
                                s.nom.includes(surgeonName[surgeonName.length - 1]));

                            surgeonId = foundSurgeon?.id || null;

                            // Décider si c'est un MAR ou un IADE
                            let userId = null;
                            if (values[marIndex] && values[marIndex].trim()) {
                                const marName = values[marIndex].split(' ');
                                userId = users.find(u =>
                                    u.role === 'MAR' &&
                                    u.nom.includes(marName[marName.length - 1]))?.id || null;
                            } else if (values[iadeIndex] && values[iadeIndex].trim()) {
                                const iadeName = values[iadeIndex].split(' ');
                                userId = users.find(u =>
                                    u.role === 'IADE' &&
                                    u.nom.includes(iadeName[iadeName.length - 1]))?.id || null;
                            }

                            if (roomId) {
                                newAssignments.push({
                                    id: Date.now() + i, // ID temporaire
                                    roomId,
                                    surgeonId,
                                    userId,
                                    date: new Date(values[dateIndex]),
                                    shift: values[shiftIndex].toLowerCase().includes('matin') ? 'matin' : 'apresmidi',
                                    isNew: true
                                });
                            }
                        }
                    }
                    setImportPreview(newAssignments);
                }
            } catch (error) {
                console.error("Erreur lors du parsing du fichier importé:", error);
            }
        };
        reader.readAsText(file);
    };

    // Fonction pour confirmer l'import
    const confirmImport = () => {
        if (importPreview.length > 0) {
            // Option 1: Remplacer toutes les assignations
            // setAssignments(importPreview);

            // Option 2: Ajouter aux assignations existantes (éviter les doublons)
            const existingDates = new Set(assignments.map(a =>
                `${format(new Date(a.date), 'yyyy-MM-dd')}-${a.roomId}-${a.shift}`
            ));

            const newAssignments = [
                ...assignments,
                ...importPreview.filter(a =>
                    !existingDates.has(`${format(new Date(a.date), 'yyyy-MM-dd')}-${a.roomId}-${a.shift}`)
                )
            ];

            setAssignments(newAssignments);
            setShowImportModal(false);
            setImportData('');
            setImportPreview([]);

            // Réinitialiser le champ de fichier
            if (fileInputRef.current) {
                fileInputRef.current.value = '';
            }
        }
    };

    // Fonction pour obtenir le style de la vacation
    const getVacationStyle = (
        assignment: Assignment | undefined,
        hasConflict: boolean,
        isRecentlyModified: boolean,
        darkMode: boolean,
        displayConfig: DisplayConfig
    ): { bg: string; border: string; } => {
        if (!assignment) {
            return {
                bg: darkMode ? 'bg-gray-800' : `bg-[${displayConfig.vacation.vide}]`,
                border: darkMode ? 'border-gray-700' : `border-[${displayConfig.vacation.border}]`
            };
        }

        let bgColor = '';
        if (hasConflict) {
            bgColor = darkMode ? 'bg-red-900/20' : `bg-[${displayConfig.vacation.conflit}]`;
        } else if (isRecentlyModified) {
            bgColor = darkMode ? 'bg-yellow-900/20' : `bg-[${displayConfig.vacation.recent}]`;
        } else {
            switch (assignment.shift) {
                case 'matin':
                    bgColor = darkMode ? 'bg-blue-900/20' : `bg-[${displayConfig.vacation.matin}]`;
                    break;
                case 'apresmidi':
                    bgColor = darkMode ? 'bg-amber-900/20' : `bg-[${displayConfig.vacation.apresmidi}]`;
                    break;
                case 'full':
                    bgColor = darkMode ? 'bg-indigo-900/20' : `bg-[${displayConfig.vacation.full}]`;
                    break;
                default:
                    bgColor = darkMode ? 'bg-gray-700' : 'bg-white';
            }
        }

        const borderWidth = {
            'thin': 'border',
            'medium': 'border-2',
            'thick': 'border-4'
        }[displayConfig.borderWidth];

        const borderStyle = {
            'solid': 'border-solid',
            'dashed': 'border-dashed',
            'dotted': 'border-dotted',
            'double': 'border-double'
        }[displayConfig.borderStyle];

        const borderColor = hasConflict
            ? 'border-red-500'
            : isRecentlyModified
                ? 'border-yellow-500'
                : darkMode ? 'border-gray-700' : `border-[${displayConfig.vacation.border}]`;

        return {
            bg: bgColor,
            border: `${borderWidth} ${borderStyle} ${borderColor}`
        };
    };

    // Fonction pour obtenir le style de carte en fonction de la configuration
    const getCardStyleClasses = (displayConfig: DisplayConfig): string => {
        switch (displayConfig.cardStyle) {
            case 'flat':
                return '';
            case 'shadowed':
                return 'shadow-md';
            case 'bordered':
                return 'border-2';
            case 'rounded':
                return 'rounded-lg';
            default:
                return 'shadow-sm';
        }
    };

    return (
        <div ref={mainContainerRef} className={`p-4 ${darkMode ? 'dark bg-gray-900 text-white' : 'bg-white text-gray-900'}`}>
            {/* Panneau de configuration d'affichage */}
            {showDisplayConfig && (
                <DisplayConfigPanel
                    config={displayConfig}
                    onConfigChange={setDisplayConfig}
                    onClose={() => setShowDisplayConfig(false)}
                />
            )}

            {/* En-tête avec titre et boutons d'action */}
            <div className="flex justify-between items-center mb-4 flex-wrap gap-2">
                <h1 className="text-2xl font-bold">Planning Hebdomadaire du Bloc</h1>

                <div className="flex items-center space-x-2">
                    {/* Bouton mode sombre */}
                    <button
                        onClick={() => setDarkMode(!darkMode)}
                        className={`p-2 rounded-full ${darkMode ? 'bg-gray-700 text-yellow-300' : 'bg-gray-100 text-gray-700'}`}
                        aria-label={darkMode ? "Activer le mode clair" : "Activer le mode sombre"}
                    >
                        {darkMode ? <SunIcon className="h-5 w-5" /> : <MoonIcon className="h-5 w-5" />}
                    </button>

                    {/* Navigation entre les semaines */}
                    <div className="flex items-center px-2 py-1 rounded-lg bg-gray-100 dark:bg-gray-800">
                        <button
                            onClick={goToPreviousWeek}
                            className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"
                            aria-label="Semaine précédente"
                        >
                            <ChevronLeftIcon className="h-5 w-5" />
                        </button>
                        <button
                            onClick={goToCurrentWeek}
                            className="mx-2 px-2 py-0.5 text-xs font-medium rounded hover:bg-gray-200 dark:hover:bg-gray-700"
                        >
                            Aujourd'hui
                        </button>
                        <button
                            onClick={goToNextWeek}
                            className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"
                            aria-label="Semaine suivante"
                        >
                            <ChevronRightIcon className="h-5 w-5" />
                        </button>
                    </div>

                    {/* Boutons d'action */}
                    <div className="flex space-x-2">
                        <button
                            onClick={toggleEditMode}
                            className={`p-2 rounded-full ${editMode ? 'bg-blue-600 text-white' : darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200'}`}
                            aria-pressed={editMode}
                            aria-label={editMode ? "Désactiver le mode édition" : "Activer le mode édition"}
                        >
                            {editMode ? <CheckIcon className="h-5 w-5" /> : <PencilIcon className="h-5 w-5" />}
                        </button>
                    </div>
                </div>
            </div>

            {/* Barre d'outils secondaire */}
            <div className="mb-6 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm">
                <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                    <div className="flex items-center gap-2">
                        <div className="text-lg font-medium">
                            Semaine du {formatDate(currentWeek[0], 'dd MMMM', { locale: fr })} au {formatDate(currentWeek[4], 'dd MMMM yyyy', { locale: fr })}
                        </div>
                    </div>

                    <div className="flex space-x-2">
                        <button
                            onClick={() => setViewMode(viewMode === 'rooms' ? 'surgeons' : 'rooms')}
                            className={`px-3 py-1 rounded ${viewMode === 'surgeons' ? 'bg-indigo-500 text-white' : 'bg-gray-200 dark:bg-gray-700'}`}
                            aria-pressed={viewMode === 'surgeons'}
                        >
                            {viewMode === 'surgeons' ? 'Par salle' : 'Par chirurgien'}
                        </button>
                        <button
                            onClick={toggleDisplayMode}
                            className={`px-3 py-1 rounded ${displayMode === 'condensed' ? 'bg-purple-500 text-white' : 'bg-gray-200 dark:bg-gray-700'}`}
                            aria-pressed={displayMode === 'condensed'}
                        >
                            {displayMode === 'condensed' ? 'Vue normale' : 'Vue condensée'}
                        </button>

                        {/* Bouton pour ouvrir le panneau de configuration d'affichage */}
                        <button
                            onClick={() => setShowDisplayConfig(true)}
                            className="px-3 py-1 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 flex items-center"
                            aria-label="Configurer l'affichage"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" />
                            </svg>
                            Style
                        </button>
                    </div>

                    <div className="flex-grow">
                        <input
                            type="text"
                            placeholder="Rechercher..."
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            className="w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:border-gray-600"
                            aria-label="Rechercher dans le planning"
                        />
                    </div>
                </div>
            </div>

            {/* Contenu restant de la page */}
            {loading ? (
                <div className="flex justify-center items-center h-64" role="status">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
                    <span className="sr-only">Chargement...</span>
                </div>
            ) : (
                <>
                    {/* En-tête du tableau avec les jours de la semaine */}
                    <div className="mx-auto px-4 mt-6">
                        {/* Première ligne: jours de la semaine */}
                        <div className="grid grid-cols-11 mb-1">
                            <div className="col-span-1"></div>
                            <div className="col-span-10 grid grid-cols-5 gap-1">
                                {weekDays.map(day => {
                                    const { isFerie, feteName } = isPublicHoliday(day);
                                    return (
                                        <div key={day.toISOString()} className="px-1">
                                            <div className={`text-center font-semibold py-2 rounded-t-lg ${isFerie
                                                ? 'bg-red-500 text-white'
                                                : isToday(day)
                                                    ? 'bg-blue-600 text-white'
                                                    : 'bg-gray-100 text-gray-800'
                                                }`}>
                                                <div className="capitalize">{formatDate(day, 'EEEE', { locale: fr })}</div>
                                                <div>{formatDate(day, 'dd/MM', { locale: fr })}</div>
                                                {isFerie && <div className="text-xs font-normal italic">{feteName}</div>}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* Deuxième ligne: créneaux matin/après-midi */}
                        <div className="grid grid-cols-11 mb-4">
                            <div className="col-span-1"></div>
                            {weekDays.map(day => (
                                <div key={`slots-${day.toISOString()}`} className="col-span-2 grid grid-cols-2 text-center text-xs border-l border-r border-b border-gray-200 dark:border-gray-700 rounded-b-lg">
                                    <div className="py-1 bg-blue-50 dark:bg-blue-900/20">Matin</div>
                                    <div className="py-1 bg-amber-50 dark:bg-amber-900/20">Après-midi</div>
                                </div>
                            ))}
                        </div>

                        {/* Corps du tableau par secteur */}
                        {viewMode === 'rooms' ? (
                            // Vue par salle
                            Object.keys(SECTOR_COLORS).map(sector => renderSectorRooms(sector))
                        ) : (
                            // Vue par chirurgien
                            <div className="mb-4">
                                <div className="bg-indigo-600 text-white py-2 px-4 rounded-t-lg font-semibold">
                                    <h3 className="text-lg">Planning des chirurgiens</h3>
                                </div>
                                <div className="divide-y divide-gray-200 rounded-b-lg overflow-hidden shadow-md bg-white dark:bg-gray-800 dark:divide-gray-700">
                                    {surgeons.filter(surgeon =>
                                        searchTerm ?
                                            surgeon.nom.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                            surgeon.prenom.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                            surgeon.specialite.toLowerCase().includes(searchTerm.toLowerCase())
                                            : true
                                    ).map(surgeon => (
                                        <div key={surgeon.id} className="transition-all hover:bg-gray-50 dark:hover:bg-gray-700">
                                            {/* En-tête du chirurgien */}
                                            <div className="flex items-center">
                                                <div className="flex-none py-4 px-4 w-32 md:w-48 text-center font-semibold bg-indigo-50 dark:bg-indigo-900/30 border-r-2 border-indigo-300 dark:border-indigo-700">
                                                    <div>{surgeon.prenom} {surgeon.nom}</div>
                                                    <div className="text-xs text-gray-500 dark:text-gray-400">{surgeon.specialite}</div>
                                                </div>

                                                {/* Affichage des cases pour chaque jour et période */}
                                                <div className="flex-1 grid grid-cols-10 gap-1 p-2">
                                                    {weekDays.map(day => (
                                                        <React.Fragment key={day.toISOString()}>
                                                            <div className={`${displayMode === 'condensed' ? 'p-0.5' : 'p-1'}`}>
                                                                {renderSurgeonAssignment(surgeon.id, day, 'matin')}
                                                            </div>
                                                            <div className={`${displayMode === 'condensed' ? 'p-0.5' : 'p-1'}`}>
                                                                {renderSurgeonAssignment(surgeon.id, day, 'apresmidi')}
                                                            </div>
                                                        </React.Fragment>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Message si aucun résultat après filtrage */}
                        {viewMode === 'rooms' && filteredRooms.length === 0 && (
                            <div className="bg-gray-50 p-6 text-center rounded-lg border border-gray-200 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-300">
                                <p className="text-gray-500 dark:text-gray-400">Aucune salle ne correspond à votre recherche.</p>
                            </div>
                        )}
                        {viewMode === 'surgeons' && surgeons.filter(s =>
                            searchTerm ?
                                s.nom.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                s.prenom.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                s.specialite.toLowerCase().includes(searchTerm.toLowerCase())
                                : true
                        ).length === 0 && (
                                <div className="bg-gray-50 p-6 text-center rounded-lg border border-gray-200 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-300">
                                    <p className="text-gray-500 dark:text-gray-400">Aucun chirurgien ne correspond à votre recherche.</p>
                                </div>
                            )}
                    </div>
                </>
            )}
        </div>
    );
};

export default WeeklyPlanningPage; 