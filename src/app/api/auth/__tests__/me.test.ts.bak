import { NextRequest, NextResponse } from 'next/server';
import { GET } from '../me/route';
import { getServerSession } from 'next-auth/next';
import { verifyAuthToken, getAuthTokenServer } from '@/lib/auth-server-utils';

// Mocks
jest.mock('next-auth/next');
jest.mock('@/lib/auth-server-utils');
jest.mock('@prisma/client');

// Définir un type personnalisé pour notre mock de réponse
interface MockResponse extends NextResponse {
    data: any;
}

// Mock NextResponse pour les tests d'API route
jest.mock('next/server', () => {
    const originalModule = jest.requireActual('next/server');
    return {
        ...originalModule,
        NextResponse: {
            ...originalModule.NextResponse,
            json: jest.fn((data, init) => {
                return {
                    status: init?.status || 200,
                    headers: new Headers(init?.headers),
                    json: () => Promise.resolve(data),
                    data // Pour faciliter les tests
                };
            })
        }
    };
});

describe('API /auth/me', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
        (NextResponse.json as jest.Mock).mockClear();
    });

    it('authentifie avec NextAuth correctement', async () => {
        // Simuler une session valide
        (getServerSession as jest.Mock).mockResolvedValue({
            user: {
                id: 123,
                login: 'test-user',
                email: 'user@example.com',
                name: 'Test User',
                role: 'USER',
                accessToken: 'valid-access-token'
            }
        });

        const req = new NextRequest('http://localhost/api/auth/me');
        const response = await GET(req) as MockResponse;
        const data = response.data;

        expect(response.status).toBe(200);
        expect(data).toEqual({
            authenticated: true,
            authMethod: 'nextauth',
            user: {
                id: 123,
                login: 'test-user',
                email: 'user@example.com',
                name: 'Test User',
                role: 'USER',
                accessToken: 'valid-access-token'
            }
        });
    });

    it('authentifie avec token en header Authorization quand NextAuth échoue', async () => {
        // Pas de session NextAuth
        (getServerSession as jest.Mock).mockResolvedValue(null);

        // Token valide dans le header Authorization
        const authHeader = 'Bearer valid-token-from-header';
        const headers = new Headers();
        headers.append('Authorization', authHeader);

        const req = new NextRequest('http://localhost/api/auth/me', {
            headers
        });

        // Configurer le mock pour verifyAuthToken
        (verifyAuthToken as jest.Mock).mockResolvedValue({
            authenticated: true,
            userId: 456,
            role: 'ADMIN'
        });

        // Configurer le mock prisma
        const mockUser = {
            id: 456,
            login: 'admin-user',
            email: 'admin@example.com',
            nom: 'Admin',
            prenom: 'User',
            role: 'ADMIN'
        };

        const mockPrismaClient = {
            user: {
                findUnique: jest.fn().mockResolvedValue(mockUser)
            },
            $disconnect: jest.fn()
        };

        const PrismaClientMock = jest.requireMock('@prisma/client').PrismaClient;
        PrismaClientMock.mockImplementation(() => mockPrismaClient);

        const response = await GET(req) as MockResponse;
        const data = response.data;

        expect(response.status).toBe(200);
        expect(data).toEqual(expect.objectContaining({
            authenticated: true,
            authMethod: 'custom_token',
            user: mockUser
        }));
    });

    it('authentifie avec token dans les cookies quand NextAuth échoue', async () => {
        // Pas de session NextAuth
        (getServerSession as jest.Mock).mockResolvedValue(null);

        // Pas de token dans le header
        const req = new NextRequest('http://localhost/api/auth/me');

        // Token dans le cookie
        (getAuthTokenServer as jest.Mock).mockResolvedValue('valid-token-from-cookie');

        // Configurer le mock pour verifyAuthToken
        (verifyAuthToken as jest.Mock).mockResolvedValue({
            authenticated: true,
            userId: 789,
            role: 'USER'
        });

        // Configurer le mock prisma
        const mockUser = {
            id: 789,
            login: 'cookie-user',
            email: 'cookie@example.com',
            nom: 'Cookie',
            prenom: 'User',
            role: 'USER'
        };

        const mockPrismaClient = {
            user: {
                findUnique: jest.fn().mockResolvedValue(mockUser)
            },
            $disconnect: jest.fn()
        };

        const PrismaClientMock = jest.requireMock('@prisma/client').PrismaClient;
        PrismaClientMock.mockImplementation(() => mockPrismaClient);

        const response = await GET(req) as MockResponse;
        const data = response.data;

        expect(response.status).toBe(200);
        expect(data).toEqual(expect.objectContaining({
            authenticated: true,
            authMethod: 'custom_token',
            user: mockUser
        }));
    });

    it('renvoie 401 quand aucune authentification n'est trouvée', async () => {
        // Aucun moyen d'authentification
        (getServerSession as jest.Mock).mockResolvedValue(null);
        (getAuthTokenServer as jest.Mock).mockResolvedValue(null);

        const req = new NextRequest('http://localhost/api/auth/me');
        const response = await GET(req) as MockResponse;
        const data = response.data;

        expect(response.status).toBe(401);
        expect(data).toEqual(expect.objectContaining({
            authenticated: false,
            error: 'Non authentifié'
        }));
    });

    it('renvoie 401 quand le token n'est pas valide', async () => {
        // Pas de session NextAuth
        (getServerSession as jest.Mock).mockResolvedValue(null);

        // Un token est trouvé mais pas valide
        (getAuthTokenServer as jest.Mock).mockResolvedValue('invalid-token');
        (verifyAuthToken as jest.Mock).mockResolvedValue({
            authenticated: false,
            error: 'Token invalide ou expiré'
        });

        const req = new NextRequest('http://localhost/api/auth/me');
        const response = await GET(req) as MockResponse;
        const data = response.data;

        expect(response.status).toBe(401);
        expect(data).toEqual(expect.objectContaining({
            authenticated: false,
            error: 'Token invalide ou expiré'
        }));
    });

    it('renvoie 404 quand l'utilisateur n'est pas trouvé en base de données', async () => {
        // Pas de session NextAuth
        (getServerSession as jest.Mock).mockResolvedValue(null);

        // Token valide mais utilisateur non trouvé
        (getAuthTokenServer as jest.Mock).mockResolvedValue('valid-token');
        (verifyAuthToken as jest.Mock).mockResolvedValue({
            authenticated: true,
            userId: 999,
            role: 'USER'
        });

        // L'utilisateur n'existe pas en BDD
        const mockPrismaClient = {
            user: {
                findUnique: jest.fn().mockResolvedValue(null)
            },
            $disconnect: jest.fn()
        };

        const PrismaClientMock = jest.requireMock('@prisma/client').PrismaClient;
        PrismaClientMock.mockImplementation(() => mockPrismaClient);

        const req = new NextRequest('http://localhost/api/auth/me');
        const response = await GET(req) as MockResponse;
        const data = response.data;

        expect(response.status).toBe(404);
        expect(data).toEqual(expect.objectContaining({
            authenticated: false,
            error: 'Utilisateur non trouvé'
        }));
    });

    it('gère les erreurs serveur correctement', async () => {
        // Simuler une erreur serveur
        (getServerSession as jest.Mock).mockRejectedValue(new Error('Erreur serveur simulée'));

        const req = new NextRequest('http://localhost/api/auth/me');
        const response = await GET(req) as MockResponse;
        const data = response.data;

        expect(response.status).toBe(500);
        expect(data).toEqual(expect.objectContaining({
            authenticated: false,
            error: 'Erreur serveur'
        }));
    });
}); 