import { NextRequest } from 'next/server';
import { POST } from '../route';
import { applySimulationService } from '@/services/simulations/applySimulationService';
import { getServerSession } from 'next-auth';

// Mocks
jest.mock('next-auth');
jest.mock('@/services/simulations/applySimulationService');
jest.mock('@prisma/client', () => {
    const mockPrismaClient = {
        user: {
            findUnique: jest.fn()
        }
    };

    return {
        PrismaClient: jest.fn(() => mockPrismaClient)
    };
});

// Création d'une fonction utilitaire pour simuler les requêtes
const createMockRequest = (body: any) => {
    return {
        json: jest.fn().mockResolvedValue(body)
    } as unknown as NextRequest;
};

jest.mock('@/lib/prisma');

describe('API POST /api/simulations/apply', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    
        jest.clearAllMocks();
    });

    it('doit rejeter les requêtes non authentifiées', async () => {
        // Arrange
        const mockRequest = createMockRequest({
            simulationResultId: 'sim-result-123'
        });

        // Simuler une session non authentifiée
        (getServerSession as jest.Mock).mockResolvedValue(null);

        // Act
        const response = await POST(mockRequest);

        // Assert
        expect(response.status).toBe(401);
        const data = await response.json();
        expect(data).toHaveProperty('error', 'Non autorisé');
    });

    it('doit rejeter les requêtes sans ID de résultat de simulation', async () => {
        // Arrange
        const mockRequest = createMockRequest({});

        // Simuler une session authentifiée
        (getServerSession as jest.Mock).mockResolvedValue({
            user: { email: 'test@example.com' }
        });

        // Act
        const response = await POST(mockRequest);

        // Assert
        expect(response.status).toBe(400);
        const data = await response.json();
        expect(data).toHaveProperty('error', 'L'ID du résultat de simulation est requis');
    });

    it('doit rejeter si l'utilisateur n'est pas trouvé', async () => {
        // Arrange
        const mockRequest = createMockRequest({
            simulationResultId: 'sim-result-123'
        });

        // Simuler une session authentifiée
        (getServerSession as jest.Mock).mockResolvedValue({
            user: { email: 'test@example.com' }
        });

        // Simuler que l'utilisateur n'est pas trouvé
        const prisma = require('@prisma/client').PrismaClient();
        prisma.user.findUnique.mockResolvedValue(null);

        // Act
        const response = await POST(mockRequest);

        // Assert
        expect(response.status).toBe(404);
        const data = await response.json();
        expect(data).toHaveProperty('error', 'Utilisateur non trouvé');
    });

    it('doit vérifier les droits de l'utilisateur avant d'appliquer la simulation', async () => {
        // Cette fonction est un peu complexe à tester car elle dépend de checkUserRightsForSimulationApply
        // qui est une fonction interne du module. Pour un test complet, il faudrait extraire cette fonction
        // dans un module séparé pour pouvoir la mocker facilement.
        // Pour cette raison, ce test est partiel.

        // Arrange
        const mockRequest = createMockRequest({
            simulationResultId: 'sim-result-123'
        });

        // Simuler une session authentifiée
        (getServerSession as jest.Mock).mockResolvedValue({
            user: { email: 'test@example.com' }
        });

        // Simuler que l'utilisateur est trouvé
        const prisma = require('@prisma/client').PrismaClient();
        prisma.user.findUnique.mockResolvedValue({
            id: 1,
            email: 'test@example.com',
            // Ajouter d'autres propriétés si nécessaire pour checkUserRightsForSimulationApply
            isAdmin: false,
            role: 'USER'
        });

        // Mock une réponse pour le service
        (applySimulationService.applySimulationToPlanning as jest.Mock).mockResolvedValue({
            success: true,
            assignmentsCreated: 5,
            assignmentsUpdated: 2,
            leavesCreated: 0,
            conflicts: [],
            date: new Date().toISOString(),
            message: 'Simulation appliquée avec succès'
        });

        // Act
        const response = await POST(mockRequest);

        // Assert
        // Nous ne pouvons pas facilement tester le code 403 à cause de la fonction interne
        // Mais nous pouvons vérifier que le service est appelé si les droits sont corrects
        // (ce qui est le cas par défaut dans notre implémentation actuelle)
        expect(applySimulationService.applySimulationToPlanning).toHaveBeenCalled();
    });

    it('doit retourner une erreur si le service échoue', async () => {
        // Arrange
        const mockRequest = createMockRequest({
            simulationResultId: 'sim-result-123'
        });

        // Simuler une session authentifiée
        (getServerSession as jest.Mock).mockResolvedValue({
            user: { email: 'test@example.com' }
        });

        // Simuler que l'utilisateur est trouvé
        const prisma = require('@prisma/client').PrismaClient();
        prisma.user.findUnique.mockResolvedValue({
            id: 1,
            email: 'test@example.com',
            isAdmin: true
        });

        // Mock une réponse d'échec pour le service
        (applySimulationService.applySimulationToPlanning as jest.Mock).mockResolvedValue({
            success: false,
            assignmentsCreated: 0,
            assignmentsUpdated: 0,
            leavesCreated: 0,
            conflicts: [{ type: 'ERROR', message: 'Erreur pendant l'application' }],
            date: new Date().toISOString(),
            error: 'Erreur pendant l'application'
        });

        // Act
        const response = await POST(mockRequest);

        // Assert
        expect(response.status).toBe(500);
        const data = await response.json();
        expect(data).toHaveProperty('success', false);
        expect(data).toHaveProperty('error', 'Erreur pendant l'application');
    });

    it('doit retourner un succès si le service réussit', async () => {
        // Arrange
        const mockRequest = createMockRequest({
            simulationResultId: 'sim-result-123',
            clearExistingAssignments: true,
            includeLeaves: false
        });

        // Simuler une session authentifiée
        (getServerSession as jest.Mock).mockResolvedValue({
            user: { email: 'test@example.com' }
        });

        // Simuler que l'utilisateur est trouvé
        const prisma = require('@prisma/client').PrismaClient();
        prisma.user.findUnique.mockResolvedValue({
            id: 1,
            email: 'test@example.com',
            isAdmin: true
        });

        // Mock une réponse de succès pour le service
        (applySimulationService.applySimulationToPlanning as jest.Mock).mockResolvedValue({
            success: true,
            assignmentsCreated: 10,
            assignmentsUpdated: 5,
            leavesCreated: 0,
            conflicts: [],
            date: new Date().toISOString(),
            message: 'Simulation appliquée avec succès'
        });

        // Act
        const response = await POST(mockRequest);

        // Assert
        expect(response.status).toBe(200);
        const data = await response.json();
        expect(data).toHaveProperty('success', true);
        expect(data).toHaveProperty('message', 'Simulation appliquée avec succès');
        expect(data.data).toHaveProperty('assignmentsCreated', 10);
        expect(data.data).toHaveProperty('assignmentsUpdated', 5);
    });
}); 