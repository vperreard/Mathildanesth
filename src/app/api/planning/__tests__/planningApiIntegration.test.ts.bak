import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { NextRequest } from 'next/server';
import { createMocks } from 'node-mocks-http';

// Mock des modules externes
jest.mock('@/lib/prisma', () => ({
  prisma: {
    attribution: {
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      createMany: jest.fn(),
      count: jest.fn()
    },
    user: {
      findMany: jest.fn(),
      findUnique: jest.fn()
    },
    planning: {
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn()
    },
    $transaction: jest.fn()
  }
}));

jest.mock('@/lib/auth', () => ({
  getServerSession: jest.fn(),
  authOptions: {}
}));

jest.mock('@/services/planningService', () => ({
  PlanningService: {
    saveAssignments: jest.fn(),
    validateAssignments: jest.fn(),
    getAssignments: jest.fn()
  }
}));

jest.mock('@/services/planningGenerator', () => ({
  PlanningGenerator: jest.fn().mockImplementation(() => ({
    initialize: jest.fn().mockResolvedValue(undefined),
    generate: jest.fn().mockResolvedValue({
      attributions: [],
      validation: { valid: true, violations: [], metrics: { equiteScore: 0.8 } },
      metrics: { totalAssignments: 0, coveragePercentage: 90, equityScore: 0.8, conflictsDetected: 0 }
    })
  }))
}));

// Mock WebSocket pour les notifications temps réel
const mockWebSocketSend = jest.fn();
jest.mock('@/lib/websocket', () => ({
  WebSocketService: {
    broadcast: jest.fn(),
    sendToUser: mockWebSocketSend,
    notifyPlanningUpdate: jest.fn()
  }
}));

describe('Planning API Integration Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  const mockSession = {
    user: {
      id: '1',
      role: 'ADMIN',
      email: 'admin@hospital.fr',
      sites: [1]
    }
  };

  const mockUser = {
    id: 1,
    nom: 'Admin',
    prenom: 'Test',
    email: 'admin@hospital.fr',
    role: 'ADMIN',
    active: true,
    sites: [1]
  };

  const mockPersonnel = [
    {
      id: 1,
      nom: 'Martin',
      prenom: 'Jean',
      email: 'j.martin@hospital.fr',
      role: 'MAR',
      specialite: 'Anesthésie Générale',
      active: true,
      sites: [1],
      competences: ['BLOC_GENERAL'],
      weeklyHours: 35
    },
    {
      id: 2,
      nom: 'Dubois',
      prenom: 'Marie',
      email: 'm.dubois@hospital.fr',
      role: 'IADE',
      specialite: 'Anesthésie Pédiatrique',
      active: true,
      sites: [1],
      competences: ['PEDIATRIE', 'SUPERVISION_MAR'],
      weeklyHours: 35
    }
  ];

  const mockAttributions = [
    {
      id: 'attr-1',
      userId: '1',
      type: 'GARDE',
      startDate: new Date('2025-01-15T08:00:00'),
      endDate: new Date('2025-01-16T08:00:00'),
      site: 'Bloc Principal',
      status: 'VALIDATED'
    },
    {
      id: 'attr-2',
      userId: '2',
      type: 'ASTREINTE',
      startDate: new Date('2025-01-15T18:00:00'),
      endDate: new Date('2025-01-16T08:00:00'),
      site: 'Bloc Principal',
      status: 'PENDING'
    }
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();

    // Mock auth par défaut
    const { getServerSession } = require('@/lib/auth');
    getServerSession.mockResolvedValue(mockSession);

    // Mock Prisma par défaut
    const { prisma } = require('@/lib/prisma');
    prisma.user.findUnique.mockResolvedValue(mockUser);
    prisma.user.findMany.mockResolvedValue(mockPersonnel);
    prisma.attribution.findMany.mockResolvedValue(mockAttributions);
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('GET /api/planning/gardes-vacations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should retrieve planning assignments for date range', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        url: '/api/planning/gardes-vacations?start=2025-01-15&end=2025-01-15',
        query: {
          start: '2025-01-15',
          end: '2025-01-15'
        }
      });

      const { prisma } = require('@/lib/prisma');
      prisma.attribution.findMany.mockResolvedValue(mockAttributions);

      // Simulate API call
      const response = await fetch('http://localhost:3000/api/planning/gardes-vacations', {
        method: 'GET'
      });

      expect(prisma.attribution.findMany).toHaveBeenCalledWith({
        where: {
          startDate: {
            gte: expect.any(Date),
            lte: expect.any(Date)
          }
        },
        include: {
          user: {
            select: {
              id: true,
              nom: true,
              prenom: true,
              role: true,
              specialite: true
            }
          }
        },
        orderBy: {
          startDate: 'asc'
        }
      });
    });

    it('should filter by user role when specified', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        url: '/api/planning/gardes-vacations?start=2025-01-15&end=2025-01-15&role=MAR',
        query: {
          start: '2025-01-15',
          end: '2025-01-15',
          role: 'MAR'
        }
      });

      const { prisma } = require('@/lib/prisma');
      const marAttributions = mockAttributions.filter(attr => attr.userId === '1');
      prisma.attribution.findMany.mockResolvedValue(marAttributions);

      expect(prisma.attribution.findMany).toHaveBeenCalledWith({
        where: {
          startDate: {
            gte: expect.any(Date),
            lte: expect.any(Date)
          },
          user: {
            role: 'MAR'
          }
        },
        include: {
          user: {
            select: {
              id: true,
              nom: true,
              prenom: true,
              role: true,
              specialite: true
            }
          }
        },
        orderBy: {
          startDate: 'asc'
        }
      });
    });

    it('should handle site-specific filtering', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        url: '/api/planning/gardes-vacations?start=2025-01-15&end=2025-01-15&site=1',
        query: {
          start: '2025-01-15',
          end: '2025-01-15',
          site: '1'
        }
      });

      const { prisma } = require('@/lib/prisma');
      prisma.attribution.findMany.mockResolvedValue(mockAttributions);

      expect(prisma.attribution.findMany).toHaveBeenCalledWith({
        where: {
          startDate: {
            gte: expect.any(Date),
            lte: expect.any(Date)
          },
          user: {
            sites: {
              hasSome: [1]
            }
          }
        },
        include: {
          user: {
            select: {
              id: true,
              nom: true,
              prenom: true,
              role: true,
              specialite: true
            }
          }
        },
        orderBy: {
          startDate: 'asc'
        }
      });
    });
  });

  describe('POST /api/planning/gardes-vacations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should create new planning assignments', async () => {
      const newAttributions = [
        {
          userId: '1',
          type: 'GARDE',
          startDate: new Date('2025-01-20T08:00:00'),
          endDate: new Date('2025-01-21T08:00:00'),
          site: 'Bloc Principal'
        }
      ];

      const { req, res } = createMocks({
        method: 'POST',
        url: '/api/planning/gardes-vacations',
        body: {
          attributions: newAttributions
        }
      });

      const { prisma } = require('@/lib/prisma');
      const { PlanningService } = require('@/services/planningService');

      // Mock successful validation and creation
      PlanningService.validateAssignments.mockResolvedValue([]);
      prisma.attribution.createMany.mockResolvedValue({ count: 1 });

      const createdAttribution = {
        id: 'new-attr-1',
        ...newAttributions[0],
        status: 'PENDING',
        createdAt: new Date(),
        updatedAt: new Date()
      };
      prisma.attribution.findMany.mockResolvedValue([createdAttribution]);

      // Simulate API call
      expect(PlanningService.validateAssignments).toHaveBeenCalledWith(newAttributions);
      expect(prisma.attribution.createMany).toHaveBeenCalledWith({
        data: expect.arrayContaining([
          expect.objectContaining({
            userId: 1,
            type: 'GARDE',
            status: 'PENDING'
          })
        ])
      });
    });

    it('should reject invalid assignments', async () => {
      const invalidAttributions = [
        {
          userId: '1',
          type: 'GARDE',
          startDate: new Date('2025-01-20T08:00:00'),
          endDate: new Date('2025-01-21T08:00:00'),
          site: 'Bloc Principal'
        }
      ];

      const validationViolations = [
        {
          ruleId: 'INSUFFICIENT_REST_TIME',
          severity: 'ERROR',
          message: 'Temps de repos insuffisant entre deux gardes',
          assignmentId: 'temp-id',
          userId: '1'
        }
      ];

      const { PlanningService } = require('@/services/planningService');
      PlanningService.validateAssignments.mockResolvedValue(validationViolations);

      const { req, res } = createMocks({
        method: 'POST',
        url: '/api/planning/gardes-vacations',
        body: {
          attributions: invalidAttributions
        }
      });

      // Simulation would reject with validation errors
      expect(PlanningService.validateAssignments).toHaveBeenCalledWith(invalidAttributions);
    });

    it('should send real-time notifications on creation', async () => {
      const newAttributions = [
        {
          userId: '1',
          type: 'GARDE',
          startDate: new Date('2025-01-20T08:00:00'),
          endDate: new Date('2025-01-21T08:00:00'),
          site: 'Bloc Principal'
        }
      ];

      const { prisma } = require('@/lib/prisma');
      const { PlanningService } = require('@/services/planningService');
      const { WebSocketService } = require('@/lib/websocket');

      PlanningService.validateAssignments.mockResolvedValue([]);
      prisma.attribution.createMany.mockResolvedValue({ count: 1 });

      // Simulate successful creation
      expect(WebSocketService.notifyPlanningUpdate).toHaveBeenCalledWith({
        type: 'PLANNING_CREATED',
        data: {
          attributions: expect.any(Array),
          createdBy: mockSession.user.id,
          timestamp: expect.any(Date)
        }
      });
    });
  });

  describe('PUT /api/planning/gardes-vacations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should update existing assignments', async () => {
      const updatedAttributions = [
        {
          id: 'attr-1',
          userId: '1',
          type: 'GARDE',
          startDate: new Date('2025-01-15T09:00:00'), // Changed time
          endDate: new Date('2025-01-16T09:00:00'),
          site: 'Bloc Principal',
          status: 'VALIDATED'
        }
      ];

      const { req, res } = createMocks({
        method: 'PUT',
        url: '/api/planning/gardes-vacations',
        body: {
          attributions: updatedAttributions
        }
      });

      const { prisma } = require('@/lib/prisma');
      const { PlanningService } = require('@/services/planningService');

      PlanningService.validateAssignments.mockResolvedValue([]);
      prisma.$transaction.mockImplementation(async (operations) => {
        return await Promise.all(operations);
      });

      expect(prisma.$transaction).toHaveBeenCalled();
    });

    it('should handle bulk assignment updates efficiently', async () => {
      const bulkUpdates = Array.from({ length: 50 }, (_, i) => ({
        id: `attr-${i}`,
        userId: String((i % 2) + 1),
        type: i % 2 === 0 ? 'GARDE' : 'ASTREINTE',
        startDate: new Date(`2025-01-${i + 1 <= 31 ? i + 1 : 31}T08:00:00`),
        endDate: new Date(`2025-01-${i + 1 <= 31 ? i + 1 : 31}T20:00:00`),
        site: 'Bloc Principal',
        status: 'VALIDATED'
      }));

      const { prisma } = require('@/lib/prisma');
      const { PlanningService } = require('@/services/planningService');

      PlanningService.validateAssignments.mockResolvedValue([]);
      prisma.$transaction.mockImplementation(async (operations) => {
        // Simulate efficient batch processing
        expect(operations.length).toBeLessThanOrEqual(10); // Batched operations
        return operations;
      });

      // Simulate bulk update
      expect(prisma.$transaction).toHaveBeenCalled();
    });
  });

  describe('DELETE /api/planning/gardes-vacations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should delete assignments by ID', async () => {
      const assignmentIds = ['attr-1', 'attr-2'];

      const { req, res } = createMocks({
        method: 'DELETE',
        url: '/api/planning/gardes-vacations',
        body: {
          ids: assignmentIds
        }
      });

      const { prisma } = require('@/lib/prisma');
      prisma.attribution.delete.mockResolvedValue({ count: 2 });

      expect(prisma.attribution.delete).toHaveBeenCalledWith({
        where: {
          id: {
            in: assignmentIds
          }
        }
      });
    });

    it('should prevent deletion of validated assignments without permission', async () => {
      const protectedAssignmentIds = ['validated-attr-1'];

      const sessionWithoutPermission = {
        ...mockSession,
        user: {
          ...mockSession.user,
          role: 'USER' // Not admin
        }
      };

      const { getServerSession } = require('@/lib/auth');
      getServerSession.mockResolvedValue(sessionWithoutPermission);

      const { req, res } = createMocks({
        method: 'DELETE',
        url: '/api/planning/gardes-vacations',
        body: {
          ids: protectedAssignmentIds
        }
      });

      // Should throw authorization error
      expect(() => {
        // Simulate authorization check
        if (sessionWithoutPermission.user.role !== 'ADMIN') {
          throw new Error('Insufficient permissions to delete validated assignments');
        }
      }).toThrow('Insufficient permissions');
    });
  });

  describe('POST /api/planning/generate', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should generate planning with medical parameters', async () => {
      const generationParameters = {
        dateDebut: '2025-02-01',
        dateFin: '2025-02-28',
        etapesActives: ['GARDE', 'ASTREINTE'],
        niveauOptimisation: 'medical',
        appliquerPreferencesPersonnelles: true,
        poidsEquite: 0.4,
        poidsPreference: 0.3,
        poidsQualiteVie: 0.3
      };

      const { req, res } = createMocks({
        method: 'POST',
        url: '/api/planning/generate',
        body: generationParameters
      });

      const { PlanningGenerator } = require('@/services/planningGenerator');
      const mockGenerator = new PlanningGenerator();

      const generatedResult = {
        attributions: [
          {
            id: 'generated-1',
            userId: '1',
            type: 'GARDE',
            startDate: new Date('2025-02-01T08:00:00'),
            endDate: new Date('2025-02-02T08:00:00'),
            status: 'PENDING'
          }
        ],
        validation: {
          valid: true,
          violations: [],
          metrics: { equiteScore: 0.85, fatigueScore: 0.3 }
        },
        metrics: {
          totalAssignments: 1,
          coveragePercentage: 95,
          equityScore: 0.85,
          conflictsDetected: 0
        }
      };

      mockGenerator.generate.mockResolvedValue(generatedResult);

      expect(mockGenerator.initialize).toHaveBeenCalledWith(
        mockPersonnel,
        expect.any(Array)
      );
      expect(mockGenerator.generate).toHaveBeenCalled();
    });

    it('should handle generation with medical constraints', async () => {
      const medicalParameters = {
        dateDebut: '2025-02-01',
        dateFin: '2025-02-28',
        etapesActives: ['GARDE', 'ASTREINTE'],
        constraintesMedicales: {
          tempsReposMinimum: 12,
          maxGardesConsecutives: 2,
          supervisionMAR: true,
          limitesSpecialite: true
        }
      };

      const { PlanningGenerator } = require('@/services/planningGenerator');
      const mockGenerator = new PlanningGenerator();

      const constrainedResult = {
        attributions: [],
        validation: {
          valid: false,
          violations: [
            {
              ruleId: 'SUPERVISION_REQUIRED',
              severity: 'ERROR',
              message: 'Supervision IADE requise pour MAR',
              userId: '1'
            }
          ],
          metrics: { equiteScore: 0.5 }
        },
        metrics: {
          totalAssignments: 0,
          coveragePercentage: 60,
          equityScore: 0.5,
          conflictsDetected: 1
        }
      };

      mockGenerator.generate.mockResolvedValue(constrainedResult);

      // Should handle constraints and return appropriate warnings
      expect(constrainedResult.validation.violations.length).toBeGreaterThan(0);
      expect(constrainedResult.validation.violations[0].ruleId).toBe('SUPERVISION_REQUIRED');
    });
  });

  describe('WebSocket Real-time Updates', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should broadcast planning changes to connected users', async () => {
      const { WebSocketService } = require('@/lib/websocket');

      const planningUpdate = {
        type: 'PLANNING_UPDATED',
        data: {
          attributions: mockAttributions,
          updatedBy: mockSession.user.id,
          timestamp: new Date(),
          affectedUsers: ['1', '2']
        }
      };

      WebSocketService.broadcast.mockImplementation((message) => {
        expect(message.type).toBe('PLANNING_UPDATED');
        expect(message.data.affectedUsers).toContain('1');
        expect(message.data.affectedUsers).toContain('2');
      });

      WebSocketService.broadcast(planningUpdate);

      expect(WebSocketService.broadcast).toHaveBeenCalledWith(planningUpdate);
    });

    it('should notify specific users of their assignment changes', async () => {
      const { WebSocketService } = require('@/lib/websocket');

      const userSpecificUpdate = {
        type: 'ASSIGNMENT_CHANGED',
        data: {
          userId: '1',
          assignment: mockAttributions[0],
          changeType: 'UPDATED',
          timestamp: new Date()
        }
      };

      WebSocketService.sendToUser.mockImplementation((userId, message) => {
        expect(userId).toBe('1');
        expect(message.type).toBe('ASSIGNMENT_CHANGED');
        expect(message.data.assignment.id).toBe('attr-1');
      });

      WebSocketService.sendToUser('1', userSpecificUpdate);

      expect(mockWebSocketSend).toHaveBeenCalledWith('1', userSpecificUpdate);
    });

    it('should handle WebSocket connection failures gracefully', async () => {
      const { WebSocketService } = require('@/lib/websocket');

      // Simulate connection failure
      WebSocketService.broadcast.mockImplementation(() => {
        throw new Error('WebSocket connection failed');
      });

      const planningUpdate = {
        type: 'PLANNING_UPDATED',
        data: { test: 'data' }
      };

      // Should not throw error, should handle gracefully
      expect(() => {
        try {
          WebSocketService.broadcast(planningUpdate);
        } catch (error) {
          // Log error but continue operation
          console.error('WebSocket notification failed:', error.message);
        }
      }).not.toThrow();
    });
  });

  describe('Performance and Scaling', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle large dataset queries efficiently', async () => {
      const largeDataset = Array.from({ length: 1000 }, (_, i) => ({
        id: `large-attr-${i}`,
        userId: String((i % 10) + 1),
        type: i % 3 === 0 ? 'GARDE' : i % 3 === 1 ? 'ASTREINTE' : 'CONSULTATION',
        startDate: new Date(`2025-01-${(i % 31) + 1}T08:00:00`),
        endDate: new Date(`2025-01-${(i % 31) + 1}T20:00:00`),
        status: 'VALIDATED'
      }));

      const { prisma } = require('@/lib/prisma');

      // Mock efficient pagination
      prisma.attribution.findMany.mockImplementation(({ skip, take }) => {
        const start = skip || 0;
        const limit = take || 50;
        return Promise.resolve(largeDataset.slice(start, start + limit));
      });

      prisma.attribution.count.mockResolvedValue(largeDataset.length);

      const { req, res } = createMocks({
        method: 'GET',
        url: '/api/planning/gardes-vacations?start=2025-01-01&end=2025-01-31&page=1&limit=50',
        query: {
          start: '2025-01-01',
          end: '2025-01-31',
          page: '1',
          limit: '50'
        }
      });

      expect(prisma.attribution.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          skip: 0,
          take: 50
        })
      );
    });

    it('should implement caching for frequently accessed data', async () => {
      const cacheKey = 'planning_2025-01-15_2025-01-15';
      const cachedData = mockAttributions;

      // Mock Redis cache
      const mockCache = {
        get: jest.fn().mockResolvedValue(JSON.stringify(cachedData)),
        set: jest.fn().mockResolvedValue(true),
        del: jest.fn().mockResolvedValue(true)
      };

      // Simulate cache hit
      const cacheResult = await mockCache.get(cacheKey);
      expect(cacheResult).toBeDefined();
      expect(JSON.parse(cacheResult)).toEqual(cachedData);

      // Simulate cache invalidation on update
      await mockCache.del(cacheKey);
      expect(mockCache.del).toHaveBeenCalledWith(cacheKey);
    });

    it('should rate limit API requests', async () => {
      const rateLimitStore = new Map();
      const maxRequests = 100; // per minute
      const windowMs = 60 * 1000; // 1 minute

      const checkRateLimit = (ip: string) => {
        const now = Date.now();
        const windowStart = now - windowMs;

        if (!rateLimitStore.has(ip)) {
          rateLimitStore.set(ip, []);
        }

        const requests = rateLimitStore.get(ip);
        const recentRequests = requests.filter((time: number) => time > windowStart);

        if (recentRequests.length >= maxRequests) {
          throw new Error('Rate limit exceeded');
        }

        recentRequests.push(now);
        rateLimitStore.set(ip, recentRequests);
      };

      const testIp = '192.168.1.1';

      // Should allow normal usage
      for (let i = 0; i < 50; i++) {
        expect(() => checkRateLimit(testIp)).not.toThrow();
      }

      // Should block excessive requests
      for (let i = 0; i < 60; i++) {
        checkRateLimit(testIp);
      }

      expect(() => checkRateLimit(testIp)).toThrow('Rate limit exceeded');
    });
  });

  describe('Error Handling and Recovery', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle database connection failures', async () => {
      const { prisma } = require('@/lib/prisma');

      // Simulate database connection error
      prisma.attribution.findMany.mockRejectedValue(new Error('Database connection failed'));

      const { req, res } = createMocks({
        method: 'GET',
        url: '/api/planning/gardes-vacations?start=2025-01-15&end=2025-01-15'
      });

      // Should handle gracefully and return appropriate error
      try {
        await prisma.attribution.findMany();
      } catch (error) {
        expect(error.message).toBe('Database connection failed');
        // Should log error and return 500 status
      }
    });

    it('should implement transaction rollback on partial failures', async () => {
      const { prisma } = require('@/lib/prisma');

      const bulkOperations = [
        { operation: 'create', data: { userId: 1, type: 'GARDE' } },
        { operation: 'update', id: 'attr-1', data: { status: 'VALIDATED' } },
        { operation: 'delete', id: 'attr-2' }
      ];

      // Simulate partial failure (second operation fails)
      prisma.$transaction.mockImplementation(async (operations) => {
        // First operation succeeds
        await operations[0]();

        // Second operation fails
        throw new Error('Update operation failed');

        // Third operation never executes due to rollback
      });

      try {
        await prisma.$transaction(bulkOperations.map(() => jest.fn()));
      } catch (error) {
        expect(error.message).toBe('Update operation failed');
        // All operations should be rolled back
      }
    });

    it('should validate request data thoroughly', async () => {
      const invalidRequest = {
        attributions: [
          {
            // Missing required fields
            userId: null,
            type: 'INVALID_TYPE',
            startDate: 'invalid-date',
            endDate: new Date('2025-01-01'), // End before start
          }
        ]
      };

      const validateRequestData = (data: any) => {
        const errors = [];

        if (!data.attributions || !Array.isArray(data.attributions)) {
          errors.push('attributions must be an array');
        }

        data.attributions.forEach((attr: any, index: number) => {
          if (!attr.userId) {
            errors.push(`attributions[${index}].userId is required`);
          }

          if (!['GARDE', 'ASTREINTE', 'CONSULTATION', 'BLOC'].includes(attr.type)) {
            errors.push(`attributions[${index}].type is invalid`);
          }

          if (isNaN(Date.parse(attr.startDate))) {
            errors.push(`attributions[${index}].startDate is invalid`);
          }

          if (new Date(attr.endDate) <= new Date(attr.startDate)) {
            errors.push(`attributions[${index}].endDate must be after startDate`);
          }
        });

        return errors;
      };

      const validationErrors = validateRequestData(invalidRequest);

      expect(validationErrors.length).toBeGreaterThan(0);
      expect(validationErrors).toContain('attributions[0].userId is required');
      expect(validationErrors).toContain('attributions[0].type is invalid');
      expect(validationErrors).toContain('attributions[0].startDate is invalid');
      expect(validationErrors).toContain('attributions[0].endDate must be after startDate');
    });
  });
});