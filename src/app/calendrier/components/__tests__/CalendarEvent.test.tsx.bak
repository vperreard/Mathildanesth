import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import { CalendarEvent, EventType } from '../CalendarEvent';

describe('CalendarEvent', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

    // Ã‰vÃ©nement de test de base
    const baseEvent = {
        id: '1',
        title: 'RÃ©union d'Ã©quipe',
        start: '2023-01-15T10:00:00',
        end: '2023-01-15T11:00:00',
        description: 'Discussion des objectifs hebdomadaires',
        extendedProps: {
            type: EventType.MEETING
        }
    };

    const mockProps = {
        event: baseEvent,
        onClick: jest.fn()
    };

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    test('affiche correctement le titre et les horaires de l'Ã©vÃ©nement', () => {
        render(<CalendarEvent {...mockProps} />);

        // VÃ©rifier que le titre est affichÃ©
        expect(screen.getByText('RÃ©union d'Ã©quipe')).toBeInTheDocument();

        // VÃ©rifier que les horaires sont affichÃ©s
        expect(screen.getByText(/15\/01\/2023 10:00 - 15\/01\/2023 11:00/)).toBeInTheDocument();
    });

    test('affiche la description si elle est fournie', () => {
        render(<CalendarEvent {...mockProps} />);

        expect(screen.getByText('Discussion des objectifs hebdomadaires')).toBeInTheDocument();
    });

    test('n'affiche pas la description si elle n'est pas fournie', () => {
        const eventWithoutDescription = {
            ...baseEvent,
            description: undefined
        };

        render(<CalendarEvent event={eventWithoutDescription} />);

        expect(screen.queryByText('Discussion des objectifs hebdomadaires')).not.toBeInTheDocument();
    });

    test('appelle onClick quand l'Ã©vÃ©nement est cliquÃ©', () => {
        render(<CalendarEvent {...mockProps} />);

        const eventElement = screen.getByText('RÃ©union d'Ã©quipe');
        const eventContainer = eventElement.closest('.calendar-event');

        if (eventContainer) {
            fireEvent.click(eventContainer);
        }

        expect(mockProps.onClick).toHaveBeenCalledTimes(1);
        expect(mockProps.onClick).toHaveBeenCalledWith(baseEvent);
    });

    test('applique les couleurs fournies dans l'Ã©vÃ©nement', () => {
        const coloredEvent = {
            ...baseEvent,
            backgroundColor: '#ff0000',
            borderColor: '#cc0000',
            textColor: '#ffffff'
        };

        render(<CalendarEvent event={coloredEvent} />);

        const eventContainer = screen.getByText('RÃ©union d'Ã©quipe').closest('.calendar-event');

        expect(eventContainer).toHaveStyle({
            backgroundColor: '#ff0000',
            borderLeft: '4px solid #cc0000',
            color: '#ffffff'
        });
    });

    test('utilise les couleurs par dÃ©faut basÃ©es sur le type d'Ã©vÃ©nement', () => {
        // Ã‰vÃ©nement sans couleurs spÃ©cifiÃ©es
        render(<CalendarEvent {...mockProps} />);

        const eventContainer = screen.getByText('RÃ©union d'Ã©quipe').closest('.calendar-event');

        // Les couleurs par dÃ©faut pour le type MEETING doivent Ãªtre appliquÃ©es
        expect(eventContainer).toHaveStyle({
            borderLeft: expect.stringContaining('#ed64a6') // couleur de bordure par dÃ©faut pour MEETING
        });
    });

    test('affiche un statut si fourni', () => {
        const eventWithStatus = {
            ...baseEvent,
            extendedProps: {
                ...baseEvent.extendedProps,
                status: 'APPROVED'
            }
        };

        render(<CalendarEvent event={eventWithStatus} />);

        expect(screen.getByText('ApprouvÃ©')).toBeInTheDocument();
    });

    test('n'affiche pas de statut s'il n'est pas fourni', () => {
        render(<CalendarEvent {...mockProps} />);

        expect(screen.queryByText('ApprouvÃ©')).not.toBeInTheDocument();
        expect(screen.queryByText('RefusÃ©')).not.toBeInTheDocument();
        expect(screen.queryByText('En attente')).not.toBeInTheDocument();
    });

    test('rend un mode compact quand isCompact est true', () => {
        render(<CalendarEvent {...mockProps} isCompact={true} />);

        const eventContainer = screen.getByText('RÃ©union d'Ã©quipe').closest('.calendar-event');

        // VÃ©rifier que la classe pour le mode compact est appliquÃ©e
        expect(eventContainer).toHaveClass('p-1');
        expect(eventContainer).toHaveClass('text-xs');

        // En mode compact, la description ne devrait pas Ãªtre affichÃ©e
        expect(screen.queryByText('Discussion des objectifs hebdomadaires')).not.toBeInTheDocument();
    });

    test('utilise des styles diffÃ©rents pour les Ã©vÃ©nements toute la journÃ©e', () => {
        const allDayEvent = {
            ...baseEvent,
            start: '2023-01-15',
            end: '2023-01-15',
            allDay: true
        };

        render(<CalendarEvent event={allDayEvent} />);

        // VÃ©rifier le format spÃ©cial pour les Ã©vÃ©nements toute la journÃ©e
        expect(screen.getByText(/Toute la journÃ©e: 15\/01\/2023/)).toBeInTheDocument();
    });

    test('n'affiche pas les horaires quand showTime est false', () => {
        render(<CalendarEvent {...mockProps} showTime={false} />);

        // Les horaires ne devraient pas Ãªtre affichÃ©s
        expect(screen.queryByText(/15\/01\/2023 10:00 - 15\/01\/2023 11:00/)).not.toBeInTheDocument();
    });

    test('affiche l'icÃ´ne correspondant au type d'Ã©vÃ©nement', () => {
        const { rerender } = render(<CalendarEvent {...mockProps} />);

        // Pour le type MEETING, on devrait voir l'icÃ´ne ğŸ‘¥
        const eventTitle = screen.getByText('RÃ©union d'Ã©quipe');
        const titleContainer = eventTitle.closest('.flex');
        expect(titleContainer?.textContent).toContain('ğŸ‘¥');

        // Tester avec un autre type d'Ã©vÃ©nement
        const leaveEvent = {
            ...baseEvent,
            extendedProps: {
                type: EventType.LEAVE
            }
        };

        rerender(<CalendarEvent event={leaveEvent} />);

        // Pour le type LEAVE, on devrait voir l'icÃ´ne ğŸ–ï¸
        const updatedTitleContainer = screen.getByText('RÃ©union d'Ã©quipe').closest('.flex');
        expect(updatedTitleContainer?.textContent).toContain('ğŸ–ï¸');
    });
}); 