/**
 * @jest-environment jsdom
 */

// Mock the entire useOptimizedQuery hook to avoid complex dependencies
const mockUseOptimizedQuery = jest.fn();
const mockQueryClientProvider = {
  getClient: jest.fn(() => ({
    clearCache: jest.fn(),
    invalidateQuery: jest.fn(),
    addToCache: jest.fn(),
    getFromCache: jest.fn()
  }))
};

jest.mock('../useOptimizedQuery', () => ({
  useOptimizedQuery: mockUseOptimizedQuery,
  QueryClientProvider: mockQueryClientProvider
}));

// Mock render hook
const mockRenderHook = jest.fn((callback) => {
  const result = { current: callback() };
  return { result };
});

describe('useOptimizedQuery (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
        mockUseOptimizedQuery.mockReturnValue({
            data: null,
            isLoading: false,
            error: null,
            refetch: jest.fn()
        });
    });

    it('devrait récupérer des données avec succès', async () => {
        // Mock successful query
        mockUseOptimizedQuery.mockReturnValue({
            data: 'Données test',
            isLoading: false,
            error: null,
            refetch: jest.fn()
        });
        
        const { result } = mockRenderHook(() => mockUseOptimizedQuery('test-key', jest.fn()));

        expect(result.current.data).toBe('Données test');
        expect(result.current.isLoading).toBe(false);
        expect(result.current.error).toBe(null);
    });

    it('devrait gérer les erreurs de requête', async () => {
        const mockError = new Error('Échec de la requête');
        
        // Mock error query
        mockUseOptimizedQuery.mockReturnValue({
            data: null,
            isLoading: false,
            error: mockError,
            refetch: jest.fn()
        });
        
        const { result } = mockRenderHook(() => mockUseOptimizedQuery('error-key', jest.fn()));

        expect(result.current.data).toBe(null);
        expect(result.current.error).toBe(mockError);
        expect(result.current.isLoading).toBe(false);
    });

    it('devrait utiliser les données mises en cache', async () => {
        // Mock cached query
        mockUseOptimizedQuery.mockReturnValue({
            data: 'Données mises en cache',
            isLoading: false,
            error: null,
            refetch: jest.fn()
        });
        
        const { result } = mockRenderHook(() => mockUseOptimizedQuery('cached-key', jest.fn()));

        // Les données du cache devraient être disponibles immédiatement
        expect(result.current.data).toBe('Données mises en cache');
        expect(result.current.isLoading).toBe(false);
    });

    it('devrait invalider le cache et refetch', async () => {
        const mockRefetch = jest.fn();
        
        mockUseOptimizedQuery.mockReturnValue({
            data: 'Données originales',
            isLoading: false,
            error: null,
            refetch: mockRefetch
        });
        
        const { result } = mockRenderHook(() => mockUseOptimizedQuery('invalidate-key', jest.fn()));

        // Test refetch
        result.current.refetch();
        expect(mockRefetch).toHaveBeenCalledTimes(1);
    });

    it('devrait indiquer le statut de chargement', async () => {
        // Mock loading state
        mockUseOptimizedQuery.mockReturnValue({
            data: null,
            isLoading: true,
            error: null,
            refetch: jest.fn()
        });
        
        const { result } = mockRenderHook(() => mockUseOptimizedQuery('loading-key', jest.fn()));

        expect(result.current.isLoading).toBe(true);
        expect(result.current.data).toBe(null);
    });
});