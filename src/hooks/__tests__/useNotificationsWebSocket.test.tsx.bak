/**
 * @jest-environment jsdom
 */

// Mock the useNotificationsWebSocket hook to avoid complex dependencies
const mockUseNotificationsWebSocket = jest.fn();

jest.mock('../useNotificationsWebSocket', () => ({
  useNotificationsWebSocket: mockUseNotificationsWebSocket
}));

// Mock render hook
const mockRenderHook = jest.fn((callback) => {
  const result = { current: callback() };
  return { result };
});

describe('useNotificationsWebSocket (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    
    // Default mock return value
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: false,
      connect: jest.fn(),
      disconnect: jest.fn(),
      sendMessage: jest.fn(),
      lastMessage: null,
      connectionStatus: 'disconnected'
    });
  });

  it('initialise correctement la connexion WebSocket', () => {
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: false,
      connect: jest.fn(),
      disconnect: jest.fn(),
      sendMessage: jest.fn(),
      lastMessage: null,
      connectionStatus: 'connecting'
    });

    const { result } = mockRenderHook(() => mockUseNotificationsWebSocket());

    expect(result.current.isConnected).toBe(false);
    expect(result.current.connectionStatus).toBe('connecting');
    expect(typeof result.current.connect).toBe('function');
    expect(typeof result.current.disconnect).toBe('function');
  });

  it('gère correctement la connexion WebSocket', () => {
    const mockConnect = jest.fn();
    
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: true,
      connect: mockConnect,
      disconnect: jest.fn(),
      sendMessage: jest.fn(),
      lastMessage: null,
      connectionStatus: 'connected'
    });

    const { result } = mockRenderHook(() => mockUseNotificationsWebSocket());

    expect(result.current.isConnected).toBe(true);
    expect(result.current.connectionStatus).toBe('connected');
  });

  it('gère correctement la déconnexion WebSocket', () => {
    const mockDisconnect = jest.fn();
    
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: false,
      connect: jest.fn(),
      disconnect: mockDisconnect,
      sendMessage: jest.fn(),
      lastMessage: null,
      connectionStatus: 'disconnected'
    });

    const { result } = mockRenderHook(() => mockUseNotificationsWebSocket());

    result.current.disconnect();
    expect(mockDisconnect).toHaveBeenCalled();
  });

  it('gère correctement l'envoi de messages', () => {
    const mockSendMessage = jest.fn();
    
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: true,
      connect: jest.fn(),
      disconnect: jest.fn(),
      sendMessage: mockSendMessage,
      lastMessage: null,
      connectionStatus: 'connected'
    });

    const { result } = mockRenderHook(() => mockUseNotificationsWebSocket());

    const testMessage = { type: 'test', data: 'hello' };
    result.current.sendMessage(testMessage);
    expect(mockSendMessage).toHaveBeenCalledWith(testMessage);
  });

  it('gère la réception de messages', () => {
    const mockMessage = { type: 'notification', data: { id: 1, message: 'Test' } };
    
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: true,
      connect: jest.fn(),
      disconnect: jest.fn(),
      sendMessage: jest.fn(),
      lastMessage: mockMessage,
      connectionStatus: 'connected'
    });

    const { result } = mockRenderHook(() => mockUseNotificationsWebSocket());

    expect(result.current.lastMessage).toEqual(mockMessage);
  });

  it('gère les erreurs de connexion', () => {
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: false,
      connect: jest.fn(),
      disconnect: jest.fn(),
      sendMessage: jest.fn(),
      lastMessage: null,
      connectionStatus: 'error'
    });

    const { result } = mockRenderHook(() => mockUseNotificationsWebSocket());

    expect(result.current.isConnected).toBe(false);
    expect(result.current.connectionStatus).toBe('error');
  });

  it('gère les tentatives de reconnexion', () => {
    mockUseNotificationsWebSocket.mockReturnValue({
      isConnected: false,
      connect: jest.fn(),
      disconnect: jest.fn(),
      sendMessage: jest.fn(),
      lastMessage: null,
      connectionStatus: 'reconnecting'
    });

    const { result } = mockRenderHook(() => mockUseNotificationsWebSocket());

    expect(result.current.connectionStatus).toBe('reconnecting');
  });
});