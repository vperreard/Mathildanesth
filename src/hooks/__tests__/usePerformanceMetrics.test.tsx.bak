import { renderHook, act } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import { usePerformanceMetrics, useAuthPerformanceMetrics, measureExecutionTime } from '../usePerformanceMetrics';

// Mock performance APIs - simplified version
const mockPerformanceAPI = {
  getEntriesByType: jest.fn(),
  now: jest.fn(),
  memory: {
    usedJSHeapSize: 50 * 1024 * 1024, // 50MB in bytes
  },
};

// Mock navigation timing
const mockNavigationTiming = {
  fetchStart: 100,
  loadEventEnd: 1000,
  domInteractive: 800,
};

// Mock paint timing
const mockPaintTiming = [
  { name: 'first-paint', startTime: 300 },
  { name: 'first-contentful-paint', startTime: 400 },
];

Object.defineProperty(window, 'performance', {
  value: mockPerformanceAPI,
  writable: true,
});

// Mock console methods
const consoleSpy = {
  group: jest.spyOn(console, 'group').mockImplementation(),
  log: jest.spyOn(console, 'log').mockImplementation(),
  groupEnd: jest.spyOn(console, 'groupEnd').mockImplementation(),
  error: jest.spyOn(console, 'error').mockImplementation(),
};

describe('usePerformanceMetrics - Core Functionality', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    
    // Setup default mock returns
    mockPerformanceAPI.getEntriesByType.mockImplementation((type: string) => {
      if (type === 'navigation') return [mockNavigationTiming];
      if (type === 'paint') return mockPaintTiming;
      return [];
    });
    
    mockPerformanceAPI.now.mockReturnValue(1500);
    
    // Mock document.readyState as loading to avoid automatic measurement
    Object.defineProperty(document, 'readyState', {
      value: 'loading',
      writable: true,
    });
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Basic functionality', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should initialize with loading state', () => {
      const { result } = renderHook(() => usePerformanceMetrics());

      expect(result.current.metrics).toBeNull();
      expect(result.current.isLoading).toBe(true);
      expect(typeof result.current.recordMetric).toBe('function');
    });

    it('should provide recordMetric function', () => {
      const { result } = renderHook(() => usePerformanceMetrics());

      act(() => {
        result.current.recordMetric('testMetric', 123);
      });

      // Should not throw and function should be defined
      expect(result.current.recordMetric).toBeDefined();
    });

    it('should handle multiple custom metrics without errors', () => {
      const { result } = renderHook(() => usePerformanceMetrics());

      expect(() => {
        act(() => {
          result.current.recordMetric('metric1', 100);
          result.current.recordMetric('metric2', 200);
          result.current.recordMetric('metric1', 150); // Update existing
        });
      }).not.toThrow();

      expect(result.current.recordMetric).toBeDefined();
    });
  });

  describe('useAuthPerformanceMetrics', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should provide auth-specific functionality', () => {
      const { result } = renderHook(() => useAuthPerformanceMetrics());

      expect(result.current.recordAuthStep).toBeDefined();
      expect(result.current.recordMetric).toBeDefined();
      expect(result.current.metrics).toBeDefined();
      expect(result.current.isLoading).toBeDefined();
      expect(result.current.getAuthMetrics).toBeDefined();
    });

    it('should record auth steps with timestamps', () => {
      const { result } = renderHook(() => useAuthPerformanceMetrics());

      act(() => {
        result.current.recordAuthStep('login_start');
      });

      expect(mockPerformanceAPI.now).toHaveBeenCalled();
    });

    it('should handle all auth step types', () => {
      const { result } = renderHook(() => useAuthPerformanceMetrics());

      act(() => {
        result.current.recordAuthStep('login_start');
        result.current.recordAuthStep('api_call');
        result.current.recordAuthStep('redirect');
      });

      expect(mockPerformanceAPI.now).toHaveBeenCalledTimes(3);
    });

    it('should return auth metrics', () => {
      const { result } = renderHook(() => useAuthPerformanceMetrics());

      act(() => {
        result.current.recordAuthStep('test_step');
      });

      const authMetrics = result.current.getAuthMetrics();
      expect(authMetrics).toBeDefined();
      expect(typeof authMetrics).toBe('object');
    });
  });
});

describe('measureExecutionTime', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    mockPerformanceAPI.now
      .mockReturnValueOnce(1000) // Start time
      .mockReturnValueOnce(1500); // End time
  });

  it('should measure successful function execution', async () => {
    const testFunction = jest.fn().mockResolvedValue('success');

    const result = await measureExecutionTime(testFunction, 'testFunction');

    expect(result.result).toBe('success');
    expect(result.executionTime).toBe(500);
    expect(testFunction).toHaveBeenCalled();
  });

  it('should measure failed function execution', async () => {
    const testFunction = jest.fn().mockRejectedValue(new Error('Test error'));

    await expect(
      measureExecutionTime(testFunction, 'failingFunction')
    ).rejects.toThrow('Test error');

    expect(consoleSpy.error).toHaveBeenCalledWith(
      '❌ failingFunction failed after 500.00ms:',
      expect.any(Error)
    );
  });

  it('should log execution time in development', async () => {
    const originalEnv = process.env.NODE_ENV;
    process.env.NODE_ENV = 'development';

    const testFunction = jest.fn().mockResolvedValue('success');

    await measureExecutionTime(testFunction, 'testFunction');

    expect(consoleSpy.log).toHaveBeenCalledWith('⏱️ testFunction: 500.00ms');

    process.env.NODE_ENV = originalEnv;
  });

  it('should handle complex async operations', async () => {
    const complexFunction = async () => {
      await new Promise(resolve => setTimeout(resolve, 10));
      return { data: 'complex result', status: 'ok' };
    };

    const result = await measureExecutionTime(complexFunction, 'complexOp');

    expect(result.result).toEqual({ data: 'complex result', status: 'ok' });
    expect(result.executionTime).toBe(500);
  });

  it('should handle synchronous functions', async () => {
    const syncFunction = () => 'sync result';

    const result = await measureExecutionTime(async () => syncFunction(), 'syncOp');

    expect(result.result).toBe('sync result');
    expect(result.executionTime).toBe(500);
  });
});