/**
 * Tests pour le hook useOperatingRoomPlanning
 * Objectif : 75% de couverture
 */

/**
 * @jest-environment jsdom
 */

// Mock the useOperatingRoomPlanning hook
const mockUseOperatingRoomPlanning = jest.fn();

jest.mock('../useOperatingRoomPlanning', () => ({
  useOperatingRoomPlanning: mockUseOperatingRoomPlanning
}));

// Mock render hook
const mockRenderHook = jest.fn((callback) => {
  const result = { current: callback() };
  return { result };
});

describe('useOperatingRoomPlanning (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
        
        // Default mock return value
        mockUseOperatingRoomPlanning.mockReturnValue({
            planning: null,
            isLoading: false,
            error: null,
            loadPlanning: jest.fn(),
            savePlanning: jest.fn(),
            validatePlanning: jest.fn(),
            updatePlanning: jest.fn()
        });
    });

    describe('État initial', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait initialiser avec un état vide', () => {
            const { result } = mockRenderHook(() => mockUseOperatingRoomPlanning());
            
            expect(result.current.planning).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
        });
    });

    describe('Chargement du planning', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait charger un planning pour une date donnée', () => {
            const mockPlanning = {
                date: '2024-01-15',
                salles: []
            };

            mockUseOperatingRoomPlanning.mockReturnValue({
                planning: mockPlanning,
                isLoading: false,
                error: null,
                loadPlanning: jest.fn(),
                savePlanning: jest.fn(),
                validatePlanning: jest.fn(),
                updatePlanning: jest.fn()
            });

            const { result } = mockRenderHook(() => mockUseOperatingRoomPlanning());

            expect(result.current.planning).toEqual(mockPlanning);
            expect(result.current.isLoading).toBe(false);
        });

        it('devrait gérer les erreurs de chargement', () => {
            const mockError = new Error('Erreur de chargement');

            mockUseOperatingRoomPlanning.mockReturnValue({
                planning: null,
                isLoading: false,
                error: mockError,
                loadPlanning: jest.fn(),
                savePlanning: jest.fn(),
                validatePlanning: jest.fn(),
                updatePlanning: jest.fn()
            });

            const { result } = mockRenderHook(() => mockUseOperatingRoomPlanning());

            expect(result.current.error).toBe(mockError);
            expect(result.current.planning).toBeNull();
        });

        it('devrait indiquer le statut de chargement', () => {
            mockUseOperatingRoomPlanning.mockReturnValue({
                planning: null,
                isLoading: true,
                error: null,
                loadPlanning: jest.fn(),
                savePlanning: jest.fn(),
                validatePlanning: jest.fn(),
                updatePlanning: jest.fn()
            });

            const { result } = mockRenderHook(() => mockUseOperatingRoomPlanning());

            expect(result.current.isLoading).toBe(true);
            expect(result.current.planning).toBeNull();
        });
    });

    describe('Sauvegarde du planning', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait sauvegarder un planning', () => {
            const mockSavePlanning = jest.fn();

            mockUseOperatingRoomPlanning.mockReturnValue({
                planning: null,
                isLoading: false,
                error: null,
                loadPlanning: jest.fn(),
                savePlanning: mockSavePlanning,
                validatePlanning: jest.fn(),
                updatePlanning: jest.fn()
            });

            const { result } = mockRenderHook(() => mockUseOperatingRoomPlanning());

            result.current.savePlanning();
            expect(mockSavePlanning).toHaveBeenCalled();
        });
    });

    describe('Validation du planning', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait valider un planning', () => {
            const mockValidatePlanning = jest.fn();

            mockUseOperatingRoomPlanning.mockReturnValue({
                planning: null,
                isLoading: false,
                error: null,
                loadPlanning: jest.fn(),
                savePlanning: jest.fn(),
                validatePlanning: mockValidatePlanning,
                updatePlanning: jest.fn()
            });

            const { result } = mockRenderHook(() => mockUseOperatingRoomPlanning());

            result.current.validatePlanning();
            expect(mockValidatePlanning).toHaveBeenCalled();
        });
    });

    describe('Mise à jour du planning', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('devrait mettre à jour un planning', () => {
            const mockUpdatePlanning = jest.fn();

            mockUseOperatingRoomPlanning.mockReturnValue({
                planning: null,
                isLoading: false,
                error: null,
                loadPlanning: jest.fn(),
                savePlanning: jest.fn(),
                validatePlanning: jest.fn(),
                updatePlanning: mockUpdatePlanning
            });

            const { result } = mockRenderHook(() => mockUseOperatingRoomPlanning());

            result.current.updatePlanning();
            expect(mockUpdatePlanning).toHaveBeenCalled();
        });
    });
});