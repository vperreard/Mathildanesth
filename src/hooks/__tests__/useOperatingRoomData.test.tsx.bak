import React from 'react';
import { renderHook, act, waitFor } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import { useOperatingRoomData } from '../useOperatingRoomData';

// Mock the bloc planning service completely
jest.mock('@/modules/planning/bloc-operatoire/services/blocPlanningService', () => ({
  blocPlanningService: {
    getAllOperatingRooms: jest.fn().mockResolvedValue([
      {
        id: 'room1',
        numero: '101',
        secteurId: 'sector1',
        estActif: true,
        nom: 'Salle A'
      },
      {
        id: 'room2',
        numero: '102',
        secteurId: 'sector1',
        estActif: true,
        nom: 'Salle B'
      }
    ]),
    getAllSectors: jest.fn().mockResolvedValue([
      {
        id: 'sector1',
        nom: 'Secteur Chirurgie',
        code: 'CHI',
        couleur: '#007bff'
      }
    ]),
    getOperatingRoomById: jest.fn().mockImplementation((id: string) => 
      Promise.resolve({ id, numero: '101', secteurId: 'sector1', estActif: true, nom: 'Salle Test' })
    ),
    createOperatingRoom: jest.fn().mockImplementation((room: any) => 
      Promise.resolve({ ...room, id: 'new-room-id' })
    ),
    updateOperatingRoom: jest.fn().mockImplementation((id: string, data: any) => 
      Promise.resolve({ id, ...data })
    ),
    deleteOperatingRoom: jest.fn().mockResolvedValue(true),
  }
}));

describe('useOperatingRoomData - Core Functionality', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
  });

  describe('Hook Interface', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should provide expected interface', () => {
      const { result } = renderHook(() => useOperatingRoomData());
      const [state, actions] = result.current;

      // Check state properties
      expect(state).toHaveProperty('rooms');
      expect(state).toHaveProperty('sectors');
      expect(state).toHaveProperty('isLoading');
      expect(state).toHaveProperty('error');

      // Check action functions
      expect(actions).toHaveProperty('fetchRooms');
      expect(actions).toHaveProperty('fetchRoomById');
      expect(actions).toHaveProperty('createRoom');
      expect(actions).toHaveProperty('updateRoom');
      expect(actions).toHaveProperty('deleteRoom');
      expect(actions).toHaveProperty('fetchSectors');
    });

    it('should have correct function types', () => {
      const { result } = renderHook(() => useOperatingRoomData());
      const [, actions] = result.current;

      expect(typeof actions.fetchRooms).toBe('function');
      expect(typeof actions.fetchRoomById).toBe('function');
      expect(typeof actions.createRoom).toBe('function');
      expect(typeof actions.updateRoom).toBe('function');
      expect(typeof actions.deleteRoom).toBe('function');
      expect(typeof actions.fetchSectors).toBe('function');
    });
  });

  describe('Initial Data Loading', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should initialize with correct state structure', () => {
      const { result } = renderHook(() => useOperatingRoomData());
      const [state] = result.current;

      // Check initial state structure
      expect(Array.isArray(state.rooms)).toBe(true);
      expect(Array.isArray(state.sectors)).toBe(true);
      expect(typeof state.isLoading).toBe('boolean');
      expect(state.error === null || state.error instanceof Error).toBe(true);
    });

    it('should provide manual data fetching capability', async () => {
      const { result } = renderHook(() => useOperatingRoomData());

      await act(async () => {
        await result.current[1].fetchRooms();
      });

      await act(async () => {
        await result.current[1].fetchSectors();
      });

      // Manual fetching should work
      expect(result.current[0].rooms.length).toBeGreaterThan(0);
      expect(result.current[0].sectors.length).toBeGreaterThan(0);
    });
  });

  describe('Actions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle fetchRoomById action', async () => {
      const { result } = renderHook(() => useOperatingRoomData());
      
      await act(async () => {
        const room = await result.current[1].fetchRoomById('room1');
        expect(room).toBeDefined();
        expect(room?.id).toBe('room1');
      });
    });

    it('should handle createRoom action', async () => {
      const { result } = renderHook(() => useOperatingRoomData());
      
      const newRoomData = {
        numero: '103',
        secteurId: 'sector1',
        estActif: true,
        nom: 'Nouvelle Salle'
      };

      await act(async () => {
        const newRoom = await result.current[1].createRoom(newRoomData);
        expect(newRoom).toBeDefined();
        expect(newRoom.id).toBe('new-room-id');
      });
    });

    it('should handle updateRoom action', async () => {
      const { result } = renderHook(() => useOperatingRoomData());
      
      await act(async () => {
        const updatedRoom = await result.current[1].updateRoom('room1', { nom: 'Salle Modifiée' });
        expect(updatedRoom).toBeDefined();
        expect(updatedRoom?.nom).toBe('Salle Modifiée');
      });
    });

    it('should handle deleteRoom action', async () => {
      const { result } = renderHook(() => useOperatingRoomData());
      
      await act(async () => {
        const success = await result.current[1].deleteRoom('room1');
        expect(success).toBe(true);
      });
    });

    it('should handle fetchSectors action', async () => {
      const { result } = renderHook(() => useOperatingRoomData());
      
      await act(async () => {
        await result.current[1].fetchSectors();
      });

      expect(result.current[0].sectors.length).toBeGreaterThan(0);
    });
  });

  describe('Error Handling', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle hook initialization gracefully', () => {
      expect(() => {
        renderHook(() => useOperatingRoomData());
      }).not.toThrow();
    });

    it('should handle function calls gracefully', async () => {
      const { result } = renderHook(() => useOperatingRoomData());

      await expect(async () => {
        await act(async () => {
          await result.current[1].fetchRoomById('test-id');
        });
      }).not.toThrow();

      await expect(async () => {
        await act(async () => {
          await result.current[1].fetchSectors();
        });
      }).not.toThrow();
    });
  });

  describe('Cleanup', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should unmount without errors', () => {
      expect(() => {
        const { unmount } = renderHook(() => useOperatingRoomData());
        unmount();
      }).not.toThrow();
    });
  });
});