/**
 * @jest-environment jsdom
 */
import { renderHook, act, waitFor } from '@testing-library/react';
import { cleanup } from '@testing-library/react';
import { VisualTheme } from '@/types/user';

// Mock the entire hook to make tests simpler and more reliable
jest.mock('../useAppearance', () => ({
  useAppearance: jest.fn(() => ({
    loading: false,
    preferences: {
      visualTheme: 'DEFAULT',
      typography: {
        fontSize: 'medium',
        fontFamily: 'sans-serif',
        lineHeight: 'normal',
        fontWeight: 'normal',
      },
      animations: {
        enabled: true,
        speed: 'normal',
      },
      interface: {
        borderRadius: 'medium',
        density: 'normal',
        shadows: 'normal',
        transparencyEffects: true,
      },
      accessibility: {
        highContrast: false,
        reduceMotion: false,
        largeClickTargets: false,
      },
      header: {
        style: 'default',
        sticky: true,
      },
    },
    updatePreferences: jest.fn().mockResolvedValue(true),
  })),
}));

// Mock ApiService
const MockedApiService = jest.fn().mockImplementation(() => ({
  getUserPreferences: jest.fn().mockResolvedValue({}),
  saveUserPreferences: jest.fn().mockResolvedValue(true),
}));

jest.mock('@/services/api', () => ({
  ApiService: MockedApiService,
}));

const { useAppearance } = require('../useAppearance');

describe('useAppearance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

  let mockApiInstance: {
    getUserPreferences: jest.Mock;
    saveUserPreferences: jest.Mock;
  };

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    
    mockApiInstance = {
      getUserPreferences: jest.fn(),
      saveUserPreferences: jest.fn(),
    };
    
    MockedApiService.mockImplementation(() => mockApiInstance as any);
  });

  describe('Initial State', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should initialize with default preferences', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      expect(result.current.loading).toBe(true);
      expect(result.current.preferences.visualTheme).toBe(VisualTheme.DEFAULT);
      expect(result.current.preferences.typography.fontSize).toBe('medium');
      expect(result.current.preferences.animations.enabled).toBe(true);

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });
    });

    it('should initialize with provided initial preferences', async () => {
      const initialPreferences = {
        visualTheme: VisualTheme.OCEAN,
        typography: {
          fontSize: 'large' as const,
          fontFamily: 'serif' as const,
          lineHeight: 'relaxed' as const,
          fontWeight: 'bold' as const,
        },
        animations: {
          enabled: false,
          speed: 'slow' as const,
        },
        interface: {
          borderRadius: 'large' as const,
          density: 'compact' as const,
          shadows: 'prominent' as const,
          transparencyEffects: false,
        },
        accessibility: {
          highContrast: true,
          reduceMotion: true,
          largeClickTargets: true,
        },
        header: {
          style: 'flat' as const,
          sticky: false,
        },
      };

      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance({ initialPreferences }));

      expect(result.current.preferences.visualTheme).toBe(VisualTheme.OCEAN);
      expect(result.current.preferences.typography.fontSize).toBe('large');
      expect(result.current.preferences.animations.enabled).toBe(false);
    });
  });

  describe('Loading Preferences from API', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should load preferences from API successfully', async () => {
      const apiPreferences = {
        appearance: {
          visualTheme: VisualTheme.SUNSET,
          typography: {
            fontSize: 'x-large' as const,
            fontFamily: 'monospace' as const,
            lineHeight: 'compact' as const,
            fontWeight: 'medium' as const,
          },
        },
      };

      mockApiInstance.getUserPreferences.mockResolvedValue(apiPreferences);

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      expect(result.current.preferences.visualTheme).toBe(VisualTheme.SUNSET);
      expect(result.current.preferences.typography.fontSize).toBe('x-large');
      expect(result.current.preferences.typography.fontFamily).toBe('monospace');
    });

    it('should handle API loading errors gracefully', async () => {
      mockApiInstance.getUserPreferences.mockRejectedValue(new Error('API Error'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      // Should still use default preferences
      expect(result.current.preferences.visualTheme).toBe(VisualTheme.DEFAULT);
      expect(consoleSpy).toHaveBeenCalledWith('Erreur lors du chargement des préférences:', expect.any(Error));

      consoleSpy.mockRestore();
    });

    it('should handle API returning null preferences', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue(null);

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      expect(result.current.preferences.visualTheme).toBe(VisualTheme.DEFAULT);
    });
  });

  describe('Updating Preferences', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should update preferences successfully', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});
      mockApiInstance.saveUserPreferences.mockResolvedValue(true);

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      let updateResult: boolean | undefined;
      await act(async () => {
        updateResult = await result.current.updatePreferences({
          visualTheme: VisualTheme.FOREST,
        });
      });

      expect(updateResult).toBe(true);
      expect(result.current.preferences.visualTheme).toBe(VisualTheme.FOREST);
      expect(mockApiInstance.saveUserPreferences).toHaveBeenCalledWith({
        appearance: expect.objectContaining({
          visualTheme: VisualTheme.FOREST,
        }),
      });
    });

    it('should handle preference update errors', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});
      mockApiInstance.saveUserPreferences.mockRejectedValue(new Error('Save Error'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      let updateResult: boolean | undefined;
      await act(async () => {
        updateResult = await result.current.updatePreferences({
          visualTheme: VisualTheme.LAVENDER,
        });
      });

      expect(updateResult).toBe(false);
      expect(consoleSpy).toHaveBeenCalledWith('Erreur lors de la mise à jour des préférences:', expect.any(Error));

      consoleSpy.mockRestore();
    });

    it('should merge partial preferences correctly', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});
      mockApiInstance.saveUserPreferences.mockResolvedValue(true);

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          typography: {
            fontSize: 'large' as const,
            fontFamily: 'serif' as const,
            lineHeight: 'relaxed' as const,
            fontWeight: 'bold' as const,
          },
        });
      });

      expect(result.current.preferences.visualTheme).toBe(VisualTheme.DEFAULT); // Should keep default
      expect(result.current.preferences.typography.fontSize).toBe('large'); // Should update
      expect(result.current.preferences.animations.enabled).toBe(true); // Should keep default
    });
  });

  describe('Style Application', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
      // Reset mocks for each test
      mockDocumentElement.style.setProperty.mockClear();
      mockDocument.body.classList.add.mockClear();
      mockDocument.body.classList.remove.mockClear();
    });

    it('should apply visual theme styles', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          visualTheme: VisualTheme.OCEAN,
        });
      });

      // Should set CSS custom properties for ocean theme
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--primary-500', '14, 165, 233');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--secondary-500', '6, 182, 212');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--tertiary-500', '8, 145, 178');
    });

    it('should apply typography styles', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          typography: {
            fontSize: 'large' as const,
            fontFamily: 'serif' as const,
            lineHeight: 'relaxed' as const,
            fontWeight: 'bold' as const,
          },
        });
      });

      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--font-size-base', '1.125rem');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--font-family', 'Georgia, Cambria, "Times New Roman", Times, serif');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--line-height', '1.8');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--font-weight', '700');
    });

    it('should apply interface styles', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          interface: {
            borderRadius: 'large' as const,
            density: 'compact' as const,
            shadows: 'prominent' as const,
            transparencyEffects: false,
          },
        });
      });

      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--radius-md', '1rem');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--spacing-factor', '0.75');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--padding-base', '0.75rem');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--shadow-md', '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)');
      expect(mockDocument.body.classList.remove).toHaveBeenCalledWith('transparency-effects');
    });

    it('should apply accessibility styles', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          accessibility: {
            highContrast: true,
            reduceMotion: true,
            largeClickTargets: true,
          },
        });
      });

      expect(mockDocument.body.classList.add).toHaveBeenCalledWith('high-contrast');
      expect(mockDocument.body.classList.add).toHaveBeenCalledWith('reduce-motion');
      expect(mockDocument.body.classList.add).toHaveBeenCalledWith('large-targets');
    });

    it('should apply theme CSS classes', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          visualTheme: VisualTheme.SUNSET,
        });
      });

      // Should remove all theme classes first
      expect(mockDocument.body.classList.remove).toHaveBeenCalledWith(
        'theme-default',
        'theme-ocean',
        'theme-sunset',
        'theme-forest',
        'theme-lavender',
        'theme-monochrome',
        'theme-custom'
      );

      // Should add the new theme class
      expect(mockDocument.body.classList.add).toHaveBeenCalledWith('theme-sunset');
    });

    it('should handle dark mode theme values', async () => {
      // Mock dark mode detection
      mockDocumentElement.classList.contains.mockReturnValue(true);

      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          visualTheme: VisualTheme.FOREST,
        });
      });

      // Should use dark mode color values
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--primary-500', '74, 222, 128');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--secondary-500', '34, 197, 94');
      expect(mockDocumentElement.style.setProperty).toHaveBeenCalledWith('--tertiary-500', '22, 163, 74');
    });
  });

  describe('Custom Theme Handling', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should not override colors for custom theme', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      await act(async () => {
        await result.current.updatePreferences({
          visualTheme: VisualTheme.CUSTOM,
        });
      });

      // Should not set predefined color values for custom theme
      expect(mockDocumentElement.style.setProperty).not.toHaveBeenCalledWith('--primary-500', expect.any(String));
    });
  });

  describe('Performance and Edge Cases', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should not apply styles while loading', async () => {
      mockApiInstance.getUserPreferences.mockImplementation(() => new Promise(() => {})); // Never resolves

      renderHook(() => useAppearance());

      // Wait a bit to ensure styles aren't applied
      await new Promise(resolve => setTimeout(resolve, 100));

      expect(mockDocumentElement.style.setProperty).not.toHaveBeenCalled();
    });

    it('should handle transparency effects toggling', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      // Enable transparency effects
      await act(async () => {
        await result.current.updatePreferences({
          interface: {
            borderRadius: 'medium' as const,
            density: 'normal' as const,
            shadows: 'normal' as const,
            transparencyEffects: true,
          },
        });
      });

      expect(mockDocument.body.classList.add).toHaveBeenCalledWith('transparency-effects');

      // Disable transparency effects
      await act(async () => {
        await result.current.updatePreferences({
          interface: {
            borderRadius: 'medium' as const,
            density: 'normal' as const,
            shadows: 'normal' as const,
            transparencyEffects: false,
          },
        });
      });

      expect(mockDocument.body.classList.remove).toHaveBeenCalledWith('transparency-effects');
    });

    it('should handle accessibility features toggling', async () => {
      mockApiInstance.getUserPreferences.mockResolvedValue({});

      const { result } = renderHook(() => useAppearance());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      // Enable accessibility features
      await act(async () => {
        await result.current.updatePreferences({
          accessibility: {
            highContrast: true,
            reduceMotion: false,
            largeClickTargets: false,
          },
        });
      });

      expect(mockDocument.body.classList.add).toHaveBeenCalledWith('high-contrast');
      expect(mockDocument.body.classList.remove).toHaveBeenCalledWith('reduce-motion');
      expect(mockDocument.body.classList.remove).toHaveBeenCalledWith('large-targets');
    });
  });
});