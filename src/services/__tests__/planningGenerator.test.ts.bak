/**
 * @jest-environment node
 */
/**
 * @jest-environment node
 */
import { jest, describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
import { 
  setupTestEnvironment, 
  cleanupTestEnvironment, 
  createMockPrismaClient,
  createMockBcrypt,
  createMockJWT,
  createMockLogger,
  testDataFactories 
} from '../../test-utils/standardMocks';


// Mock external dependencies
jest.mock('@/lib/prisma', () => ({
  prisma: createMockPrismaClient()
}));

jest.mock('bcryptjs', () => createMockBcrypt());
jest.mock('jsonwebtoken', () => createMockJWT());
jest.mock('@/lib/logger', () => ({
  logger: createMockLogger()
}));

const mockPrisma = require('@/lib/prisma').prisma;
const mockBcrypt = require('bcryptjs');
const mockJwt = require('jsonwebtoken');
const mockLogger = require('@/lib/logger').logger;



// Mock du module de règles
jest.mock('../rulesConfigService', () => ({
  rulesConfigService: {
    getRulesConfiguration: jest.fn().mockResolvedValue({
      garde: { maxGardesMois: 8, maxGardesConsecutives: 2 },
      astreinte: { maxAstreintesMois: 4 },
      repos: { minReposEntreGardes: 1 },
      intervalle: { maxGardesMois: 8, maxGardesConsecutives: 2 }
    }),
    getFatigueConfiguration: jest.fn().mockResolvedValue({
      seuils: { critique: 80, alerte: 60 },
      poids: { garde: 10, astreinte: 5 },
      recuperation: { parJour: 2 }
    })
  }
}));

// Mock du RuleEngineV2 - simplifié
const mockRuleEngine = {
  initialize: jest.fn().mockResolvedValue(undefined),
  evaluate: jest.fn().mockResolvedValue([]),
  applyRules: jest.fn().mockResolvedValue([]),
  validateAssignment: jest.fn().mockResolvedValue({ valid: true, violations: [] })
};

// Mock du PlanningOptimizer
jest.mock('../planningOptimizer', () => ({
  PlanningOptimizer: jest.fn().mockImplementation(() => ({
    optimizePlanning: jest.fn().mockImplementation((assignments) => assignments),
    optimizeWorkload: jest.fn().mockResolvedValue([]),
    calculateEquityScore: jest.fn().mockReturnValue(85),
    distributeAssignments: jest.fn().mockResolvedValue([])
  }))
}));

describe('PlanningGenerator - Working Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  let generator: PlanningGenerator;
  let mockPersonnel: User[];
  let mockParameters: GenerationParameters;

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset tous les mocks
    jest.clearAllMocks();

    // Mock personnel de test
    mockPersonnel = [
      {
        id: 1,
        nom: 'Dupont',
        prenom: 'Jean',
        email: 'jean.dupont@hospital.fr',
        role: 'MAR',
        specialite: 'Anesthésie',
        active: true,
        sites: [1],
        competences: ['BLOC_CARDIO', 'PEDIATRIE'],
        preferences: { maxGardesMois: 6 },
        contraintes: [],
        weeklyHours: 35,
        isChefEquipe: false
      },
      {
        id: 2,
        nom: 'Martin',
        prenom: 'Marie',
        email: 'marie.martin@hospital.fr',
        role: 'IADE',
        specialite: 'Anesthésie',
        active: true,
        sites: [1],
        competences: ['BLOC_ORTHO', 'URGENCES'],
        preferences: { maxGardesMois: 8 },
        contraintes: [],
        weeklyHours: 35,
        isChefEquipe: true
      }
    ];

    // Paramètres de génération de test
    mockParameters = {
      dateDebut: new Date('2025-01-01'),
      dateFin: new Date('2025-01-31'),
      etapesActives: [AssignmentType.GARDE, AssignmentType.ASTREINTE],
      conserverAffectationsExistantes: true,
      niveauOptimisation: 'standard' as const,
      appliquerPreferencesPersonnelles: true,
      poidsEquite: 0.4,
      poidsPreference: 0.3,
      poidsQualiteVie: 0.3
    };

    // Créer une nouvelle instance pour chaque test
    generator = new PlanningGenerator(mockParameters);
  });

  describe('Service Structure', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should export PlanningGenerator class with required methods', () => {
      expect(generator).toBeDefined();
      expect(typeof generator.initialize).toBe('function');
      expect(typeof generator.generate).toBe('function');
    });
  });

  describe('initialize', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should initialize successfully with personnel', async () => {
      await expect(generator.initialize(mockPersonnel)).resolves.not.toThrow();
    });

    it('should initialize with personnel and existing assignments', async () => {
      const existingAssignments: Attribution[] = [
        {
          id: 'existing-1',
          userId: 1,
          type: AssignmentType.GARDE,
          startDate: new Date('2025-01-01'),
          endDate: new Date('2025-01-02'),
          site: 'Site A',
          specialite: 'Anesthésie',
          status: 'VALIDATED'
        }
      ];

      await expect(
        generator.initialize(mockPersonnel, existingAssignments)
      ).resolves.not.toThrow();
    });

    it('should handle empty personnel array', async () => {
      await expect(generator.initialize([])).resolves.not.toThrow();
    });

    it('should handle personnel with no competences', async () => {
      const personnelSansCompetences = [
        {
          ...mockPersonnel[0],
          competences: []
        }
      ];

      await expect(
        generator.initialize(personnelSansCompetences)
      ).resolves.not.toThrow();
    });
  });

  describe('generate', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(async () => {
      await generator.initialize(mockPersonnel);
    });

    it('should generate planning successfully', async () => {
      const result = await generator.generate();

      expect(result).toBeDefined();
      expect(result).toHaveProperty('attributions');
      expect(result).toHaveProperty('validation');
      expect(result).toHaveProperty('metrics');
      expect(Array.isArray(result.attributions)).toBe(true);
    });

    it('should respect medical scheduling constraints', async () => {
      const medicalParameters: GenerationParameters = {
        dateDebut: new Date('2025-01-01'),
        dateFin: new Date('2025-01-31'),
        etapesActives: [AssignmentType.GARDE, AssignmentType.ASTREINTE],
        conserverAffectationsExistantes: true,
        niveauOptimisation: 'medical' as const,
        appliquerPreferencesPersonnelles: true,
        poidsEquite: 0.4,
        poidsPreference: 0.2,
        poidsQualiteVie: 0.4
      };

      const medicalGenerator = new PlanningGenerator(medicalParameters);
      await medicalGenerator.initialize(mockPersonnel);
      
      const result = await medicalGenerator.generate();

      expect(result.validation.violations.filter(v => v.severity === 'ERROR')).toHaveLength(0);
      expect(result.metrics.coveragePercentage).toBeGreaterThan(80);
      expect(result.metrics.equityScore).toBeGreaterThan(0.7);
    });

    it('should handle MAR/IADE role distribution', async () => {
      const medicalPersonnel = [
        {
          ...mockPersonnel[0],
          role: 'MAR',
          competences: ['BLOC_CARDIO', 'REANIMATION'],
          requiresSupervision: true
        },
        {
          ...mockPersonnel[1],
          role: 'IADE',
          competences: ['SUPERVISION_MAR', 'BLOC_ORTHO'],
          canSupervise: true
        }
      ];

      await generator.initialize(medicalPersonnel);
      const result = await generator.generate();

      // Vérifier que les MAR ont une supervision IADE
      const marAssignments = result.attributions.filter(a => 
        medicalPersonnel.find(p => String(p.id) === a.userId)?.role === 'MAR'
      );
      
      expect(marAssignments.length).toBeGreaterThan(0);
      // Chaque MAR devrait avoir une supervision
      marAssignments.forEach(marAssignment => {
        const hasSupervision = result.attributions.some(a => 
          medicalPersonnel.find(p => String(p.id) === a.userId)?.role === 'IADE' &&
          areDatesSameDay(a.startDate, marAssignment.startDate)
        );
        expect(hasSupervision).toBe(true);
      });
    });

    it('should optimize for anesthesia team fatigue', async () => {
      const fatigueConfig = {
        enabled: true,
        seuils: { critique: 80, alerte: 60 },
        points: { garde: 10, astreinte: 5 },
        recovery: { jourOff: 15 }
      };

      const fatigueGenerator = new PlanningGenerator(mockParameters, defaultRulesConfiguration, fatigueConfig);
      await fatigueGenerator.initialize(mockPersonnel);
      
      const result = await fatigueGenerator.generate();

      // Vérifier qu'aucun utilisateur ne dépasse le seuil critique de fatigue
      const fatigueViolations = result.validation.violations.filter(v => v.type === 'FATIGUE');
      expect(fatigueViolations).toHaveLength(0);
      
      // Vérifier que la répartition équitable réduit la fatigue
      expect(result.metrics.equityScore).toBeGreaterThan(0.6);
    });

    it('should return validation results', async () => {
      const result = await generator.generate();

      expect(result.validation).toBeDefined();
      expect(result.validation).toHaveProperty('valid');
      expect(result.validation).toHaveProperty('violations');
      expect(typeof result.validation.valid).toBe('boolean');
      expect(Array.isArray(result.validation.violations)).toBe(true);
    });

    it('should return planning metrics', async () => {
      const result = await generator.generate();

      expect(result.metrics).toBeDefined();
      expect(result.metrics).toHaveProperty('equityScore');
      expect(result.metrics).toHaveProperty('totalAssignments');
      expect(result.metrics).toHaveProperty('coveragePercentage');
      expect(typeof result.metrics.equityScore).toBe('number');
    });

    it('should handle generation with existing assignments', async () => {
      const existingAssignments: Attribution[] = [
        {
          id: 'existing-1',
          userId: 1,
          type: AssignmentType.GARDE,
          startDate: new Date('2025-01-01'),
          endDate: new Date('2025-01-02'),
          site: 'Site A',
          specialite: 'Anesthésie',
          status: 'VALIDATED'
        }
      ];

      await generator.initialize(mockPersonnel, existingAssignments);
      const result = await generator.generate();

      expect(result.attributions).toBeDefined();
      expect(Array.isArray(result.attributions)).toBe(true);
    });
  });

  describe('Error Handling', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle generation without initialization', async () => {
      const newGenerator = new PlanningGenerator(mockParameters);
      
      // Essayer de générer sans initialiser devrait lancer une erreur appropriée
      await expect(newGenerator.generate()).rejects.toThrow('Organisateur not initialized');
    });

    it('should handle malformed personnel data', async () => {
      const malformedPersonnel = [
        {
          id: null,
          nom: '',
          email: 'invalid-email',
          role: 'UNKNOWN_ROLE'
        } as any
      ];

      await expect(
        generator.initialize(malformedPersonnel)
      ).resolves.not.toThrow();
    });

    it('should handle invalid date ranges in parameters', async () => {
      const invalidParameters: GenerationParameters = {
        dateDebut: new Date('2025-01-31'),
        dateFin: new Date('2025-01-01'), // Date fin antérieure à date début
        etapesActives: [AssignmentType.GARDE],
        conserverAffectationsExistantes: true,
        niveauOptimisation: 'standard' as const,
        appliquerPreferencesPersonnelles: true,
        poidsEquite: 0.4,
        poidsPreference: 0.3,
        poidsQualiteVie: 0.3
      };

      const invalidGenerator = new PlanningGenerator(invalidParameters);
      await invalidGenerator.initialize(mockPersonnel);
      
      // Devrait gérer l'erreur gracieusement
      const result = await invalidGenerator.generate();
      expect(result).toBeDefined();
    });
  });

  describe('Performance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle large personnel datasets efficiently', async () => {
      const largePersonnel = Array.from({ length: 50 }, (_, i) => ({
        ...mockPersonnel[0],
        id: i + 1,
        nom: `User${i + 1}`,
        email: `user${i + 1}@hospital.fr`
      }));

      const startTime = Date.now();
      await generator.initialize(largePersonnel);
      await generator.generate();
      const endTime = Date.now();

      // Devrait terminer en moins de 5 secondes même avec 50 utilisateurs
      expect(endTime - startTime).toBeLessThan(5000);
    });

    it('should handle multiple consecutive generations', async () => {
      await generator.initialize(mockPersonnel);

      const results = [];
      for (let i = 0; i < 3; i++) {
        const result = await generator.generate();
        results.push(result);
      }

      // Tous les résultats devraient être valides
      results.forEach(result => {
        expect(result).toBeDefined();
        expect(result.attributions).toBeDefined();
        expect(result.validation).toBeDefined();
      });
    });
  });

  describe('Medical Planning Quality', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(async () => {
      await generator.initialize(mockPersonnel);
    });

    it('should distribute assignments among available personnel', async () => {
      const result = await generator.generate();

      if (result.attributions.length > 0) {
        const userIds = new Set(result.attributions.map(a => a.userId));
        expect(userIds.size).toBeGreaterThan(0);
        expect(userIds.size).toBeLessThanOrEqual(mockPersonnel.length);
      }
    });

    it('should enforce medical specialty matching', async () => {
      const specializedPersonnel = [
        {
          ...mockPersonnel[0],
          specialite: 'Anesthésie Cardiaque',
          competences: ['BLOC_CARDIO', 'CIRCULATION_EXTRACORPORELLE']
        },
        {
          ...mockPersonnel[1],
          specialite: 'Anesthésie Pédiatrique',
          competences: ['PEDIATRIE', 'NEONATOLOGIE']
        }
      ];

      await generator.initialize(specializedPersonnel);
      const result = await generator.generate();

      // Vérifier que les compétences correspondent aux affectations
      result.attributions.forEach(attribution => {
        const user = specializedPersonnel.find(p => String(p.id) === attribution.userId);
        expect(user).toBeDefined();
        
        if (attribution.notes && attribution.notes.includes('Cardio')) {
          expect(user?.competences).toContain('BLOC_CARDIO');
        }
        if (attribution.notes && attribution.notes.includes('Pédiatrie')) {
          expect(user?.competences).toContain('PEDIATRIE');
        }
      });
    });

    it('should respect work-life balance for medical staff', async () => {
      const personnelWithConstraints = mockPersonnel.map(p => ({
        ...p,
        contraintes: [
          {
            type: 'WEEKEND_LIMIT',
            value: 2, // Max 2 weekends per month
            priority: 'HIGH'
          },
          {
            type: 'CONSECUTIVE_LIMIT',
            value: 2, // Max 2 consecutive days
            priority: 'MEDIUM'
          }
        ]
      }));

      await generator.initialize(personnelWithConstraints);
      const result = await generator.generate();

      // Vérifier le respect des contraintes de qualité de vie
      const weekendViolations = result.validation.violations.filter(v => 
        v.message.includes('weekend') || v.type === 'WEEKEND_LIMIT'
      );
      expect(weekendViolations.length).toBeLessThan(2); // Quelques violations acceptables

      const consecutiveViolations = result.validation.violations.filter(v => 
        v.type === 'CONSECUTIVE_ASSIGNMENTS'
      );
      expect(consecutiveViolations.length).toBeLessThan(3);
    });

    it('should optimize for emergency coverage', async () => {
      const emergencyParameters = {
        ...mockParameters,
        etapesActives: [AssignmentType.GARDE, AssignmentType.ASTREINTE],
        prioriteUrgences: true,
        couvertureMinimale: 0.95
      };

      const emergencyGenerator = new PlanningGenerator(emergencyParameters);
      await emergencyGenerator.initialize(mockPersonnel);
      
      const result = await emergencyGenerator.generate();

      // Vérifier la couverture d'urgence
      expect(result.metrics.coveragePercentage).toBeGreaterThan(90);
      
      // Chaque jour devrait avoir au moins une garde
      const startDate = new Date(emergencyParameters.dateDebut);
      const endDate = new Date(emergencyParameters.dateFin);
      const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
      
      const gardesCount = result.attributions.filter(a => a.shiftType === 'GARDE_24H').length;
      expect(gardesCount).toBeGreaterThanOrEqual(Math.floor(totalDays * 0.8)); // Au moins 80% des jours couverts
    });

    it('should respect assignment type constraints', async () => {
      const result = await generator.generate();

      if (result.attributions.length > 0) {
        result.attributions.forEach(attribution => {
          // L'attribution utilise shiftType au lieu de type dans cette implémentation
          expect(attribution).toHaveProperty('shiftType');
          expect(attribution.startDate).toBeInstanceOf(Date);
          expect(attribution.endDate).toBeInstanceOf(Date);
          expect(attribution.startDate.getTime()).toBeLessThanOrEqual(
            attribution.endDate.getTime()
          );
        });
      }
    });

    it('should include specialite and site information', async () => {
      const result = await generator.generate();

      if (result.attributions.length > 0) {
        result.attributions.forEach(attribution => {
          // Vérifier que l'attribution a une structure valide
          expect(attribution).toHaveProperty('userId');
          expect(attribution).toHaveProperty('startDate');
          expect(attribution).toHaveProperty('endDate');
          
          // Les propriétés optionnelles peuvent être présentes selon l'implémentation
          if (attribution.notes) {
            expect(typeof attribution.notes).toBe('string');
          }
          if (attribution.validatedBy) {
            expect(typeof attribution.validatedBy).toBe('string');
          }
        });
      }
    });
  });

  describe('Medical Rules Integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(async () => {
      await generator.initialize(mockPersonnel);
    });

    it('should interact with RuleEngineV2', async () => {
      await generator.generate();
      
      // Vérifier que le RuleEngineV2 a été utilisé
      const mockRuleEngine = require('@/modules/dynamicRules/v2/services/RuleEngineV2').RuleEngineV2;
      expect(mockRuleEngine).toHaveBeenCalled();
    });

    it('should use rulesConfigService for configuration', async () => {
      await generator.generate();
      
      // Vérifier que la configuration des règles a été récupérée
      const { rulesConfigService } = require('../rulesConfigService');
      expect(rulesConfigService.getRulesConfiguration).toHaveBeenCalled();
      expect(rulesConfigService.getFatigueConfiguration).toHaveBeenCalled();
    });

    it('should apply anesthesia-specific medical rules', async () => {
      const medicalRulesConfig = {
        garde: { maxGardesMois: 8, maxGardesConsecutives: 2 },
        astreinte: { maxAstreintesMois: 4 },
        repos: { minReposEntreGardes: 12 }, // 12 heures minimum
        intervalle: { maxGardesMois: 8, maxGardesConsecutives: 2 },
        medical: {
          tempsReposObligatoire: 12,
          maxHeuresConsecutives: 24,
          pauseMinimaleEntreGardes: 11
        }
      };

      const medicalGenerator = new PlanningGenerator(mockParameters, medicalRulesConfig);
      await medicalGenerator.initialize(mockPersonnel);
      
      const result = await medicalGenerator.generate();

      // Vérifier le respect des règles médicales
      const restViolations = result.validation.violations.filter(v => 
        v.message.includes('repos') || v.type === 'INSUFFICIENT_REST_TIME'
      );
      expect(restViolations.length).toBeLessThan(2);

      // Vérifier les limites d'heures consécutives
      const overtimeViolations = result.validation.violations.filter(v => 
        v.message.includes('heures') || v.type === 'OVERTIME_VIOLATION'
      );
      expect(overtimeViolations.length).toBe(0);
    });

    it('should handle pediatric anesthesia constraints', async () => {
      const pediatricPersonnel = [
        {
          ...mockPersonnel[0],
          specialite: 'Anesthésie Pédiatrique',
          competences: ['PEDIATRIE', 'NEONATOLOGIE'],
          certifications: ['PEDIATRIC_ADVANCED_LIFE_SUPPORT']
        },
        {
          ...mockPersonnel[1],
          specialite: 'Anesthésie Générale',
          competences: ['ADULTE', 'GERIATRIE']
        }
      ];

      await generator.initialize(pediatricPersonnel);
      const result = await generator.generate();

      // Vérifier que les compétences pédiatriques sont prises en compte
      result.attributions.forEach(attribution => {
        const user = pediatricPersonnel.find(p => String(p.id) === attribution.userId);
        if (attribution.notes && attribution.notes.includes('Pédiatrie')) {
          expect(user?.competences).toContain('PEDIATRIE');
        }
      });
    });

    it('should integrate with equipment and resource planning', async () => {
      const personnelWithEquipment = mockPersonnel.map(p => ({
        ...p,
        equipmentCertifications: ['VENTILATEUR', 'MONITORING_AVANCE', 'ECMO'],
        resourceAccess: ['SALLE_HYBRIDE', 'SCANNER_INTERVENTIONNEL']
      }));

      await generator.initialize(personnelWithEquipment);
      const result = await generator.generate();

      // Vérifier que les ressources sont prises en compte dans la planification
      expect(result.attributions.length).toBeGreaterThan(0);
      
      // Chaque affectation devrait avoir accès aux ressources nécessaires
      result.attributions.forEach(attribution => {
        const user = personnelWithEquipment.find(p => String(p.id) === attribution.userId);
        expect(user?.equipmentCertifications?.length).toBeGreaterThan(0);
      });
    });
  });
});