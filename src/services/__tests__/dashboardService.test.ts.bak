/**
 * @jest-environment node
 */
import { jest, describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
import { 
  setupTestEnvironment, 
  cleanupTestEnvironment, 
  createMockPrismaClient,
  createMockBcrypt,
  createMockJWT,
  createMockLogger,
  testDataFactories 
} from '../../test-utils/standardMocks';
import { dashboardService } from '../dashboardService';

// Mock external dependencies
jest.mock('@/lib/prisma', () => ({
  prisma: createMockPrismaClient()
}));

jest.mock('bcryptjs', () => createMockBcrypt());
jest.mock('jsonwebtoken', () => createMockJWT());
jest.mock('@/lib/logger', () => ({
  logger: createMockLogger()
}));

jest.mock('../errorLoggingService', () => ({
  logError: jest.fn()
}));

const mockPrisma = require('@/lib/prisma').prisma;
const mockBcrypt = require('bcryptjs');
const mockJwt = require('jsonwebtoken');
const mockLogger = require('@/lib/logger').logger;

const mockWidget = {
  id: 'widget-1',
  type: 'calendar',
  position: { x: 0, y: 0 },
  size: { width: 2, height: 2 }
};

const mockDashboardFromDB = {
  id: 'dashboard-1',
  userId: 1,
  name: 'My Dashboard',
  widgets: JSON.stringify([mockWidget]),
  layout: 'grid'
};

const expectedDashboard = {
  id: 'dashboard-1',
  userId: 1,
  name: 'My Dashboard',
  widgets: [mockWidget],
  layout: 'grid'
};

describe('DashboardService - Working Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });


  beforeAll(() => {
  });

  afterAll(() => {
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
  });

  describe('Service Structure', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should export dashboardService with required methods', () => {
      expect(dashboardService).toBeDefined();
      expect(typeof dashboardService.getDashboard).toBe('function');
      expect(typeof dashboardService.createDashboard).toBe('function');
      expect(typeof dashboardService.updateDashboard).toBe('function');
      expect(typeof dashboardService.deleteDashboard).toBe('function');
    });
  });

  describe('getDashboard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should get dashboard for user successfully', async () => {
      mockPrisma.dashboard.findFirst.mockResolvedValueOnce(mockDashboardFromDB);

      const result = await dashboardService.getDashboard(1);

      expect(result).toEqual(expectedDashboard);
      expect(mockPrisma.dashboard.findFirst).toHaveBeenCalledWith({
        where: { userId: 1 }
      });
    });

    it('should return null when dashboard not found', async () => {
      mockPrisma.dashboard.findFirst.mockResolvedValueOnce(null);

      const result = await dashboardService.getDashboard(999);

      expect(result).toBeNull();
      expect(mockPrisma.dashboard.findFirst).toHaveBeenCalledWith({
        where: { userId: 999 }
      });
    });

    it('should handle database errors gracefully', async () => {
      const mockError = new Error('Database error');
      mockPrisma.dashboard.findFirst.mockRejectedValueOnce(mockError);

      await expect(dashboardService.getDashboard(1)).rejects.toThrow('Database error');
    });
  });

  describe('createDashboard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should create dashboard successfully', async () => {
      const dashboardData = {
        userId: 1,
        name: 'New Dashboard',
        widgets: [],
        layout: 'grid' as const
      };

      const mockCreatedFromDB = {
        id: 'dashboard-2',
        userId: 1,
        name: 'New Dashboard',
        widgets: '[]',
        layout: 'grid'
      };

      const expectedCreated = {
        id: 'dashboard-2',
        userId: 1,
        name: 'New Dashboard',
        widgets: [],
        layout: 'grid'
      };

      mockPrisma.dashboard.create.mockResolvedValueOnce(mockCreatedFromDB);

      const result = await dashboardService.createDashboard(dashboardData);

      expect(result).toEqual(expectedCreated);
      expect(mockPrisma.dashboard.create).toHaveBeenCalledWith({
        data: {
          ...dashboardData,
          widgets: JSON.stringify(dashboardData.widgets)
        }
      });
    });

    it('should handle creation errors', async () => {
      const dashboardData = {
        userId: 1,
        name: 'New Dashboard',
        widgets: [],
        layout: 'grid' as const
      };

      mockPrisma.dashboard.create.mockRejectedValueOnce(new Error('Creation failed'));

      await expect(dashboardService.createDashboard(dashboardData)).rejects.toThrow('Creation failed');
    });

    it('should create dashboard with widgets', async () => {
      const widgets = [
        {
          id: 'widget-1',
          type: 'calendar',
          position: { x: 0, y: 0 },
          size: { width: 2, height: 2 }
        },
        {
          id: 'widget-2',
          type: 'stats',
          position: { x: 2, y: 0 },
          size: { width: 1, height: 1 }
        }
      ];

      const dashboardData = {
        userId: 1,
        name: 'Dashboard with Widgets',
        widgets,
        layout: 'free' as const
      };

      const mockCreatedFromDB = {
        id: 'dashboard-3',
        userId: 1,
        name: 'Dashboard with Widgets',
        widgets: JSON.stringify(widgets),
        layout: 'free'
      };

      const expectedCreated = {
        id: 'dashboard-3',
        userId: 1,
        name: 'Dashboard with Widgets',
        widgets,
        layout: 'free'
      };

      mockPrisma.dashboard.create.mockResolvedValueOnce(mockCreatedFromDB);

      const result = await dashboardService.createDashboard(dashboardData);

      expect(result).toEqual(expectedCreated);
      expect(result.widgets).toHaveLength(2);
      expect(result.layout).toBe('free');
    });
  });

  describe('updateDashboard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should update dashboard successfully', async () => {
      const updateWidgets = [
        {
          id: 'widget-updated',
          type: 'notifications',
          position: { x: 1, y: 1 },
          size: { width: 1, height: 1 }
        }
      ];

      const updateData = {
        name: 'Updated Dashboard',
        widgets: updateWidgets
      };

      const mockUpdatedFromDB = {
        id: 'dashboard-1',
        userId: 1,
        name: 'Updated Dashboard',
        widgets: JSON.stringify(updateWidgets),
        layout: 'grid'
      };

      const expectedUpdated = {
        id: 'dashboard-1',
        userId: 1,
        name: 'Updated Dashboard',
        widgets: updateWidgets,
        layout: 'grid'
      };

      mockPrisma.dashboard.update.mockResolvedValueOnce(mockUpdatedFromDB);

      const result = await dashboardService.updateDashboard('dashboard-1', updateData);

      expect(result).toEqual(expectedUpdated);
      expect(mockPrisma.dashboard.update).toHaveBeenCalledWith({
        where: { id: 'dashboard-1' },
        data: {
          ...updateData,
          widgets: JSON.stringify(updateData.widgets)
        }
      });
    });

    it('should handle update errors', async () => {
      mockPrisma.dashboard.update.mockRejectedValueOnce(new Error('Update failed'));

      await expect(
        dashboardService.updateDashboard('dashboard-1', { name: 'New Name' })
      ).rejects.toThrow('Update failed');
    });

    it('should handle partial updates without widgets', async () => {
      const partialUpdate = { name: 'Partially Updated' };

      const mockUpdatedFromDB = {
        id: 'dashboard-1',
        userId: 1,
        name: 'Partially Updated',
        widgets: '[]',
        layout: 'grid'
      };

      const expectedUpdated = {
        id: 'dashboard-1',
        userId: 1,
        name: 'Partially Updated',
        widgets: [],
        layout: 'grid'
      };

      mockPrisma.dashboard.update.mockResolvedValueOnce(mockUpdatedFromDB);

      const result = await dashboardService.updateDashboard('dashboard-1', partialUpdate);

      expect(result).toEqual(expectedUpdated);
      expect(mockPrisma.dashboard.update).toHaveBeenCalledWith({
        where: { id: 'dashboard-1' },
        data: {
          ...partialUpdate,
          widgets: undefined
        }
      });
    });
  });

  describe('deleteDashboard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should delete dashboard successfully', async () => {
      mockPrisma.dashboard.delete.mockResolvedValueOnce({
        id: 'dashboard-1',
        userId: 1,
        name: 'Deleted Dashboard',
        widgets: '[]',
        layout: 'grid'
      });

      await expect(dashboardService.deleteDashboard('dashboard-1')).resolves.not.toThrow();

      expect(mockPrisma.dashboard.delete).toHaveBeenCalledWith({
        where: { id: 'dashboard-1' }
      });
    });

    it('should handle deletion errors', async () => {
      mockPrisma.dashboard.delete.mockRejectedValueOnce(new Error('Deletion failed'));

      await expect(dashboardService.deleteDashboard('dashboard-1')).rejects.toThrow('Deletion failed');
    });

    it('should handle non-existent dashboard deletion', async () => {
      mockPrisma.dashboard.delete.mockRejectedValueOnce(new Error('Record not found'));

      await expect(dashboardService.deleteDashboard('non-existent')).rejects.toThrow('Record not found');
    });
  });

  describe('Data Validation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle dashboard with empty widgets array', async () => {
      const dashboardData = {
        userId: 1,
        name: 'Empty Dashboard',
        widgets: [],
        layout: 'grid' as const
      };

      const mockCreatedFromDB = {
        id: 'dashboard-empty',
        userId: 1,
        name: 'Empty Dashboard',
        widgets: '[]',
        layout: 'grid'
      };

      const expectedCreated = {
        id: 'dashboard-empty',
        userId: 1,
        name: 'Empty Dashboard',
        widgets: [],
        layout: 'grid'
      };

      mockPrisma.dashboard.create.mockResolvedValueOnce(mockCreatedFromDB);

      const result = await dashboardService.createDashboard(dashboardData);

      expect(result).toEqual(expectedCreated);
      expect(result.widgets).toHaveLength(0);
    });

    it('should handle different layout types', async () => {
      const gridDashboard = {
        userId: 1,
        name: 'Grid Dashboard',
        widgets: [],
        layout: 'grid' as const
      };

      const freeDashboard = {
        userId: 2,
        name: 'Free Dashboard',
        widgets: [],
        layout: 'free' as const
      };

      mockPrisma.dashboard.create
        .mockResolvedValueOnce({ 
          id: 'grid-1', 
          userId: 1,
          name: 'Grid Dashboard',
          widgets: '[]',
          layout: 'grid'
        })
        .mockResolvedValueOnce({ 
          id: 'free-1', 
          userId: 2,
          name: 'Free Dashboard',
          widgets: '[]',
          layout: 'free'
        });

      const gridResult = await dashboardService.createDashboard(gridDashboard);
      const freeResult = await dashboardService.createDashboard(freeDashboard);

      expect(gridResult.layout).toBe('grid');
      expect(freeResult.layout).toBe('free');
    });
  });

  describe('Performance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle multiple concurrent operations', async () => {
      const dashboards = Array.from({ length: 3 }, (_, i) => ({
        userId: i + 1,
        name: `Dashboard ${i + 1}`,
        widgets: [],
        layout: 'grid' as const
      }));

      dashboards.forEach((dashboard, i) => {
        mockPrisma.dashboard.create.mockResolvedValueOnce({
          id: `dashboard-${i + 1}`,
          userId: dashboard.userId,
          name: dashboard.name,
          widgets: '[]',
          layout: 'grid'
        });
      });

      const startTime = Date.now();
      const promises = dashboards.map(dashboard => 
        dashboardService.createDashboard(dashboard)
      );
      
      const results = await Promise.all(promises);
      const endTime = Date.now();

      expect(results).toHaveLength(3);
      results.forEach((result, i) => {
        expect(result.userId).toBe(i + 1);
        expect(result.name).toBe(`Dashboard ${i + 1}`);
        expect(result.widgets).toEqual([]);
      });

      expect(endTime - startTime).toBeLessThan(1000);
    });

    it('should handle large widget arrays efficiently', async () => {
      const largeWidgetArray = Array.from({ length: 10 }, (_, i) => ({
        id: `widget-${i}`,
        type: 'generic',
        position: { x: i % 5, y: Math.floor(i / 5) },
        size: { width: 1, height: 1 }
      }));

      const dashboardData = {
        userId: 1,
        name: 'Large Dashboard',
        widgets: largeWidgetArray,
        layout: 'free' as const
      };

      const mockCreatedFromDB = {
        id: 'large-dashboard',
        userId: 1,
        name: 'Large Dashboard',
        widgets: JSON.stringify(largeWidgetArray),
        layout: 'free'
      };

      const expectedCreated = {
        id: 'large-dashboard',
        userId: 1,
        name: 'Large Dashboard',
        widgets: largeWidgetArray,
        layout: 'free'
      };

      mockPrisma.dashboard.create.mockResolvedValueOnce(mockCreatedFromDB);

      const startTime = Date.now();
      const result = await dashboardService.createDashboard(dashboardData);
      const endTime = Date.now();

      expect(result).toEqual(expectedCreated);
      expect(result.widgets).toHaveLength(10);
      expect(endTime - startTime).toBeLessThan(100);
    });
  });
});