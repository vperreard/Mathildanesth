/**
 * @jest-environment node
 */
/**
 * @jest-environment node
 */
import { jest, describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
import { 
  setupTestEnvironment, 
  cleanupTestEnvironment, 
  createMockPrismaClient,
  createMockBcrypt,
  createMockJWT,
  createMockLogger,
  testDataFactories 
} from '../../test-utils/standardMocks';


// Mock external dependencies
jest.mock('@/lib/prisma', () => ({
  prisma: createMockPrismaClient()
}));

jest.mock('bcryptjs', () => createMockBcrypt());
jest.mock('jsonwebtoken', () => createMockJWT());
jest.mock('@/lib/logger', () => ({
  logger: createMockLogger()
}));

const mockPrisma = require('@/lib/prisma').prisma;
const mockBcrypt = require('bcryptjs');
const mockJwt = require('jsonwebtoken');
const mockLogger = require('@/lib/logger').logger;



// Mock des services externes
jest.mock('../rulesConfigService', () => ({
  rulesConfigService: {
    getRulesConfiguration: jest.fn().mockResolvedValue({
      garde: { maxGardesMois: 8, maxGardesConsecutives: 2 },
      astreinte: { maxAstreintesMois: 4 },
      repos: { minReposEntreGardes: 12 },
      intervalle: { maxGardesMois: 8, maxGardesConsecutives: 2, minJoursEntreGardes: 1 },
      medical: {
        tempsReposObligatoire: 12,
        maxHeuresConsecutives: 24,
        pauseMinimaleEntreGardes: 11,
        supervisionMAR: true,
        comptageHeuresSupplementaires: true
      }
    }),
    getFatigueConfiguration: jest.fn().mockResolvedValue({
      enabled: true,
      seuils: { critique: 80, alerte: 60 },
      points: { garde: 10, astreinte: 5, consultation: 3 },
      recovery: { jourOff: 15 }
    })
  }
}));

// Mock simple pour RuleEngineV2
const mockRuleEngineV2 = {
  initialize: jest.fn().mockResolvedValue(undefined),
  evaluate: jest.fn().mockImplementation((context, ruleType) => {
    // Simuler des violations de règles selon le contexte
    if (ruleType === 'validation' && context.attribution) {
      const violations = [];
      
      // Simuler violation de temps de repos
      if (context.attribution.startDate && context.planning?.existingAssignments) {
        const existingAssignment = context.planning.existingAssignments.find(a => 
          a.userId === context.attribution.userId
        );
        if (existingAssignment) {
          violations.push({
            ruleId: 'REST_TIME_VIOLATION',
            ruleName: 'Temps de repos obligatoire',
            passed: false,
            actions: [{
              type: 'validate',
              parameters: {
                severity: 'ERROR',
                violationType: 'INSUFFICIENT_REST_TIME',
                message: 'Temps de repos insuffisant entre deux affectations'
              }
            }]
          });
        }
      }
      
      return Promise.resolve(violations);
    }
    return Promise.resolve([]);
  }),
  applyRules: jest.fn().mockResolvedValue([]),
  validateAssignment: jest.fn().mockResolvedValue({ valid: true, violations: [] })
};

describe('Planning Rules Validation - Medical Context', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  let generator: PlanningGenerator;
  let mockPersonnel: User[];
  let mockParameters: GenerationParameters;
  let medicalRulesConfig: RulesConfiguration;
  let fatigueConfig: FatigueConfig;

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();

    // Configuration médicale stricte
    medicalRulesConfig = {
      garde: { 
        maxGardesMois: 8, 
        maxGardesConsecutives: 2,
        maxGardesWeekend: 3,
        repos24hApresGarde: true
      },
      astreinte: { 
        maxAstreintesMois: 4,
        maxAstreintesWeekend: 2
      },
      repos: { 
        minReposEntreGardes: 12,
        reposObligatoireApresDeux: 24,
        weekendLibreParMois: 2
      },
      intervalle: { 
        maxGardesMois: 8, 
        maxGardesConsecutives: 2, 
        minJoursEntreGardes: 1,
        maxHeuresSemaine: 48
      },
      medical: {
        tempsReposObligatoire: 12,
        maxHeuresConsecutives: 24,
        pauseMinimaleEntreGardes: 11,
        supervisionMAR: true,
        comptageHeuresSupplementaires: true,
        limitesSpecialite: {
          'Anesthésie Pédiatrique': { maxGardesConsecutives: 1 },
          'Anesthésie Cardiaque': { maxHeuresSemaine: 44 }
        }
      },
      consultations: {
        maxParSemaine: 5,
        creneauxMatin: 2,
        creneauxApresMidi: 2
      }
    };

    fatigueConfig = {
      enabled: true,
      seuils: { 
        critique: 80, 
        alerte: 60,
        repos: 40
      },
      points: { 
        garde: 15, 
        astreinte: 8, 
        consultation: 3,
        gardeWeekend: 20,
        astreinteWeekend: 12
      },
      recovery: { 
        jourOff: 15,
        weekendOff: 25,
        congesMaladie: 30
      }
    };

    // Personnel médical spécialisé
    mockPersonnel = [
      {
        id: 1,
        nom: 'Martin',
        prenom: 'Jean',
        email: 'j.martin@hospital.fr',
        role: 'MAR',
        specialite: 'Anesthésie Générale',
        active: true,
        sites: [1],
        competences: ['BLOC_GENERAL', 'REANIMATION'],
        preferences: { maxGardesMois: 6 },
        contraintes: [],
        weeklyHours: 35,
        isChefEquipe: false,
        yearsOfExperience: 8,
        requiresSupervision: true
      },
      {
        id: 2,
        nom: 'Dubois',
        prenom: 'Marie',
        email: 'm.dubois@hospital.fr',
        role: 'IADE',
        specialite: 'Anesthésie Pédiatrique',
        active: true,
        sites: [1],
        competences: ['PEDIATRIE', 'SUPERVISION_MAR', 'URGENCES'],
        preferences: { maxGardesMois: 7 },
        contraintes: [],
        weeklyHours: 35,
        isChefEquipe: true,
        yearsOfExperience: 12,
        canSupervise: true
      },
      {
        id: 3,
        nom: 'Leroy',
        prenom: 'Pierre',
        email: 'p.leroy@hospital.fr',
        role: 'IADE',
        specialite: 'Anesthésie Cardiaque',
        active: true,
        sites: [1],
        competences: ['BLOC_CARDIO', 'CIRCULATION_EXTRACORPORELLE'],
        preferences: { maxGardesMois: 5 },
        contraintes: [
          { type: 'REPOS_WEEKEND', frequency: 'MONTHLY', value: 2 }
        ],
        weeklyHours: 35,
        isChefEquipe: false,
        yearsOfExperience: 15,
        canSupervise: true
      }
    ];

    mockParameters = {
      dateDebut: new Date('2025-01-01'),
      dateFin: new Date('2025-01-31'),
      etapesActives: [AssignmentType.GARDE, AssignmentType.ASTREINTE],
      conserverAffectationsExistantes: true,
      niveauOptimisation: 'medical' as const,
      appliquerPreferencesPersonnelles: true,
      poidsEquite: 0.3,
      poidsPreference: 0.2,
      poidsQualiteVie: 0.5 // Priorité à la qualité de vie
    };

    generator = new PlanningGenerator(mockParameters, medicalRulesConfig, fatigueConfig);
  });

  describe('Medical Rest Time Validation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should enforce mandatory 11-hour rest between assignments', async () => {
      const existingAssignments: Attribution[] = [
        {
          id: 'existing-1',
          userId: '1',
          shiftType: ShiftType.GARDE_24H,
          startDate: new Date('2025-01-01T08:00:00'),
          endDate: new Date('2025-01-02T08:00:00'),
          status: 'VALIDATED',
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];

      await generator.initialize(mockPersonnel, existingAssignments);
      const result = await generator.generate();

      // Vérifier qu'aucune affectation ne viole le temps de repos obligatoire
      const restViolations = result.validation.violations.filter(v => 
        v.type === 'INSUFFICIENT_REST_TIME' || v.message.includes('repos')
      );

      expect(restViolations.length).toBeLessThan(2); // Quelques violations peuvent être acceptables
      
      // Vérifier qu'il y a bien un écart de 11h minimum
      const newAssignments = result.attributions.filter(a => a.userId === '1');
      newAssignments.forEach(assignment => {
        const timeDiff = assignment.startDate.getTime() - existingAssignments[0].endDate.getTime();
        const hoursDiff = timeDiff / (1000 * 60 * 60);
        
        if (hoursDiff > 0 && hoursDiff < 11) {
          // Cette affectation devrait être signalée comme violation
          const hasViolation = restViolations.some(v => 
            v.affectedAssignments?.includes(assignment.id)
          );
          expect(hasViolation).toBe(true);
        }
      });
    });

    it('should enforce 24-hour rest after two consecutive guards', async () => {
      const consecutiveGuards: Attribution[] = [
        {
          id: 'guard-1',
          userId: '2',
          shiftType: ShiftType.GARDE_24H,
          startDate: new Date('2025-01-01T08:00:00'),
          endDate: new Date('2025-01-02T08:00:00'),
          status: 'VALIDATED',
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'guard-2',
          userId: '2',
          shiftType: ShiftType.GARDE_24H,
          startDate: new Date('2025-01-02T08:00:00'),
          endDate: new Date('2025-01-03T08:00:00'),
          status: 'VALIDATED',
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];

      await generator.initialize(mockPersonnel, consecutiveGuards);
      const result = await generator.generate();

      // Vérifier qu'aucune nouvelle garde n'est assignée dans les 24h suivantes
      const user2NewAssignments = result.attributions.filter(a => 
        a.userId === '2' && a.shiftType === ShiftType.GARDE_24H
      );

      user2NewAssignments.forEach(assignment => {
        const timeSinceLastGuard = assignment.startDate.getTime() - 
          new Date('2025-01-03T08:00:00').getTime();
        const hoursSinceLastGuard = timeSinceLastGuard / (1000 * 60 * 60);
        
        expect(hoursSinceLastGuard).toBeGreaterThanOrEqual(24);
      });
    });

    it('should validate weekend rest requirements', async () => {
      await generator.initialize(mockPersonnel);
      const result = await generator.generate();

      // Vérifier que chaque personne a au moins 2 weekends libres par mois
      mockPersonnel.forEach(person => {
        const personAssignments = result.attributions.filter(a => a.userId === String(person.id));
        
        const weekendAssignments = personAssignments.filter(assignment => {
          const dayOfWeek = assignment.startDate.getDay();
          return dayOfWeek === 0 || dayOfWeek === 6; // Dimanche ou Samedi
        });

        // Compter les weekends uniques
        const weekendDates = new Set(
          weekendAssignments.map(a => {
            const date = new Date(a.startDate);
            const saturday = new Date(date);
            saturday.setDate(date.getDate() - date.getDay() + 6);
            return saturday.toISOString().split('T')[0];
          })
        );

        expect(weekendDates.size).toBeLessThanOrEqual(2); // Max 2 weekends par mois
      });
    });
  });

  describe('Medical Specialty Constraints', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should enforce pediatric anesthesia limitations', async () => {
      const pediatricPersonnel = [
        {
          ...mockPersonnel[1],
          specialite: 'Anesthésie Pédiatrique',
          competences: ['PEDIATRIE', 'NEONATOLOGIE']
        }
      ];

      await generator.initialize(pediatricPersonnel);
      const result = await generator.generate();

      // Personnel pédiatrique ne devrait pas avoir plus d'1 garde consécutive
      const pediatricAssignments = result.attributions.filter(a => 
        a.userId === String(pediatricPersonnel[0].id) && a.shiftType === ShiftType.GARDE_24H
      );

      // Vérifier qu'il n'y a pas de gardes consécutives
      pediatricAssignments.sort((a, b) => a.startDate.getTime() - b.startDate.getTime());
      
      for (let i = 1; i < pediatricAssignments.length; i++) {
        const prevEnd = pediatricAssignments[i - 1].endDate;
        const currentStart = pediatricAssignments[i].startDate;
        const hoursBetween = (currentStart.getTime() - prevEnd.getTime()) / (1000 * 60 * 60);
        
        expect(hoursBetween).toBeGreaterThan(24); // Au moins 24h entre gardes pédiatriques
      }
    });

    it('should enforce cardiac anesthesia weekly hour limits', async () => {
      const cardiacPersonnel = [
        {
          ...mockPersonnel[2],
          specialite: 'Anesthésie Cardiaque'
        }
      ];

      await generator.initialize(cardiacPersonnel);
      const result = await generator.generate();

      // Calculer les heures par semaine pour le personnel cardiaque
      const cardiacAssignments = result.attributions.filter(a => 
        a.userId === String(cardiacPersonnel[0].id)
      );

      // Grouper par semaine
      const weeklyHours = new Map<string, number>();
      
      cardiacAssignments.forEach(assignment => {
        const weekStart = new Date(assignment.startDate);
        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
        const weekKey = weekStart.toISOString().split('T')[0];
        
        const duration = (assignment.endDate.getTime() - assignment.startDate.getTime()) / (1000 * 60 * 60);
        weeklyHours.set(weekKey, (weeklyHours.get(weekKey) || 0) + duration);
      });

      // Vérifier que chaque semaine respecte la limite de 44h
      weeklyHours.forEach((hours, week) => {
        expect(hours).toBeLessThanOrEqual(44);
      });
    });
  });

  describe('MAR/IADE Supervision Rules', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should ensure MAR supervision by IADE', async () => {
      await generator.initialize(mockPersonnel);
      const result = await generator.generate();

      // Trouver toutes les affectations MAR
      const marAssignments = result.attributions.filter(a => {
        const user = mockPersonnel.find(p => String(p.id) === a.userId);
        return user?.role === 'MAR';
      });

      // Chaque affectation MAR devrait avoir une supervision IADE
      marAssignments.forEach(marAssignment => {
        const supervisionExists = result.attributions.some(assignment => {
          const user = mockPersonnel.find(p => String(p.id) === assignment.userId);
          if (user?.role !== 'IADE' || !user.canSupervise) return false;
          
          // Vérifier la superposition temporelle
          const marStart = marAssignment.startDate.getTime();
          const marEnd = marAssignment.endDate.getTime();
          const iadeStart = assignment.startDate.getTime();
          const iadeEnd = assignment.endDate.getTime();
          
          return (iadeStart <= marStart && iadeEnd >= marEnd) || // IADE couvre MAR
                 (iadeStart <= marStart && iadeEnd > marStart) || // Début couvert
                 (iadeStart < marEnd && iadeEnd >= marEnd);      // Fin couverte
        });

        if (!supervisionExists) {
          // Devrait y avoir une violation de supervision
          const supervisionViolations = result.validation.violations.filter(v => 
            v.message.includes('supervision') || v.type === 'SUPERVISION_REQUIRED'
          );
          expect(supervisionViolations.length).toBeGreaterThan(0);
        }
      });
    });

    it('should validate IADE supervisory capacity', async () => {
      const highMarRatio = [
        ...mockPersonnel,
        {
          id: 4,
          nom: 'MAR2',
          prenom: 'Test',
          email: 'mar2@hospital.fr',
          role: 'MAR' as const,
          specialite: 'Anesthésie Générale',
          active: true,
          sites: [1],
          competences: ['BLOC_GENERAL'],
          preferences: { maxGardesMois: 6 },
          contraintes: [],
          weeklyHours: 35,
          isChefEquipe: false,
          requiresSupervision: true
        },
        {
          id: 5,
          nom: 'MAR3',
          prenom: 'Test2',
          email: 'mar3@hospital.fr',
          role: 'MAR' as const,
          specialite: 'Anesthésie Générale',
          active: true,
          sites: [1],
          competences: ['BLOC_GENERAL'],
          preferences: { maxGardesMois: 6 },
          contraintes: [],
          weeklyHours: 35,
          isChefEquipe: false,
          requiresSupervision: true
        }
      ];

      await generator.initialize(highMarRatio);
      const result = await generator.generate();

      // Avec 3 MAR et seulement 2 IADE, il devrait y avoir des violations
      const supervisionViolations = result.validation.violations.filter(v => 
        v.message.includes('supervision') || 
        v.message.includes('capacité') ||
        v.type === 'SUPERVISION_OVERLOAD'
      );

      // Devrait avoir des warnings sur la surcharge de supervision
      expect(supervisionViolations.length).toBeGreaterThan(0);
    });
  });

  describe('Fatigue Score Medical Validation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should prevent critical fatigue accumulation', async () => {
      const highFatigueAssignments: Attribution[] = [
        {
          id: 'fatigue-1',
          userId: '1',
          shiftType: ShiftType.GARDE_24H,
          startDate: new Date('2025-01-01T08:00:00'),
          endDate: new Date('2025-01-02T08:00:00'),
          status: 'VALIDATED',
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'fatigue-2',
          userId: '1',
          shiftType: ShiftType.ASTREINTE_WEEKEND,
          startDate: new Date('2025-01-04T18:00:00'),
          endDate: new Date('2025-01-05T08:00:00'),
          status: 'VALIDATED',
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'fatigue-3',
          userId: '1',
          shiftType: ShiftType.GARDE_24H,
          startDate: new Date('2025-01-06T08:00:00'),
          endDate: new Date('2025-01-07T08:00:00'),
          status: 'VALIDATED',
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];

      await generator.initialize(mockPersonnel, highFatigueAssignments);
      const result = await generator.generate();

      // Vérifier qu'aucune nouvelle affectation ne mène à un score critique
      const fatigueViolations = result.validation.violations.filter(v => 
        v.type === 'FATIGUE' && v.severity === 'ERROR'
      );

      // Les nouvelles affectations ne devraient pas aggraver la fatigue critique
      expect(fatigueViolations.length).toBeLessThan(1);
    });

    it('should provide fatigue recovery periods', async () => {
      await generator.initialize(mockPersonnel);
      const result = await generator.generate();

      // Calculer les périodes de repos pour chaque personne
      mockPersonnel.forEach(person => {
        const assignments = result.attributions
          .filter(a => a.userId === String(person.id))
          .sort((a, b) => a.startDate.getTime() - b.startDate.getTime());

        if (assignments.length > 1) {
          for (let i = 1; i < assignments.length; i++) {
            const prevEnd = assignments[i - 1].endDate;
            const currentStart = assignments[i].startDate;
            const restHours = (currentStart.getTime() - prevEnd.getTime()) / (1000 * 60 * 60);
            
            // Devrait y avoir au moins 11h de repos entre affectations
            expect(restHours).toBeGreaterThanOrEqual(11);
          }
        }
      });
    });
  });

  describe('Weekly Working Time Limits', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should enforce 48-hour weekly limit', async () => {
      await generator.initialize(mockPersonnel);
      const result = await generator.generate();

      // Vérifier la limite hebdomadaire pour chaque personne
      mockPersonnel.forEach(person => {
        const assignments = result.attributions.filter(a => a.userId === String(person.id));
        
        // Grouper par semaine (ISO week)
        const weeklyHours = new Map<string, number>();
        
        assignments.forEach(assignment => {
          const assignmentDate = new Date(assignment.startDate);
          const year = assignmentDate.getFullYear();
          const week = getISOWeek(assignmentDate);
          const weekKey = `${year}-W${week}`;
          
          const duration = (assignment.endDate.getTime() - assignment.startDate.getTime()) / (1000 * 60 * 60);
          weeklyHours.set(weekKey, (weeklyHours.get(weekKey) || 0) + duration);
        });

        // Vérifier que chaque semaine respecte la limite
        weeklyHours.forEach((hours, week) => {
          expect(hours).toBeLessThanOrEqual(48);
        });
      });
    });

    it('should handle overtime violations properly', async () => {
      const overtimeParameters = {
        ...mockParameters,
        etapesActives: [AssignmentType.GARDE, AssignmentType.ASTREINTE, AssignmentType.CONSULTATION],
        forceMaxCoverage: true
      };

      const overtimeGenerator = new PlanningGenerator(overtimeParameters, medicalRulesConfig, fatigueConfig);
      await overtimeGenerator.initialize(mockPersonnel);
      
      const result = await overtimeGenerator.generate();

      // Chercher les violations d'heures supplémentaires
      const overtimeViolations = result.validation.violations.filter(v => 
        v.message.includes('48') || 
        v.message.includes('heures') ||
        v.type === 'WEEKLY_HOUR_LIMIT'
      );

      // S'il y a des violations, elles devraient être flaggées
      if (overtimeViolations.length > 0) {
        expect(overtimeViolations.every(v => v.severity === 'WARNING' || v.severity === 'ERROR')).toBe(true);
      }
    });
  });
});

// Fonction utilitaire pour calculer la semaine ISO
function getISOWeek(date: Date): number {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
  const week1 = new Date(d.getFullYear(), 0, 4);
  return 1 + Math.round(((d.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
}