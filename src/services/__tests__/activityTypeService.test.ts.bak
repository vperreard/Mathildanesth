/**
 * @jest-environment node
 */
import { ActivityTypeService } from '../activityTypeService';
import { prisma } from '@/lib/prisma';
import { 
    ActivityCategory, 
    Period, 
    CreateActivityTypeData, 
    UpdateActivityTypeData 
} from '@/types/activityTypes';

// Mock Prisma
jest.mock('@/lib/prisma', () => ({
    prisma: {
        activityType: {
            findMany: jest.fn(),
            findUnique: jest.fn(),
            findFirst: jest.fn(),
            create: jest.fn(),
            update: jest.fn(),
            delete: jest.fn()
        },
        assignment: {
            count: jest.fn(),
            groupBy: jest.fn(),
            findMany: jest.fn(),
            update: jest.fn()
        },
        affectationModele: {
            count: jest.fn()
        }
    }
}));

const mockPrisma = prisma as jest.Mocked<typeof prisma>;

describe('ActivityTypeService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });


    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    describe('getAllActivityTypes', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const mockActivityTypes = [
            {
                id: '1',
                name: 'Garde de jour',
                category: ActivityCategory.GARDE,
                code: 'GARDE_JOUR',
                isActive: true,
                site: { id: 'site1', name: 'Site 1' },
                _count: { assignments: 5, affectationModeles: 2 },
                createdAt: new Date(),
                updatedAt: new Date()
            },
            {
                id: '2',
                name: 'Consultation',
                category: ActivityCategory.CONSULTATION,
                code: 'CONSULTATION',
                isActive: true,
                site: null,
                _count: { assignments: 3, affectationModeles: 1 },
                createdAt: new Date(),
                updatedAt: new Date()
            }
        ];

        it('should return all activity types without filters', async () => {
            mockPrisma.activityType.findMany.mockResolvedValue(mockActivityTypes);

            const result = await ActivityTypeService.getAllActivityTypes();

            expect(mockPrisma.activityType.findMany).toHaveBeenCalledWith({
                where: {},
                include: {
                    site: true,
                    _count: {
                        select: {
                            assignments: true,
                            affectationModeles: true
                        }
                    }
                },
                orderBy: [
                    { category: 'asc' },
                    { name: 'asc' }
                ]
            });

            expect(result).toEqual(mockActivityTypes);
        });

        it('should filter by siteId', async () => {
            mockPrisma.activityType.findMany.mockResolvedValue([mockActivityTypes[0]]);

            await ActivityTypeService.getAllActivityTypes({ siteId: 'site1' });

            expect(mockPrisma.activityType.findMany).toHaveBeenCalledWith({
                where: { siteId: 'site1' },
                include: expect.any(Object),
                orderBy: expect.any(Array)
            });
        });

        it('should filter by category', async () => {
            mockPrisma.activityType.findMany.mockResolvedValue([mockActivityTypes[0]]);

            await ActivityTypeService.getAllActivityTypes({ category: ActivityCategory.GARDE });

            expect(mockPrisma.activityType.findMany).toHaveBeenCalledWith({
                where: { category: ActivityCategory.GARDE },
                include: expect.any(Object),
                orderBy: expect.any(Array)
            });
        });

        it('should filter by isActive', async () => {
            mockPrisma.activityType.findMany.mockResolvedValue(mockActivityTypes);

            await ActivityTypeService.getAllActivityTypes({ isActive: true });

            expect(mockPrisma.activityType.findMany).toHaveBeenCalledWith({
                where: { isActive: true },
                include: expect.any(Object),
                orderBy: expect.any(Array)
            });
        });

        it('should combine multiple filters', async () => {
            await ActivityTypeService.getAllActivityTypes({
                siteId: 'site1',
                category: ActivityCategory.GARDE,
                isActive: true
            });

            expect(mockPrisma.activityType.findMany).toHaveBeenCalledWith({
                where: {
                    siteId: 'site1',
                    category: ActivityCategory.GARDE,
                    isActive: true
                },
                include: expect.any(Object),
                orderBy: expect.any(Array)
            });
        });
    });

    describe('getActivityTypeById', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const mockActivityType = {
            id: '1',
            name: 'Test Activity',
            category: ActivityCategory.GARDE,
            code: 'TEST',
            isActive: true,
            site: { id: 'site1', name: 'Site 1' },
            _count: { assignments: 2, affectationModeles: 1 }
        };

        it('should return activity type by ID', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(mockActivityType);

            const result = await ActivityTypeService.getActivityTypeById('1');

            expect(mockPrisma.activityType.findUnique).toHaveBeenCalledWith({
                where: { id: '1' },
                include: {
                    site: true,
                    _count: {
                        select: {
                            assignments: true,
                            affectationModeles: true
                        }
                    }
                }
            });

            expect(result).toEqual(mockActivityType);
        });

        it('should return null if activity type not found', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(null);

            const result = await ActivityTypeService.getActivityTypeById('nonexistent');

            expect(result).toBeNull();
        });
    });

    describe('getActivityTypeByCode', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const mockActivityType = {
            id: '1',
            name: 'Test Activity',
            code: 'TEST',
            site: { id: 'site1', name: 'Site 1' }
        };

        it('should find activity type by code', async () => {
            mockPrisma.activityType.findFirst.mockResolvedValue(mockActivityType);

            const result = await ActivityTypeService.getActivityTypeByCode('test');

            expect(mockPrisma.activityType.findFirst).toHaveBeenCalledWith({
                where: {
                    code: 'TEST',
                    siteId: null
                },
                include: {
                    site: true
                }
            });

            expect(result).toEqual(mockActivityType);
        });

        it('should find activity type by code and siteId', async () => {
            mockPrisma.activityType.findFirst.mockResolvedValue(mockActivityType);

            await ActivityTypeService.getActivityTypeByCode('test', 'site1');

            expect(mockPrisma.activityType.findFirst).toHaveBeenCalledWith({
                where: {
                    code: 'TEST',
                    siteId: 'site1'
                },
                include: {
                    site: true
                }
            });
        });

        it('should convert code to uppercase', async () => {
            mockPrisma.activityType.findFirst.mockResolvedValue(null);

            await ActivityTypeService.getActivityTypeByCode('lowercase_code');

            expect(mockPrisma.activityType.findFirst).toHaveBeenCalledWith({
                where: {
                    code: 'LOWERCASE_CODE',
                    siteId: null
                },
                include: {
                    site: true
                }
            });
        });
    });

    describe('createActivityType', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const createData: CreateActivityTypeData = {
            name: 'New Activity',
            category: ActivityCategory.GARDE,
            code: 'NEW_ACT',
            description: 'Test description',
            defaultDurationHours: 8,
            defaultPeriod: Period.JOURNEE_ENTIERE
        };

        const mockCreatedActivityType = {
            id: '1',
            ...createData,
            code: 'NEW_ACT',
            isActive: true,
            siteId: null,
            site: null,
            createdAt: new Date(),
            updatedAt: new Date()
        };

        it('should create new activity type successfully', async () => {
            // Mock code check (no existing)
            mockPrisma.activityType.findFirst.mockResolvedValue(null);
            // Mock creation
            mockPrisma.activityType.create.mockResolvedValue(mockCreatedActivityType);

            const result = await ActivityTypeService.createActivityType(createData);

            expect(mockPrisma.activityType.create).toHaveBeenCalledWith({
                data: {
                    name: 'New Activity',
                    description: 'Test description',
                    category: ActivityCategory.GARDE,
                    color: undefined,
                    icon: undefined,
                    code: 'NEW_ACT',
                    defaultDurationHours: 8,
                    defaultPeriod: Period.JOURNEE_ENTIERE,
                    siteId: null,
                    isActive: true
                },
                include: {
                    site: true
                }
            });

            expect(result).toEqual(mockCreatedActivityType);
        });

        it('should throw error if code already exists', async () => {
            // Mock existing activity type
            mockPrisma.activityType.findFirst.mockResolvedValue({
                id: '2',
                code: 'NEW_ACT'
            });

            await expect(ActivityTypeService.createActivityType(createData))
                .rejects.toThrow('Un type d'activité avec le code "NEW_ACT" existe déjà');

            expect(mockPrisma.activityType.create).not.toHaveBeenCalled();
        });

        it('should convert code to uppercase', async () => {
            const lowercaseData = { ...createData, code: 'lowercase' };
            
            mockPrisma.activityType.findFirst.mockResolvedValue(null);
            mockPrisma.activityType.create.mockResolvedValue(mockCreatedActivityType);

            await ActivityTypeService.createActivityType(lowercaseData);

            expect(mockPrisma.activityType.create).toHaveBeenCalledWith({
                data: expect.objectContaining({
                    code: 'LOWERCASE'
                }),
                include: {
                    site: true
                }
            });
        });
    });

    describe('updateActivityType', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const existingActivityType = {
            id: '1',
            name: 'Existing Activity',
            code: 'EXISTING',
            siteId: 'site1',
            isActive: true
        };

        const updateData: UpdateActivityTypeData = {
            name: 'Updated Activity',
            description: 'Updated description',
            isActive: false
        };

        it('should update activity type successfully', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(existingActivityType);
            mockPrisma.activityType.update.mockResolvedValue({
                ...existingActivityType,
                ...updateData
            });

            const result = await ActivityTypeService.updateActivityType('1', updateData);

            expect(mockPrisma.activityType.update).toHaveBeenCalledWith({
                where: { id: '1' },
                data: {
                    name: 'Updated Activity',
                    description: 'Updated description',
                    isActive: false
                },
                include: {
                    site: true
                }
            });

            expect(result).toEqual({
                ...existingActivityType,
                ...updateData
            });
        });

        it('should throw error if activity type not found', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(null);

            await expect(ActivityTypeService.updateActivityType('nonexistent', updateData))
                .rejects.toThrow('Type d'activité avec l'ID "nonexistent" non trouvé');
        });

        it('should check code uniqueness when updating code', async () => {
            const updateWithCode = { ...updateData, code: 'NEW_CODE' };
            
            mockPrisma.activityType.findUnique.mockResolvedValue(existingActivityType);
            // Mock existing code check - no conflict
            mockPrisma.activityType.findFirst.mockResolvedValue(null);
            mockPrisma.activityType.update.mockResolvedValue({
                ...existingActivityType,
                ...updateWithCode
            });

            await ActivityTypeService.updateActivityType('1', updateWithCode);

            expect(mockPrisma.activityType.update).toHaveBeenCalledWith({
                where: { id: '1' },
                data: expect.objectContaining({
                    code: 'NEW_CODE'
                }),
                include: {
                    site: true
                }
            });
        });

        it('should throw error if new code already exists', async () => {
            const updateWithCode = { code: 'DUPLICATE' };
            
            mockPrisma.activityType.findUnique.mockResolvedValue(existingActivityType);
            // Mock existing code check - conflict
            mockPrisma.activityType.findFirst.mockResolvedValue({
                id: '2',
                code: 'DUPLICATE'
            });

            await expect(ActivityTypeService.updateActivityType('1', updateWithCode))
                .rejects.toThrow('Un autre type d'activité avec le code "DUPLICATE" existe déjà');
        });
    });

    describe('deleteActivityType', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const existingActivityType = {
            id: '1',
            name: 'To Delete',
            code: 'DELETE_ME'
        };

        it('should delete activity type successfully', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(existingActivityType);
            mockPrisma.assignment.count.mockResolvedValue(0);
            mockPrisma.affectationModele.count.mockResolvedValue(0);
            mockPrisma.activityType.delete.mockResolvedValue(existingActivityType);

            await ActivityTypeService.deleteActivityType('1');

            expect(mockPrisma.activityType.delete).toHaveBeenCalledWith({
                where: { id: '1' }
            });
        });

        it('should throw error if activity type not found', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(null);

            await expect(ActivityTypeService.deleteActivityType('nonexistent'))
                .rejects.toThrow('Type d'activité avec l'ID "nonexistent" non trouvé');
        });

        it('should throw error if activity type has assignments', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(existingActivityType);
            mockPrisma.assignment.count.mockResolvedValue(5);
            mockPrisma.affectationModele.count.mockResolvedValue(0);

            await expect(ActivityTypeService.deleteActivityType('1'))
                .rejects.toThrow('Impossible de supprimer ce type d'activité car il est utilisé dans 5 affectation(s) et 0 modèle(s)');
        });

        it('should throw error if activity type has models', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(existingActivityType);
            mockPrisma.assignment.count.mockResolvedValue(0);
            mockPrisma.affectationModele.count.mockResolvedValue(3);

            await expect(ActivityTypeService.deleteActivityType('1'))
                .rejects.toThrow('Impossible de supprimer ce type d'activité car il est utilisé dans 0 affectation(s) et 3 modèle(s)');
        });
    });

    describe('toggleActivityType', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should toggle active status from true to false', async () => {
            const activeType = { id: '1', isActive: true };
            
            mockPrisma.activityType.findUnique.mockResolvedValue(activeType);
            mockPrisma.activityType.findFirst.mockResolvedValue(null); // for code check
            mockPrisma.activityType.update.mockResolvedValue({ ...activeType, isActive: false });

            const result = await ActivityTypeService.toggleActivityType('1');

            expect(result.isActive).toBe(false);
        });

        it('should toggle active status from false to true', async () => {
            const inactiveType = { id: '1', isActive: false };
            
            mockPrisma.activityType.findUnique.mockResolvedValue(inactiveType);
            mockPrisma.activityType.findFirst.mockResolvedValue(null);
            mockPrisma.activityType.update.mockResolvedValue({ ...inactiveType, isActive: true });

            const result = await ActivityTypeService.toggleActivityType('1');

            expect(result.isActive).toBe(true);
        });

        it('should throw error if activity type not found', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(null);

            await expect(ActivityTypeService.toggleActivityType('nonexistent'))
                .rejects.toThrow('Type d'activité avec l'ID "nonexistent" non trouvé');
        });
    });

    describe('getActivityTypeStats', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const mockActivityType = {
            id: '1',
            name: 'Test Activity'
        };

        it('should return stats for existing activity type', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(mockActivityType);
            mockPrisma.assignment.count
                .mockResolvedValueOnce(10) // total assignments
                .mockResolvedValueOnce(5); // active assignments
            
            mockPrisma.assignment.groupBy
                .mockResolvedValueOnce([
                    { date: new Date('2024-01-15'), _count: { id: 2 } },
                    { date: new Date('2024-02-10'), _count: { id: 3 } }
                ])
                .mockResolvedValueOnce([
                    { period: Period.MATIN, _count: { id: 8 } },
                    { period: Period.APRES_MIDI, _count: { id: 2 } }
                ]);

            const result = await ActivityTypeService.getActivityTypeStats('1');

            expect(result).toEqual({
                activityTypeId: '1',
                activityTypeName: 'Test Activity',
                totalAssignments: 10,
                activeAssignments: 5,
                mostUsedPeriod: Period.MATIN,
                usageByMonth: {
                    '2024-01': 2,
                    '2024-02': 3
                }
            });
        });

        it('should return null if activity type not found', async () => {
            mockPrisma.activityType.findUnique.mockResolvedValue(null);

            const result = await ActivityTypeService.getActivityTypeStats('nonexistent');

            expect(result).toBeNull();
        });
    });

    describe('getActivityTypesByCategory', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should group activity types by category', async () => {
            const mockActivityTypes = [
                { id: '1', category: ActivityCategory.GARDE, name: 'Garde' },
                { id: '2', category: ActivityCategory.CONSULTATION, name: 'Consultation' },
                { id: '3', category: ActivityCategory.GARDE, name: 'Garde Nuit' }
            ];

            mockPrisma.activityType.findMany.mockResolvedValue(mockActivityTypes);

            const result = await ActivityTypeService.getActivityTypesByCategory();

            expect(result[ActivityCategory.GARDE]).toHaveLength(2);
            expect(result[ActivityCategory.CONSULTATION]).toHaveLength(1);
            expect(result[ActivityCategory.BLOC_OPERATOIRE]).toHaveLength(0);
            expect(result[ActivityCategory.ASTREINTE]).toHaveLength(0);
            expect(result[ActivityCategory.REUNION]).toHaveLength(0);
            expect(result[ActivityCategory.FORMATION]).toHaveLength(0);
            expect(result[ActivityCategory.ADMINISTRATIF]).toHaveLength(0);
            expect(result[ActivityCategory.AUTRE]).toHaveLength(0);
        });
    });

    describe('migrateOldAssignments', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should migrate assignments successfully', async () => {
            const mockActivityTypes = [
                { id: 'type1', code: 'GARDE', name: 'Garde' },
                { id: 'type2', code: 'CONSULT', name: 'Consultation' }
            ];

            const mockAssignments = [
                { id: 'assign1', type: 'GARDE' },
                { id: 'assign2', type: 'consult' },
                { id: 'assign3', type: 'UNKNOWN' }
            ];

            // Mock getAllActivityTypes call
            mockPrisma.activityType.findMany.mockResolvedValue(mockActivityTypes);
            // Mock assignments to migrate
            mockPrisma.assignment.findMany.mockResolvedValue(mockAssignments);
            // Mock update success
            mockPrisma.assignment.update.mockResolvedValue({});

            const result = await ActivityTypeService.migrateOldAssignments();

            expect(result.migrated).toBe(2);
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]).toContain('Type non mappé: UNKNOWN');
            expect(mockPrisma.assignment.update).toHaveBeenCalledTimes(2);
        });

        it('should handle migration errors', async () => {
            const mockActivityTypes = [
                { id: 'type1', code: 'GARDE', name: 'Garde' }
            ];

            const mockAssignments = [
                { id: 'assign1', type: 'GARDE' }
            ];

            mockPrisma.activityType.findMany.mockResolvedValue(mockActivityTypes);
            mockPrisma.assignment.findMany.mockResolvedValue(mockAssignments);
            mockPrisma.assignment.update.mockRejectedValue(new Error('Database error'));

            const result = await ActivityTypeService.migrateOldAssignments();

            expect(result.migrated).toBe(0);
            expect(result.errors).toHaveLength(1);
            expect(result.errors[0]).toContain('Erreur migration Assignment assign1');
        });
    });
});