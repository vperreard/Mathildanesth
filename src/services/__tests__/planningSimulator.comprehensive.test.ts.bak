import { jest, describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { setupTestEnvironment, cleanupTestEnvironment, createMockPrismaClient } from '../../test-utils/standardMocks';
import {
  createTestUser,
  createMedicalTeam,
  createTestAssignment,
  createPerformanceTestData,
  createConflictScenario,
  createBusinessRules,
} from '../../test-utils/planningFactories';
import { PlanningSimulator, PlanningSimulation, SimulationMetrics } from '../planningSimulator';
import { GenerationParameters, Attribution, AssignmentType } from '../../types/assignment';
import { RulesConfiguration, FatigueConfig, defaultRulesConfiguration, defaultFatigueConfig } from '../../types/rules';
import { ShiftType } from '../../types/common';
import { WeekType } from '../../types/user';

// Mock PlanningGenerator
jest.mock('../planningGenerator', () => ({
  PlanningGenerator: jest.fn().mockImplementation(() => ({
    initialize: jest.fn().mockResolvedValue(undefined),
    generateFullPlanning: jest.fn().mockResolvedValue({
      success: true,
      metrics: {
        equiteScore: 0.85,
        fatigueScore: 0.75,
        satisfactionScore: 0.90,
      },
      ruleViolations: [],
    }),
    getResults: jest.fn().mockReturnValue({
      gardes: [],
      astreintes: [],
      consultations: [],
      blocs: [],
    }),
  })),
}));

/**
 * Tests compréhensifs pour PlanningSimulator
 * Couvre toutes les fonctionnalités de simulation de planning médical
 */

describe('PlanningSimulator - Comprehensive Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  let planningSimulator: PlanningSimulator;
  let mockParameters: GenerationParameters;
  let medicalTeam: ReturnType<typeof createMedicalTeam>;
  let existingAssignments: Attribution[];

  beforeEach(() => {
    jest.clearAllMocks();
    setupTestEnvironment();
    
    // Configuration de base pour la simulation
    mockParameters = {
      startDate: '2025-01-15',
      endDate: '2025-01-21',
      generateGardes: true,
      generateAstreintes: true,
      generateConsultations: true,
      generateBlocs: false,
      siteId: 'site-simulation',
      optimizationLevel: 'BALANCED',
      respectIndisponibilites: true,
      autoBalance: true,
      prioritizeExperience: true,
      allowOvertime: false,
    };

    medicalTeam = createMedicalTeam(8);
    
    existingAssignments = [
      createTestAssignment({
        userId: medicalTeam[0].id,
        shiftType: ShiftType.GARDE_24H,
        startDate: '2025-01-10',
      }),
      createTestAssignment({
        userId: medicalTeam[1].id,
        shiftType: ShiftType.ASTREINTE,
        startDate: '2025-01-12',
      }),
    ];

    planningSimulator = new PlanningSimulator(mockParameters, medicalTeam, existingAssignments);
  });

  afterEach(() => {
    cleanupTestEnvironment();
  });

  describe('Simulation Creation and Management', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should create a new simulation with default parameters', async () => {
      const simulationId = await planningSimulator.generateSimulation(
        'Test Simulation',
        'Basic simulation test'
      );

      expect(simulationId).toBeDefined();
      expect(simulationId).toMatch(/^sim_\d+_[a-z0-9]+$/);

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.name).toBe('Test Simulation');
      expect(simulation!.description).toBe('Basic simulation test');
      expect(simulation!.parameters).toEqual(mockParameters);
    });

    it('should create simulation with parameter overrides', async () => {
      const parameterOverrides = {
        generateBlocs: true,
        optimizationLevel: 'OPTIMAL' as const,
        allowOvertime: true,
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Override Simulation',
        'Simulation with parameter overrides',
        parameterOverrides
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.parameters.generateBlocs).toBe(true);
      expect(simulation!.parameters.optimizationLevel).toBe('OPTIMAL');
      expect(simulation!.parameters.allowOvertime).toBe(true);
      expect(simulation!.parameters.siteId).toBe(mockParameters.siteId); // Should keep base values
    });

    it('should create simulation with rules configuration overrides', async () => {
      const rulesOverrides: Partial<RulesConfiguration> = {
        maxConsecutiveGardes: 3,
        minDaysBetweenGardes: 2,
        maxHoursPerWeek: 50,
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Rules Override Simulation',
        'Simulation with custom rules',
        {},
        rulesOverrides
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.rulesConfiguration.maxConsecutiveGardes).toBe(3);
      expect(simulation!.rulesConfiguration.minDaysBetweenGardes).toBe(2);
      expect(simulation!.rulesConfiguration.maxHoursPerWeek).toBe(50);
    });

    it('should create simulation with fatigue configuration overrides', async () => {
      const fatigueOverrides: Partial<FatigueConfig> = {
        enabled: true,
        maxFatigueScore: 40,
        points: {
          garde: 12,
          astreinte: 6,
          astreinteWeekendFerie: 10,
        },
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Fatigue Override Simulation',
        'Simulation with custom fatigue config',
        {},
        {},
        fatigueOverrides
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.fatigueConfig.enabled).toBe(true);
      expect(simulation!.fatigueConfig.maxFatigueScore).toBe(40);
      expect(simulation!.fatigueConfig.points?.garde).toBe(12);
    });

    it('should manage multiple simulations simultaneously', async () => {
      const sim1Id = await planningSimulator.generateSimulation('Simulation 1', 'First test');
      const sim2Id = await planningSimulator.generateSimulation('Simulation 2', 'Second test');
      const sim3Id = await planningSimulator.generateSimulation('Simulation 3', 'Third test');

      expect(sim1Id).not.toBe(sim2Id);
      expect(sim2Id).not.toBe(sim3Id);

      const allSimulations = planningSimulator.getAllSimulations();
      expect(allSimulations).toHaveLength(3);

      const simulationNames = allSimulations.map(s => s.name);
      expect(simulationNames).toContain('Simulation 1');
      expect(simulationNames).toContain('Simulation 2');
      expect(simulationNames).toContain('Simulation 3');
    });

    it('should delete simulations correctly', async () => {
      const sim1Id = await planningSimulator.generateSimulation('To Keep', 'Keep this one');
      const sim2Id = await planningSimulator.generateSimulation('To Delete', 'Delete this one');

      expect(planningSimulator.getAllSimulations()).toHaveLength(2);

      const deleted = planningSimulator.deleteSimulation(sim2Id);
      expect(deleted).toBe(true);

      expect(planningSimulator.getAllSimulations()).toHaveLength(1);
      expect(planningSimulator.getSimulation(sim1Id)).toBeDefined();
      expect(planningSimulator.getSimulation(sim2Id)).toBeUndefined();

      // Try to delete non-existent simulation
      const deletedAgain = planningSimulator.deleteSimulation('non-existent');
      expect(deletedAgain).toBe(false);
    });
  });

  describe('Medical Scenario Simulations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should simulate weekend coverage scenarios', async () => {
      const weekendParams = {
        startDate: '2025-01-18', // Samedi
        endDate: '2025-01-19',   // Dimanche
        prioritizeWeekendExperience: true,
        minimumMAROnDuty: 2,
        minimumIADEOnDuty: 3,
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Weekend Coverage Test',
        'Test weekend medical coverage requirements',
        weekendParams
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.parameters.prioritizeWeekendExperience).toBe(true);
      expect(simulation!.validation.success).toBe(true);
    });

    it('should simulate emergency surge capacity planning', async () => {
      const surgeParams = {
        emergencyMode: true,
        surgeCoverageMultiplier: 1.5,
        allowExtendedShifts: true,
        emergencyCallInEnabled: true,
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Emergency Surge Simulation',
        'Simulate emergency surge capacity planning',
        surgeParams
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.parameters.emergencyMode).toBe(true);
      expect(simulation!.parameters.allowExtendedShifts).toBe(true);
    });

    it('should simulate staff shortage scenarios', async () => {
      const shortageTeam = medicalTeam.slice(0, 4); // Reduced team size
      const shortageSimulator = new PlanningSimulator(mockParameters, shortageTeam, existingAssignments);

      const shortageParams = {
        minimumStaffingMode: true,
        allowConsecutiveShifts: true,
        extendedShiftDuration: 36, // hours
      };

      const simulationId = await shortageSimulator.generateSimulation(
        'Staff Shortage Simulation',
        'Simulate planning with reduced staff',
        shortageParams
      );

      const simulation = shortageSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.parameters.minimumStaffingMode).toBe(true);
    });

    it('should simulate cross-training optimization scenarios', async () => {
      const crossTrainedTeam = medicalTeam.map(user => ({
        ...user,
        competences: [
          ...(user.competences || []),
          'MULTI_SPECIALITE',
          'CROSS_TRAINING'
        ],
        crossTrainingLevel: user.id % 3 === 0 ? 'ADVANCED' : 'BASIC',
      }));

      const crossTrainingSimulator = new PlanningSimulator(
        mockParameters, 
        crossTrainedTeam, 
        existingAssignments
      );

      const crossTrainingParams = {
        enableCrossTraining: true,
        crossTrainingPriority: 'HIGH',
        skillDiversificationBonus: 0.2,
      };

      const simulationId = await crossTrainingSimulator.generateSimulation(
        'Cross-Training Optimization',
        'Optimize schedule using cross-trained staff',
        crossTrainingParams
      );

      const simulation = crossTrainingSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.parameters.enableCrossTraining).toBe(true);
    });
  });

  describe('Rules and Constraints Simulation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should simulate strict compliance rules', async () => {
      const strictRules: Partial<RulesConfiguration> = {
        maxConsecutiveGardes: 1,
        minDaysBetweenGardes: 3,
        maxHoursPerWeek: 40,
        minRestHoursBetweenShifts: 12,
        strictWeekendRules: true,
        enforceVacationRequests: true,
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Strict Compliance Simulation',
        'Test with very strict compliance rules',
        {},
        strictRules
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.rulesConfiguration.maxConsecutiveGardes).toBe(1);
      expect(simulation!.rulesConfiguration.minDaysBetweenGardes).toBe(3);
      expect(simulation!.rulesConfiguration.strictWeekendRules).toBe(true);
    });

    it('should simulate flexible rules for emergency situations', async () => {
      const flexibleRules: Partial<RulesConfiguration> = {
        maxConsecutiveGardes: 5,
        minDaysBetweenGardes: 0,
        maxHoursPerWeek: 60,
        allowEmergencyOverrides: true,
        flexibleRestPeriods: true,
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Flexible Emergency Rules',
        'Test with flexible rules for emergency situations',
        {},
        flexibleRules
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.rulesConfiguration.maxConsecutiveGardes).toBe(5);
      expect(simulation!.rulesConfiguration.allowEmergencyOverrides).toBe(true);
    });

    it('should simulate fatigue-focused planning', async () => {
      const fatigueFocus: Partial<FatigueConfig> = {
        enabled: true,
        maxFatigueScore: 20, // Very low threshold
        resetPeriodDays: 3,   // Quick reset
        points: {
          garde: 20,          // High fatigue impact
          astreinte: 10,
          astreinteWeekendFerie: 15,
        },
        fatigueRecoveryRate: 5, // Fast recovery
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Fatigue-Focused Planning',
        'Prioritize fatigue management in planning',
        {},
        {},
        fatigueFocus
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.fatigueConfig.maxFatigueScore).toBe(20);
      expect(simulation!.fatigueConfig.points?.garde).toBe(20);
    });
  });

  describe('Performance and Optimization Simulations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should simulate different optimization levels', async () => {
      const optimizationLevels = ['BASIC', 'BALANCED', 'OPTIMAL', 'PERFORMANCE'] as const;
      const simulationIds: string[] = [];

      for (const level of optimizationLevels) {
        const simulationId = await planningSimulator.generateSimulation(
          `Optimization ${level}`,
          `Test ${level} optimization level`,
          { optimizationLevel: level }
        );
        simulationIds.push(simulationId);
      }

      expect(simulationIds).toHaveLength(4);

      // Verify each simulation has correct optimization level
      simulationIds.forEach((id, index) => {
        const simulation = planningSimulator.getSimulation(id);
        expect(simulation).toBeDefined();
        expect(simulation!.parameters.optimizationLevel).toBe(optimizationLevels[index]);
      });
    });

    it('should simulate large-scale hospital planning', async () => {
      const largeTeam = Array.from({ length: 30 }, (_, i) => 
        createTestUser({
          id: i + 1,
          role: i % 3 === 0 ? 'MAR' : 'IADE',
          nom: `User${i + 1}`,
          prenom: 'Test',
        })
      );

      const largeHospitalSimulator = new PlanningSimulator(
        {
          ...mockParameters,
          startDate: '2025-01-01',
          endDate: '2025-01-31', // Full month
        },
        largeTeam,
        []
      );

      const startTime = performance.now();
      const simulationId = await largeHospitalSimulator.generateSimulation(
        'Large Hospital Simulation',
        'Test large-scale hospital planning performance'
      );
      const endTime = performance.now();

      expect(simulationId).toBeDefined();
      expect(endTime - startTime).toBeLessThan(15000); // Should complete within 15 seconds

      const simulation = largeHospitalSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.validation.success).toBe(true);
    });

    it('should simulate memory-efficient planning', async () => {
      const yearLongParams = {
        ...mockParameters,
        startDate: '2025-01-01',
        endDate: '2025-12-31', // Full year
        memoryOptimization: true,
        batchProcessing: true,
      };

      const memBefore = process.memoryUsage();
      const simulationId = await planningSimulator.generateSimulation(
        'Year-Long Planning',
        'Test memory efficiency for long-term planning',
        yearLongParams
      );
      const memAfter = process.memoryUsage();

      expect(simulationId).toBeDefined();
      
      const memIncrease = memAfter.heapUsed - memBefore.heapUsed;
      expect(memIncrease).toBeLessThan(150 * 1024 * 1024); // Less than 150MB increase

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
    });
  });

  describe('Simulation Comparison and Analysis', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should calculate detailed metrics for simulations', async () => {
      const sim1Id = await planningSimulator.generateSimulation(
        'Conservative Planning',
        'Conservative approach'
      );

      const sim2Id = await planningSimulator.generateSimulation(
        'Aggressive Planning',
        'Aggressive optimization',
        { optimizationLevel: 'OPTIMAL', allowOvertime: true }
      );

      const metrics1 = planningSimulator.calculateMetrics(sim1Id);
      const metrics2 = planningSimulator.calculateMetrics(sim2Id);

      expect(metrics1).toBeDefined();
      expect(metrics2).toBeDefined();

      expect(metrics1!.equityScore).toBeGreaterThanOrEqual(0);
      expect(metrics1!.equityScore).toBeLessThanOrEqual(1);
      expect(metrics1!.fatigueScore).toBeGreaterThanOrEqual(0);
      expect(metrics1!.satisfactionScore).toBeGreaterThanOrEqual(0);

      expect(metrics2!.assignmentCounts.total).toBeDefined();
      expect(metrics2!.ruleViolationsCount.total).toBeDefined();
    });

    it('should compare multiple simulation scenarios', async () => {
      const scenarios = [
        {
          name: 'Baseline',
          params: {},
          rules: {},
          fatigue: {},
        },
        {
          name: 'High Experience Priority',
          params: { prioritizeExperience: true },
          rules: { experienceWeighting: 0.8 },
          fatigue: {},
        },
        {
          name: 'Fatigue Minimization',
          params: {},
          rules: {},
          fatigue: { enabled: true, maxFatigueScore: 15 },
        },
      ];

      const simulationIds: string[] = [];

      for (const scenario of scenarios) {
        const id = await planningSimulator.generateSimulation(
          scenario.name,
          `Scenario: ${scenario.name}`,
          scenario.params,
          scenario.rules,
          scenario.fatigue
        );
        simulationIds.push(id);
      }

      expect(simulationIds).toHaveLength(3);

      // Compare all scenarios
      const comparison = planningSimulator.compareSimulations(simulationIds);
      
      expect(comparison).toBeDefined();
      expect(comparison.scenarios).toHaveLength(3);
      expect(comparison.metrics).toBeDefined();
      expect(comparison.recommendations).toBeDefined();
    });

    it('should export simulation results for analysis', async () => {
      const simulationId = await planningSimulator.generateSimulation(
        'Export Test',
        'Test simulation export functionality'
      );

      const exportData = planningSimulator.exportSimulation(simulationId);
      
      expect(exportData).toBeDefined();
      expect(exportData.simulation).toBeDefined();
      expect(exportData.metrics).toBeDefined();
      expect(exportData.exportTimestamp).toBeDefined();
      
      expect(exportData.simulation.id).toBe(simulationId);
      expect(exportData.simulation.name).toBe('Export Test');
    });
  });

  describe('Error Handling and Edge Cases', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle invalid simulation parameters gracefully', async () => {
      const invalidParams = {
        startDate: '2025-01-31',
        endDate: '2025-01-01', // End before start
        generateGardes: false,
        generateAstreintes: false,
        generateConsultations: false,
        generateBlocs: false, // Nothing to generate
      };

      await expect(
        planningSimulator.generateSimulation(
          'Invalid Parameters',
          'Test with invalid parameters',
          invalidParams
        )
      ).rejects.toThrow();
    });

    it('should handle empty team scenarios', async () => {
      const emptyTeamSimulator = new PlanningSimulator(mockParameters, [], []);

      const simulationId = await emptyTeamSimulator.generateSimulation(
        'Empty Team',
        'Test with no personnel'
      );

      const simulation = emptyTeamSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.validation.success).toBe(false);
      expect(simulation!.validation.warnings).toBeDefined();
    });

    it('should handle conflicting rules configurations', async () => {
      const conflictingRules: Partial<RulesConfiguration> = {
        maxConsecutiveGardes: 0, // Impossible value
        minDaysBetweenGardes: -1, // Invalid value
        maxHoursPerWeek: 200,     // Unrealistic value
      };

      const simulationId = await planningSimulator.generateSimulation(
        'Conflicting Rules',
        'Test with conflicting rules',
        {},
        conflictingRules
      );

      const simulation = planningSimulator.getSimulation(simulationId);
      expect(simulation).toBeDefined();
      expect(simulation!.validation.warnings?.length).toBeGreaterThan(0);
    });

    it('should handle simulation cleanup and memory management', async () => {
      // Create many simulations
      const simulationIds: string[] = [];
      for (let i = 0; i < 10; i++) {
        const id = await planningSimulator.generateSimulation(
          `Test Simulation ${i}`,
          `Test simulation number ${i}`
        );
        simulationIds.push(id);
      }

      expect(planningSimulator.getAllSimulations()).toHaveLength(10);

      // Clean up half of them
      for (let i = 0; i < 5; i++) {
        planningSimulator.deleteSimulation(simulationIds[i]);
      }

      expect(planningSimulator.getAllSimulations()).toHaveLength(5);

      // Clean up all remaining
      planningSimulator.clearAllSimulations();
      expect(planningSimulator.getAllSimulations()).toHaveLength(0);
    });

    it('should validate simulation consistency', async () => {
      const simulationId = await planningSimulator.generateSimulation(
        'Consistency Test',
        'Test simulation consistency validation'
      );

      const validation = planningSimulator.validateSimulation(simulationId);
      
      expect(validation).toBeDefined();
      expect(validation.isConsistent).toBeDefined();
      expect(validation.inconsistencies).toBeDefined();
      expect(validation.recommendations).toBeDefined();
    });
  });
});