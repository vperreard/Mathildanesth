/**
 * @jest-environment node
 */
/**
 * @jest-environment node
 */
import { jest, describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
import { 
  setupTestEnvironment, 
  cleanupTestEnvironment, 
  createMockPrismaClient,
  createMockBcrypt,
  createMockJWT,
  createMockLogger,
  testDataFactories 
} from '../../test-utils/standardMocks';


// Mock external dependencies
jest.mock('@/lib/prisma', () => ({
  prisma: createMockPrismaClient()
}));

jest.mock('bcryptjs', () => createMockBcrypt());
jest.mock('jsonwebtoken', () => createMockJWT());
jest.mock('@/lib/logger', () => ({
  logger: createMockLogger()
}));

const mockPrisma = require('@/lib/prisma').prisma;
const mockBcrypt = require('bcryptjs');
const mockJwt = require('jsonwebtoken');
const mockLogger = require('@/lib/logger').logger;



// Mock dependencies
jest.mock('socket.io-client');
jest.mock('react-toastify');

const mockSocket = {
  on: jest.fn(),
  off: jest.fn(),
  emit: jest.fn(),
  connect: jest.fn(),
  disconnect: jest.fn(),
  connected: true,
};

const mockIo = jest.fn().mockReturnValue(mockSocket);
jest.doMock('socket.io-client', () => ({
  io: mockIo,
  Socket: jest.fn()
}));

jest.doMock('react-toastify', () => ({
  toast: {
    success: jest.fn(),
    error: jest.fn(),
    info: jest.fn(),
    warning: jest.fn()
  }
}));

// Import after mocking
import { notificationService } from '../notificationService';

// Get mocked versions for tests
const io = mockIo;
const toast = require('react-toastify').toast;

describe('NotificationService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    // Reset notification service for testing
    notificationService.resetForTesting();
  });

  const mockNotification = {
    id: '1',
    type: 'info' as const,
    title: 'Test Notification',
    message: 'This is a test',
    createdAt: new Date(),
  };

  describe('Initialization', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait initialiser la connexion socket', () => {
      // Socket should be initialized on service creation
      expect(io).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          path: '/api/ws',
          reconnection: true,
          reconnectionAttempts: 5,
          reconnectionDelay: 1000,
        })
      );
    });

    it('devrait configurer les listeners socket', () => {
      expect(mockSocket.on).toHaveBeenCalledWith('connect', expect.any(Function));
      expect(mockSocket.on).toHaveBeenCalledWith('disconnect', expect.any(Function));
      expect(mockSocket.on).toHaveBeenCalledWith('notification', expect.any(Function));
    });
  });

  describe('Subscribe/Unsubscribe', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait permettre de s'abonner aux notifications', () => {
      const callback = jest.fn();
      const unsubscribe = notificationService.subscribe('info', callback);

      // Simulate receiving a notification
      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      notificationHandler(mockNotification);

      expect(callback).toHaveBeenCalledWith(mockNotification);
      
      // Cleanup
      unsubscribe();
    });

    it('devrait permettre de se désabonner', () => {
      const callback = jest.fn();
      const unsubscribe = notificationService.subscribe('info', callback);
      
      unsubscribe();

      // Simulate receiving a notification after unsubscribe
      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      notificationHandler(mockNotification);

      expect(callback).not.toHaveBeenCalled();
    });

    it('devrait permettre plusieurs abonnements au même type', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();

      notificationService.subscribe('info', callback1);
      notificationService.subscribe('info', callback2);

      // Simulate receiving a notification
      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      notificationHandler(mockNotification);

      expect(callback1).toHaveBeenCalledWith(mockNotification);
      expect(callback2).toHaveBeenCalledWith(mockNotification);
    });
  });

  describe('Send Notification', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait envoyer une notification via socket', () => {
      const notification = {
        type: 'success' as const,
        title: 'Success',
        message: 'Operation completed',
      };

      notificationService.sendNotification(notification);

      expect(mockSocket.emit).toHaveBeenCalledWith(
        'sendNotification',
        expect.objectContaining({
          ...notification,
          id: expect.any(String),
          createdAt: expect.any(Date),
        })
      );
    });

    it('ne devrait pas envoyer si socket déconnecté', () => {
      mockSocket.connected = false;

      notificationService.sendNotification({
        type: 'error' as const,
        title: 'Error',
        message: 'Something went wrong',
      });

      expect(mockSocket.emit).not.toHaveBeenCalled();

      // Reset
      mockSocket.connected = true;
    });
  });

  describe('Handle Notification', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait afficher une notification toast', () => {
      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      notificationHandler(mockNotification);

      expect(toast.info).toHaveBeenCalledWith(
        mockNotification.message,
        expect.objectContaining({
          position: "top-right",
          autoClose: 5000,
          hideProgressBar: false,
          closeOnClick: true,
          pauseOnHover: true,
          draggable: true,
        })
      );
    });

    it('devrait utiliser le bon type de toast', () => {
      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      const notifications = [
        { ...mockNotification, type: 'success' as const },
        { ...mockNotification, type: 'warning' as const },
        { ...mockNotification, type: 'error' as const },
      ];

      notifications.forEach(notification => {
        notificationHandler(notification);
        expect(toast[notification.type]).toHaveBeenCalled();
      });
    });
  });

  describe('Connection Events', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait logger la connexion', () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
      
      const connectHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'connect'
      )?.[1];

      connectHandler();

      expect(consoleSpy).toHaveBeenCalledWith('Connecté au serveur de notifications');
      
      consoleSpy.mockRestore();
    });

    it('devrait logger la déconnexion', () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
      
      const disconnectHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'disconnect'
      )?.[1];

      disconnectHandler();

      expect(consoleSpy).toHaveBeenCalledWith('Déconnecté du serveur de notifications');
      
      consoleSpy.mockRestore();
    });
  });

  describe('Notification Types', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait gérer les notifications de congés', () => {
      const callback = jest.fn();
      notificationService.subscribe('info', callback);

      const leaveNotification = {
        ...mockNotification,
        data: {
          leaveId: '123',
          userId: '456',
          leaveType: 'ANNUAL',
          status: 'APPROVED',
          startDate: '2025-02-01',
          endDate: '2025-02-15',
        },
      };

      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      notificationHandler(leaveNotification);

      expect(callback).toHaveBeenCalledWith(leaveNotification);
    });

    it('devrait gérer les notifications d'affectation', () => {
      const callback = jest.fn();
      notificationService.subscribe('info', callback);

      const assignmentNotification = {
        ...mockNotification,
        data: {
          assignmentId: '789',
          userId: '456',
          date: '2025-01-15',
          shiftType: 'MORNING',
          location: 'OR-1',
        },
      };

      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      notificationHandler(assignmentNotification);

      expect(callback).toHaveBeenCalledWith(assignmentNotification);
    });

    it('devrait gérer les notifications système', () => {
      const callback = jest.fn();
      notificationService.subscribe('info', callback);

      const systemNotification = {
        ...mockNotification,
        data: {
          component: 'PlanningModule',
          action: 'GENERATION_COMPLETE',
          timestamp: new Date().toISOString(),
          metadata: {
            duration: 1500,
            recordsProcessed: 100,
          },
        },
      };

      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      notificationHandler(systemNotification);

      expect(callback).toHaveBeenCalledWith(systemNotification);
    });
  });

  describe('Error Handling', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait continuer à fonctionner si toast échoue', () => {
      (toast.error as jest.Mock).mockImplementation(() => {
        throw new Error('Toast failed');
      });

      const callback = jest.fn();
      notificationService.subscribe('error', callback);

      const errorNotification = {
        ...mockNotification,
        type: 'error' as const,
      };

      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      // Should not throw
      expect(() => notificationHandler(errorNotification)).not.toThrow();
      
      // Callback should still be called
      expect(callback).toHaveBeenCalledWith(errorNotification);
    });
  });

  describe('Performance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait gérer de nombreux abonnements efficacement', () => {
      const callbacks = Array.from({ length: 100 }, () => jest.fn());
      
      callbacks.forEach(callback => {
        notificationService.subscribe('info', callback);
      });

      const notificationHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'notification'
      )?.[1];

      const start = Date.now();
      notificationHandler(mockNotification);
      const duration = Date.now() - start;

      expect(duration).toBeLessThan(10); // Should complete within 10ms
      
      callbacks.forEach(callback => {
        expect(callback).toHaveBeenCalledWith(mockNotification);
      });
    });
  });
});