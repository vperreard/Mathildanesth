/**
 * @jest-environment node
 */
import { 
  LogLevel,
  Logger,
  createLogger,
  log,
  logError,
  logWarning,
  logInfo,
  logDebug,
  LoggerService
} from '../loggerService';

// Mock winston
jest.mock('winston', () => ({
  createLogger: jest.fn(() => ({
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn(),
    verbose: jest.fn(),
    add: jest.fn()
  })),
  format: {
    combine: jest.fn(),
    timestamp: jest.fn(),
    json: jest.fn(),
    colorize: jest.fn(),
    simple: jest.fn()
  },
  transports: {
    Console: jest.fn()
  }
}));

jest.mock('winston-daily-rotate-file', () => {
  return jest.fn();
});

// Mock console methods
const originalConsole = { ...console };

describe('loggerService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });


  let mockWinstonLogger: any;

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset all mocks
    jest.clearAllMocks();
    
    // Get winston mock and setup fresh instance
    const winston = require('winston');
    mockWinstonLogger = {
      error: jest.fn(),
      warn: jest.fn(),
      info: jest.fn(),
      debug: jest.fn(),
      verbose: jest.fn(),
      add: jest.fn()
    };
    winston.createLogger.mockReturnValue(mockWinstonLogger);

    // Mock console methods
    console.log = jest.fn();
    console.error = jest.fn();
    console.warn = jest.fn();
    console.info = jest.fn();
    console.debug = jest.fn();
  });

  afterEach(() => {
    // Restore original console
    Object.assign(console, originalConsole);
    jest.clearAllMocks();
  });

  describe('LogLevel enum', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should define all log levels', () => {
      expect(LogLevel.ERROR).toBeDefined();
      expect(LogLevel.WARN).toBeDefined();
      expect(LogLevel.INFO).toBeDefined();
      expect(LogLevel.DEBUG).toBeDefined();
    });
  });

  describe('log function', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should call log function without errors', () => {
      expect(() => log(LogLevel.ERROR, 'Test error message')).not.toThrow();
    });

    it('should call log function for all levels', () => {
      expect(() => log(LogLevel.WARN, 'Test warning message')).not.toThrow();
      expect(() => log(LogLevel.INFO, 'Test info message')).not.toThrow();
      expect(() => log(LogLevel.DEBUG, 'Test debug message')).not.toThrow();
    });

    it('should accept context parameter', () => {
      expect(() => log(LogLevel.INFO, 'Test message', { extra: 'data' })).not.toThrow();
    });
  });

  describe('convenience functions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should call convenience functions without errors', () => {
      expect(() => logError('Error message')).not.toThrow();
      expect(() => logWarning('Warning message')).not.toThrow();
      expect(() => logInfo('Info message')).not.toThrow();
      expect(() => logDebug('Debug message')).not.toThrow();
    });

    it('should accept context parameters', () => {
      expect(() => logError('Error message', { error: 'details' })).not.toThrow();
      expect(() => logWarning('Warning message', { warning: 'details' })).not.toThrow();
      expect(() => logInfo('Info message', { info: 'details' })).not.toThrow();
      expect(() => logDebug('Debug message', { debug: 'details' })).not.toThrow();
    });
  });

  describe('Logger class', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should create logger with context', () => {
      const logger = new Logger('TestModule');
      expect(logger).toBeDefined();
      expect(() => logger.error('Test error')).not.toThrow();
    });

    it('should support different log levels', () => {
      const logger = new Logger('TestModule');
      
      expect(() => logger.error('Error')).not.toThrow();
      expect(() => logger.warn('Warning')).not.toThrow();
      expect(() => logger.info('Info')).not.toThrow();
      expect(() => logger.debug('Debug')).not.toThrow();
    });

    it('should handle objects and arrays', () => {
      const logger = new Logger('TestModule');
      const testObject = { id: 1, name: 'test' };
      
      expect(() => logger.info('Object:', testObject)).not.toThrow();
    });
  });

  describe('createLogger factory', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should create logger with specified context', () => {
      const logger = createLogger('MyModule');
      expect(logger).toBeDefined();
      expect(() => logger.info('Test message')).not.toThrow();
    });

    it('should create logger with default context', () => {
      const logger = createLogger();
      expect(logger).toBeDefined();
      expect(() => logger.info('Test message')).not.toThrow();
    });

    it('should create logger with minLevel parameter', () => {
      const logger = createLogger('TestModule', LogLevel.WARN);
      expect(logger).toBeDefined();
      expect(() => logger.warn('Warning')).not.toThrow();
    });
  });

  describe('LoggerService class', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should create winston logger instance', () => {
      const service = new LoggerService();
      expect(service).toBeDefined();
    });

    it('should call all logger methods without errors', () => {
      const service = new LoggerService();
      
      expect(() => service.error('Error message')).not.toThrow();
      expect(() => service.warn('Warning message')).not.toThrow();
      expect(() => service.info('Info message')).not.toThrow();
      expect(() => service.debug('Debug message')).not.toThrow();
      expect(() => service.critical('Critical message')).not.toThrow();
    });

    it('should support log method with level parameter', () => {
      const service = new LoggerService();
      
      expect(() => service.log(LogLevel.ERROR, 'Error via log method')).not.toThrow();
      expect(() => service.log(LogLevel.WARN, 'Warning via log method')).not.toThrow();
      expect(() => service.log(LogLevel.INFO, 'Info via log method')).not.toThrow();
      expect(() => service.log(LogLevel.DEBUG, 'Debug via log method')).not.toThrow();
    });
  });
});