/**
 * Tests complets pour UserService
 * Tests toutes les fonctionnalités CRUD et de gestion des utilisateurs
 */

import { UserService } from '../userService';
import { 
  mockPrismaClient, 
  testDataFactories, 
  setupTestEnvironment, 
  cleanupTestEnvironment 
} from '../../test-utils/standardMocks';

// Mock du modèle User Sequelize
const mockUser = {
  create: jest.fn(),
  findAll: jest.fn(),
  findByPk: jest.fn(),
  findOne: jest.fn(),
  update: jest.fn(),
  destroy: jest.fn(),
  count: jest.fn(),
  findAndCountAll: jest.fn(),
};

jest.mock('@/models/User', () => ({
  __esModule: true,
  default: mockUser,
  UserRole: {
    ADMIN: 'ADMIN',
    USER: 'USER',
    MANAGER: 'MANAGER'
  }
}));

// Mock du service de logging
jest.mock('../errorLoggingService', () => ({
  logError: jest.fn(),
}));

describe('UserService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });


  beforeAll(() => {
  });

  afterAll(() => {
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
  });

  describe('create', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should create a new user successfully', async () => {
      const userData = testDataFactories.user({
        email: 'new@example.com',
        name: 'New User',
        login: 'newuser'
      });

      mockUser.create.mockResolvedValue(userData);

      const result = await UserService.create(userData);

      expect(mockUser.create).toHaveBeenCalledWith(userData);
      expect(result).toEqual(userData);
    });

    it('should handle creation errors gracefully', async () => {
      const userData = testDataFactories.user();
      const error = new Error('Email already exists');

      mockUser.create.mockRejectedValue(error);

      await expect(UserService.create(userData)).rejects.toThrow('Email already exists');
      expect(mockUser.create).toHaveBeenCalledWith(userData);
    });

    it('should log errors with proper context', async () => {
      const userData = testDataFactories.user();
      const sequelizeError = {
        name: 'SequelizeUniqueConstraintError',
        message: 'Validation error',
        original: { message: 'Duplicate entry' }
      };

      mockUser.create.mockRejectedValue(sequelizeError);

      const { logError } = require('../errorLoggingService');

      await expect(UserService.create(userData)).rejects.toThrow();
      
      expect(logError).toHaveBeenCalledWith(
        'UserService.create',
        expect.objectContaining({
          message: 'Validation error',
          code: 'SequelizeUniqueConstraintError',
          severity: 'error',
          context: expect.objectContaining({
            originalError: 'Duplicate entry',
            email: userData.email
          })
        })
      );
    });
  });

  describe('findAll', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return all users without passwords', async () => {
      const users = [
        testDataFactories.user({ id: 1 }),
        testDataFactories.user({ id: 2 })
      ];

      mockUser.findAll.mockResolvedValue(users);

      const result = await UserService.findAll();

      expect(mockUser.findAll).toHaveBeenCalledWith({
        attributes: { exclude: ['password'] },
        order: [['createdAt', 'DESC']]
      });
      expect(result).toEqual(users);
    });

    it('should handle database errors', async () => {
      const error = new Error('Database connection failed');
      mockUser.findAll.mockRejectedValue(error);

      await expect(UserService.findAll()).rejects.toThrow('Database connection failed');
    });
  });

  describe('findById', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should find user by ID without password', async () => {
      const user = testDataFactories.user();
      mockUser.findByPk.mockResolvedValue(user);

      const result = await UserService.findById(1);

      expect(mockUser.findByPk).toHaveBeenCalledWith(1, {
        attributes: { exclude: ['password'] }
      });
      expect(result).toEqual(user);
    });

    it('should return null for non-existent user', async () => {
      mockUser.findByPk.mockResolvedValue(null);

      const result = await UserService.findById(999);

      expect(result).toBeNull();
    });
  });

  describe('findByEmail', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should find user by email', async () => {
      const user = testDataFactories.user();
      mockUser.findOne.mockResolvedValue(user);

      const result = await UserService.findByEmail('test@example.com');

      expect(mockUser.findOne).toHaveBeenCalledWith({
        where: { email: 'test@example.com' }
      });
      expect(result).toEqual(user);
    });

    it('should handle case-insensitive email search', async () => {
      const user = testDataFactories.user();
      mockUser.findOne.mockResolvedValue(user);

      await UserService.findByEmail('TEST@EXAMPLE.COM');

      expect(mockUser.findOne).toHaveBeenCalledWith({
        where: { email: 'TEST@EXAMPLE.COM' }
      });
    });
  });

  describe('findByLogin', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should find user by login', async () => {
      const user = testDataFactories.user();
      mockUser.findOne.mockResolvedValue(user);

      const result = await UserService.findByLogin('testuser');

      expect(mockUser.findOne).toHaveBeenCalledWith({
        where: { login: 'testuser' }
      });
      expect(result).toEqual(user);
    });
  });

  describe('update', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should update user successfully', async () => {
      const updateData = { name: 'Updated Name' };
      const updatedUser = testDataFactories.user({ ...updateData });

      mockUser.update.mockResolvedValue([1]);
      mockUser.findByPk.mockResolvedValue(updatedUser);

      const result = await UserService.update(1, updateData);

      expect(mockUser.update).toHaveBeenCalledWith(updateData, {
        where: { id: 1 }
      });
      expect(result).toEqual(updatedUser);
    });

    it('should handle update validation errors', async () => {
      const updateData = { email: 'invalid-email' };
      const validationError = {
        name: 'SequelizeValidationError',
        message: 'Invalid email format'
      };

      mockUser.update.mockRejectedValue(validationError);

      await expect(UserService.update(1, updateData)).rejects.toThrow();
    });
  });

  describe('delete', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should delete user successfully', async () => {
      mockUser.destroy.mockResolvedValue(1);

      const result = await UserService.delete(1);

      expect(mockUser.destroy).toHaveBeenCalledWith({
        where: { id: 1 }
      });
      expect(result).toBe(true);
    });

    it('should return false if user not found', async () => {
      mockUser.destroy.mockResolvedValue(0);

      const result = await UserService.delete(999);

      expect(result).toBe(false);
    });
  });

  describe('search', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should search users by multiple criteria', async () => {
      const searchParams = {
        query: 'john',
        role: 'USER',
        active: true
      };

      const users = [testDataFactories.user()];
      mockUser.findAndCountAll.mockResolvedValue({
        rows: users,
        count: 1
      });

      const result = await UserService.search(searchParams);

      expect(mockUser.findAndCountAll).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            role: 'USER',
            active: true
          }),
          attributes: { exclude: ['password'] }
        })
      );
      expect(result.users).toEqual(users);
      expect(result.total).toBe(1);
    });

    it('should handle empty search results', async () => {
      mockUser.findAndCountAll.mockResolvedValue({
        rows: [],
        count: 0
      });

      const result = await UserService.search({ query: 'nonexistent' });

      expect(result.users).toEqual([]);
      expect(result.total).toBe(0);
    });
  });

  describe('getActiveUsers', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return only active users', async () => {
      const activeUsers = [
        testDataFactories.user({ active: true }),
        testDataFactories.user({ active: true })
      ];

      mockUser.findAll.mockResolvedValue(activeUsers);

      const result = await UserService.getActiveUsers();

      expect(mockUser.findAll).toHaveBeenCalledWith({
        where: { active: true },
        attributes: { exclude: ['password'] },
        order: [['name', 'ASC']]
      });
      expect(result).toEqual(activeUsers);
    });
  });

  describe('getUsersByRole', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return users by specific role', async () => {
      const adminUsers = [
        testDataFactories.user({ role: 'ADMIN' }),
        testDataFactories.user({ role: 'ADMIN' })
      ];

      mockUser.findAll.mockResolvedValue(adminUsers);

      const result = await UserService.getUsersByRole('ADMIN');

      expect(mockUser.findAll).toHaveBeenCalledWith({
        where: { role: 'ADMIN' },
        attributes: { exclude: ['password'] },
        order: [['name', 'ASC']]
      });
      expect(result).toEqual(adminUsers);
    });
  });

  describe('updateLastLoginAttempt', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should increment login attempts', async () => {
      mockUser.update.mockResolvedValue([1]);

      await UserService.updateLastLoginAttempt(1);

      expect(mockUser.update).toHaveBeenCalledWith(
        expect.objectContaining({
          loginAttempts: expect.any(Object) // Sequelize increment
        }),
        { where: { id: 1 } }
      );
    });
  });

  describe('resetLoginAttempts', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should reset login attempts to zero', async () => {
      mockUser.update.mockResolvedValue([1]);

      await UserService.resetLoginAttempts(1);

      expect(mockUser.update).toHaveBeenCalledWith(
        { loginAttempts: 0, lockedUntil: null },
        { where: { id: 1 } }
      );
    });
  });

  describe('lockUser', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should lock user account', async () => {
      const lockUntil = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes
      mockUser.update.mockResolvedValue([1]);

      await UserService.lockUser(1, lockUntil);

      expect(mockUser.update).toHaveBeenCalledWith(
        { lockedUntil: lockUntil },
        { where: { id: 1 } }
      );
    });
  });

  describe('isUserLocked', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return true for locked user', async () => {
      const lockedUser = testDataFactories.user({
        lockedUntil: new Date(Date.now() + 10000) // Future date
      });

      mockUser.findByPk.mockResolvedValue(lockedUser);

      const result = await UserService.isUserLocked(1);

      expect(result).toBe(true);
    });

    it('should return false for unlocked user', async () => {
      const unlockedUser = testDataFactories.user({
        lockedUntil: null
      });

      mockUser.findByPk.mockResolvedValue(unlockedUser);

      const result = await UserService.isUserLocked(1);

      expect(result).toBe(false);
    });

    it('should return false for expired lock', async () => {
      const expiredLockUser = testDataFactories.user({
        lockedUntil: new Date(Date.now() - 10000) // Past date
      });

      mockUser.findByPk.mockResolvedValue(expiredLockUser);

      const result = await UserService.isUserLocked(1);

      expect(result).toBe(false);
    });
  });

  describe('validateUserAccess', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should validate active user access', async () => {
      const activeUser = testDataFactories.user({
        active: true,
        lockedUntil: null
      });

      mockUser.findByPk.mockResolvedValue(activeUser);

      const result = await UserService.validateUserAccess(1);

      expect(result.isValid).toBe(true);
      expect(result.reason).toBeUndefined();
    });

    it('should reject inactive user', async () => {
      const inactiveUser = testDataFactories.user({
        active: false
      });

      mockUser.findByPk.mockResolvedValue(inactiveUser);

      const result = await UserService.validateUserAccess(1);

      expect(result.isValid).toBe(false);
      expect(result.reason).toBe('User account is inactive');
    });

    it('should reject locked user', async () => {
      const lockedUser = testDataFactories.user({
        active: true,
        lockedUntil: new Date(Date.now() + 10000)
      });

      mockUser.findByPk.mockResolvedValue(lockedUser);

      const result = await UserService.validateUserAccess(1);

      expect(result.isValid).toBe(false);
      expect(result.reason).toBe('User account is locked');
    });
  });

  describe('Error handling and edge cases', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle network errors gracefully', async () => {
      const networkError = new Error('Network timeout');
      mockUser.findAll.mockRejectedValue(networkError);

      await expect(UserService.findAll()).rejects.toThrow('Network timeout');
    });

    it('should handle invalid ID parameters', async () => {
      mockUser.findByPk.mockResolvedValue(null);

      const result = await UserService.findById(-1);

      expect(result).toBeNull();
    });

    it('should handle empty string searches', async () => {
      mockUser.findAndCountAll.mockResolvedValue({
        rows: [],
        count: 0
      });

      const result = await UserService.search({ query: '' });

      expect(result.users).toEqual([]);
    });
  });
});