/**
 * Tests pour le monitoring de performance et optimisations cache
 */

import { PerformanceMonitoringService } from '../PerformanceMonitoringService';
import { 
  setupTestEnvironment, 
  cleanupTestEnvironment,
  testDataFactories
} from '../../test-utils/standardMocks';

// Mock du cache Redis
const mockRedisCache = {
  get: jest.fn(),
  set: jest.fn(),
  del: jest.fn(),
  exists: jest.fn(),
  keys: jest.fn(),
  flushall: jest.fn(),
  info: jest.fn(),
  getStats: jest.fn()
};

jest.mock('@/lib/redis-cache', () => ({
  redisCache: mockRedisCache
}));

// Mock des performance APIs
Object.defineProperty(global, 'performance', {
  value: {
    now: jest.fn(() => Date.now()),
    mark: jest.fn(),
    measure: jest.fn(),
    getEntriesByType: jest.fn(() => []),
    clearMarks: jest.fn(),
    clearMeasures: jest.fn()
  }
});

describe('PerformanceMonitoringService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  let performanceService: PerformanceMonitoringService;

  beforeAll(() => {
  });

  afterAll(() => {
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    performanceService = new PerformanceMonitoringService();
  });

  describe('Performance Tracking', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should start performance measurement', () => {
      const operationId = 'test-operation';
      
      performanceService.startMeasurement(operationId);
      
      expect(global.performance.mark).toHaveBeenCalledWith(`${operationId}-start`);
    });

    it('should end performance measurement and calculate duration', () => {
      const operationId = 'test-operation';
      const startTime = 1000;
      const endTime = 1500;
      
      global.performance.now = jest.fn()
        .mockReturnValueOnce(startTime)
        .mockReturnValueOnce(endTime);
      
      performanceService.startMeasurement(operationId);
      const duration = performanceService.endMeasurement(operationId);
      
      expect(global.performance.mark).toHaveBeenCalledWith(`${operationId}-end`);
      expect(global.performance.measure).toHaveBeenCalledWith(
        operationId,
        `${operationId}-start`,
        `${operationId}-end`
      );
      expect(duration).toBe(500);
    });

    it('should track API response times', async () => {
      const endpoint = '/api/trames';
      const startTime = Date.now();
      
      performanceService.trackAPICall(endpoint, 'GET', 200, startTime);
      
      const metrics = performanceService.getMetrics();
      expect(metrics.apiCalls).toHaveLength(1);
      expect(metrics.apiCalls[0]).toMatchObject({
        endpoint,
        method: 'GET',
        statusCode: 200
      });
    });

    it('should track database query performance', async () => {
      const query = 'SELECT * FROM users';
      const duration = 150;
      
      performanceService.trackDatabaseQuery(query, duration, true);
      
      const metrics = performanceService.getMetrics();
      expect(metrics.databaseQueries).toHaveLength(1);
      expect(metrics.databaseQueries[0]).toMatchObject({
        query,
        duration,
        cached: true
      });
    });

    it('should identify slow operations', () => {
      const slowOperations = [
        { id: 'slow-query', duration: 2000 },
        { id: 'fast-query', duration: 50 },
        { id: 'medium-query', duration: 800 }
      ];
      
      slowOperations.forEach(op => {
        performanceService.startMeasurement(op.id);
        // Simuler la durée
        performanceService['measurements'].set(op.id, {
          startTime: Date.now() - op.duration,
          startMark: `${op.id}-start`
        });
        performanceService.endMeasurement(op.id);
      });
      
      const slowOps = performanceService.getSlowOperations(1000);
      expect(slowOps).toHaveLength(1);
      expect(slowOps[0].operationId).toBe('slow-query');
    });

    it('should calculate performance statistics', () => {
      const durations = [100, 200, 150, 300, 250];
      
      durations.forEach((duration, index) => {
        performanceService.trackAPICall('/test', 'GET', 200, Date.now() - duration);
      });
      
      const stats = performanceService.getPerformanceStatistics();
      expect(stats.averageResponseTime).toBeCloseTo(200);
      expect(stats.medianResponseTime).toBe(200);
      expect(stats.p95ResponseTime).toBeGreaterThan(stats.averageResponseTime);
    });
  });

  describe('Cache Performance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should track cache hit rates', () => {
      // Simuler des hits et misses
      performanceService.trackCacheHit('user-cache');
      performanceService.trackCacheHit('user-cache');
      performanceService.trackCacheMiss('user-cache');
      
      const cacheStats = performanceService.getCacheStatistics();
      expect(cacheStats['user-cache']).toMatchObject({
        hits: 2,
        misses: 1,
        hitRate: 2/3
      });
    });

    it('should measure cache operation performance', async () => {
      const cacheKey = 'test-key';
      const value = { data: 'test' };
      
      mockRedisCache.get.mockResolvedValue(JSON.stringify(value));
      
      const startTime = Date.now();
      await performanceService.measureCacheOperation(
        'get',
        cacheKey,
        () => mockRedisCache.get(cacheKey)
      );
      
      const metrics = performanceService.getMetrics();
      expect(metrics.cacheOperations).toHaveLength(1);
      expect(metrics.cacheOperations[0]).toMatchObject({
        operation: 'get',
        key: cacheKey,
        success: true
      });
    });

    it('should identify cache performance issues', () => {
      // Simuler des opérations cache lentes
      const slowOperations = [
        { key: 'slow-key', duration: 500 },
        { key: 'fast-key', duration: 10 }
      ];
      
      slowOperations.forEach(op => {
        performanceService.trackCacheOperation(op.key, 'get', op.duration, true);
      });
      
      const issues = performanceService.identifyCacheIssues();
      expect(issues.slowOperations).toHaveLength(1);
      expect(issues.slowOperations[0].key).toBe('slow-key');
    });

    it('should optimize cache based on usage patterns', () => {
      // Simuler différents patterns d'usage
      const usageData = [
        { key: 'frequent-key', hits: 100, misses: 5 },
        { key: 'rare-key', hits: 2, misses: 10 },
        { key: 'medium-key', hits: 20, misses: 8 }
      ];
      
      usageData.forEach(data => {
        for (let i = 0; i < data.hits; i++) {
          performanceService.trackCacheHit(data.key);
        }
        for (let i = 0; i < data.misses; i++) {
          performanceService.trackCacheMiss(data.key);
        }
      });
      
      const recommendations = performanceService.getCacheOptimizationRecommendations();
      
      expect(recommendations.keysToPreload).toContain('frequent-key');
      expect(recommendations.keysToEvict).toContain('rare-key');
    });
  });

  describe('Memory and Resource Monitoring', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should track memory usage', () => {
      const memoryUsage = {
        used: 1024 * 1024 * 50, // 50MB
        total: 1024 * 1024 * 100 // 100MB
      };
      
      performanceService.trackMemoryUsage(memoryUsage);
      
      const metrics = performanceService.getMetrics();
      expect(metrics.memoryUsage).toHaveLength(1);
      expect(metrics.memoryUsage[0]).toMatchObject({
        used: memoryUsage.used,
        total: memoryUsage.total,
        percentage: 50
      });
    });

    it('should detect memory leaks', () => {
      // Simuler une croissance constante de la mémoire
      const memoryGrowth = [
        { used: 50 * 1024 * 1024, total: 100 * 1024 * 1024 },
        { used: 60 * 1024 * 1024, total: 100 * 1024 * 1024 },
        { used: 70 * 1024 * 1024, total: 100 * 1024 * 1024 },
        { used: 80 * 1024 * 1024, total: 100 * 1024 * 1024 },
        { used: 90 * 1024 * 1024, total: 100 * 1024 * 1024 }
      ];
      
      memoryGrowth.forEach(usage => {
        performanceService.trackMemoryUsage(usage);
      });
      
      const leakDetection = performanceService.detectMemoryLeaks();
      expect(leakDetection.potentialLeak).toBe(true);
      expect(leakDetection.growthRate).toBeGreaterThan(0);
    });

    it('should monitor CPU usage patterns', () => {
      const cpuUsages = [45, 67, 89, 23, 56];
      
      cpuUsages.forEach(usage => {
        performanceService.trackCPUUsage(usage);
      });
      
      const cpuStats = performanceService.getCPUStatistics();
      expect(cpuStats.average).toBeCloseTo(56);
      expect(cpuStats.peak).toBe(89);
      expect(cpuStats.isHigh).toBe(true); // Peak > 80%
    });
  });

  describe('Performance Alerts', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should trigger alerts for slow operations', () => {
      const alerts: any[] = [];
      performanceService.onAlert((alert) => alerts.push(alert));
      
      // Simuler une opération lente
      performanceService.startMeasurement('slow-operation');
      performanceService['measurements'].set('slow-operation', {
        startTime: Date.now() - 5000, // 5 secondes
        startMark: 'slow-operation-start'
      });
      performanceService.endMeasurement('slow-operation');
      
      expect(alerts).toHaveLength(1);
      expect(alerts[0]).toMatchObject({
        type: 'SLOW_OPERATION',
        severity: 'warning',
        operationId: 'slow-operation'
      });
    });

    it('should trigger alerts for high error rates', () => {
      const alerts: any[] = [];
      performanceService.onAlert((alert) => alerts.push(alert));
      
      // Simuler beaucoup d'erreurs
      for (let i = 0; i < 10; i++) {
        performanceService.trackAPICall('/api/test', 'GET', 500, Date.now());
      }
      
      performanceService.checkErrorRates();
      
      const errorAlert = alerts.find(a => a.type === 'HIGH_ERROR_RATE');
      expect(errorAlert).toBeDefined();
      expect(errorAlert.severity).toBe('critical');
    });

    it('should trigger alerts for cache performance degradation', () => {
      const alerts: any[] = [];
      performanceService.onAlert((alert) => alerts.push(alert));
      
      // Simuler un faible taux de hit cache
      for (let i = 0; i < 100; i++) {
        if (i < 20) {
          performanceService.trackCacheHit('degraded-cache');
        } else {
          performanceService.trackCacheMiss('degraded-cache');
        }
      }
      
      performanceService.checkCachePerformance();
      
      const cacheAlert = alerts.find(a => a.type === 'LOW_CACHE_HIT_RATE');
      expect(cacheAlert).toBeDefined();
    });
  });

  describe('Performance Reports', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should generate comprehensive performance report', () => {
      // Ajouter des données de test
      performanceService.trackAPICall('/api/users', 'GET', 200, Date.now() - 150);
      performanceService.trackDatabaseQuery('SELECT * FROM users', 80, false);
      performanceService.trackCacheHit('user-cache');
      performanceService.trackMemoryUsage({ used: 60 * 1024 * 1024, total: 100 * 1024 * 1024 });
      
      const report = performanceService.generatePerformanceReport();
      
      expect(report).toMatchObject({
        timeRange: expect.any(Object),
        apiPerformance: expect.any(Object),
        databasePerformance: expect.any(Object),
        cachePerformance: expect.any(Object),
        systemResources: expect.any(Object),
        recommendations: expect.any(Array)
      });
    });

    it('should provide actionable recommendations', () => {
      // Simuler des problèmes de performance
      performanceService.trackAPICall('/api/slow', 'GET', 200, Date.now() - 3000);
      performanceService.trackDatabaseQuery('SELECT * FROM big_table', 2000, false);
      
      for (let i = 0; i < 100; i++) {
        performanceService.trackCacheMiss('frequently-used-key');
      }
      
      const recommendations = performanceService.getPerformanceRecommendations();
      
      expect(recommendations).toContainEqual(
        expect.objectContaining({
          type: 'OPTIMIZE_SLOW_ENDPOINT',
          priority: 'high'
        })
      );
      
      expect(recommendations).toContainEqual(
        expect.objectContaining({
          type: 'ADD_DATABASE_INDEX',
          priority: 'medium'
        })
      );
      
      expect(recommendations).toContainEqual(
        expect.objectContaining({
          type: 'IMPROVE_CACHE_STRATEGY',
          priority: 'high'
        })
      );
    });

    it('should track performance trends over time', () => {
      // Simuler des données sur plusieurs jours
      const dates = [
        new Date('2025-05-28'),
        new Date('2025-05-29'),
        new Date('2025-05-30')
      ];
      
      dates.forEach((date, index) => {
        const baseResponseTime = 100 + (index * 50); // Dégradation progressive
        
        for (let i = 0; i < 10; i++) {
          performanceService.trackAPICall(
            '/api/test',
            'GET',
            200,
            date.getTime() - baseResponseTime
          );
        }
      });
      
      const trends = performanceService.getPerformanceTrends();
      
      expect(trends.responseTimeTrend).toBe('increasing');
      expect(trends.degradationDetected).toBe(true);
    });
  });

  describe('Integration and Real-world Scenarios', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle high load monitoring', async () => {
      // Simuler une charge élevée
      const promises = [];
      
      for (let i = 0; i < 1000; i++) {
        promises.push(Promise.resolve().then(() => {
          performanceService.trackAPICall('/api/test', 'GET', 200, Date.now() - Math.random() * 1000);
        }));
      }
      
      await Promise.all(promises);
      
      const metrics = performanceService.getMetrics();
      expect(metrics.apiCalls).toHaveLength(1000);
      
      const stats = performanceService.getPerformanceStatistics();
      expect(stats.requestsPerSecond).toBeGreaterThan(0);
    });

    it('should maintain performance data within memory limits', () => {
      // Ajouter beaucoup de données
      for (let i = 0; i < 10000; i++) {
        performanceService.trackAPICall(`/api/test-${i}`, 'GET', 200, Date.now());
      }
      
      // Vérifier que le service gère la mémoire
      const metrics = performanceService.getMetrics();
      expect(metrics.apiCalls.length).toBeLessThanOrEqual(5000); // Limite de rétention
    });

    it('should export and import performance data', () => {
      // Ajouter des données
      performanceService.trackAPICall('/api/test', 'GET', 200, Date.now() - 100);
      performanceService.trackCacheHit('test-cache');
      
      // Exporter
      const exportData = performanceService.exportData();
      expect(exportData).toBeDefined();
      expect(exportData.apiCalls).toHaveLength(1);
      
      // Créer un nouveau service et importer
      const newService = new PerformanceMonitoringService();
      newService.importData(exportData);
      
      const importedMetrics = newService.getMetrics();
      expect(importedMetrics.apiCalls).toHaveLength(1);
    });
  });
});