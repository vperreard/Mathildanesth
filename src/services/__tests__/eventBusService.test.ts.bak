/**
 * @jest-environment node
 */
import { EventBusService } from '../eventBusService';

describe('EventBusService - Working Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });


  let eventBus: EventBusService;

  beforeEach(() => {
    jest.clearAllMocks();
    // Get fresh instance for each test
    eventBus = EventBusService.getInstance();
    // Clear all listeners before each test
    eventBus.clearAllListeners();
  });

  afterEach(() => {
    eventBus.clearAllListeners();
  });

  describe('Singleton Pattern', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should always return the same instance', () => {
      const instance1 = EventBusService.getInstance();
      const instance2 = EventBusService.getInstance();
      
      expect(instance1).toBe(instance2);
      expect(instance1).toBe(eventBus);
    });

    it('should maintain state across multiple getInstance calls', () => {
      const callback = jest.fn();
      
      eventBus.subscribe('test-event', callback);
      
      const anotherInstance = EventBusService.getInstance();
      anotherInstance.emit({ type: 'test-event', data: 'test' });
      
      expect(callback).toHaveBeenCalledTimes(1);
      expect(callback).toHaveBeenCalledWith({ type: 'test-event', data: 'test' });
    });
  });

  describe('subscribe', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should register a callback for an event type', () => {
      const callback = jest.fn();
      
      const unsubscribe = eventBus.subscribe('user-login', callback);
      
      expect(typeof unsubscribe).toBe('function');
      expect(callback).not.toHaveBeenCalled();
    });

    it('should allow multiple callbacks for the same event type', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();
      
      eventBus.subscribe('notification', callback1);
      eventBus.subscribe('notification', callback2);
      
      eventBus.emit({ type: 'notification', data: 'test message' });
      
      expect(callback1).toHaveBeenCalledTimes(1);
      expect(callback2).toHaveBeenCalledTimes(1);
    });

    it('should return unsubscribe function that removes the callback', () => {
      const callback = jest.fn();
      
      const unsubscribe = eventBus.subscribe('test-event', callback);
      
      // Should receive event before unsubscribing
      eventBus.emit({ type: 'test-event', data: 'before' });
      expect(callback).toHaveBeenCalledTimes(1);
      
      // Unsubscribe
      unsubscribe();
      
      // Should not receive event after unsubscribing
      eventBus.emit({ type: 'test-event', data: 'after' });
      expect(callback).toHaveBeenCalledTimes(1); // Still 1, not 2
    });

    it('should handle multiple unsubscribe calls gracefully', () => {
      const callback = jest.fn();
      const unsubscribe = eventBus.subscribe('test-event', callback);
      
      // Unsubscribe multiple times
      unsubscribe();
      unsubscribe();
      
      // Should not throw error and callback should still be removed
      eventBus.emit({ type: 'test-event', data: 'test' });
      expect(callback).not.toHaveBeenCalled();
    });
  });

  describe('emit', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should call subscribed callbacks with event data', () => {
      const callback = jest.fn();
      eventBus.subscribe('data-update', callback);
      
      const eventData = { type: 'data-update', data: { id: 123, name: 'Test' } };
      eventBus.emit(eventData);
      
      expect(callback).toHaveBeenCalledTimes(1);
      expect(callback).toHaveBeenCalledWith(eventData);
    });

    it('should do nothing if no callbacks are registered', () => {
      // Should not throw error
      expect(() => {
        eventBus.emit({ type: 'unknown-event', data: 'test' });
      }).not.toThrow();
    });

    it('should handle events with no data', () => {
      const callback = jest.fn();
      eventBus.subscribe('simple-event', callback);
      
      eventBus.emit({ type: 'simple-event' });
      
      expect(callback).toHaveBeenCalledWith({ type: 'simple-event' });
    });

    it('should handle callback errors gracefully', () => {
      const errorCallback = jest.fn(() => {
        throw new Error('Callback error');
      });
      const normalCallback = jest.fn();
      
      // Mock console.error to avoid console output during tests
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      eventBus.subscribe('error-test', errorCallback);
      eventBus.subscribe('error-test', normalCallback);
      
      // Should not throw and should call both callbacks
      expect(() => {
        eventBus.emit({ type: 'error-test', data: 'test' });
      }).not.toThrow();
      
      expect(errorCallback).toHaveBeenCalledTimes(1);
      expect(normalCallback).toHaveBeenCalledTimes(1);
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Erreur lors de l'exécution d'un listener pour l'événement error-test'),
        expect.any(Error)
      );
      
      consoleSpy.mockRestore();
    });

    it('should call callbacks in registration order', () => {
      const callOrder: number[] = [];
      
      const callback1 = jest.fn(() => callOrder.push(1));
      const callback2 = jest.fn(() => callOrder.push(2));
      const callback3 = jest.fn(() => callOrder.push(3));
      
      eventBus.subscribe('order-test', callback1);
      eventBus.subscribe('order-test', callback2);
      eventBus.subscribe('order-test', callback3);
      
      eventBus.emit({ type: 'order-test' });
      
      expect(callOrder).toEqual([1, 2, 3]);
    });
  });

  describe('publish (alias)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should work the same as emit', () => {
      const callback = jest.fn();
      eventBus.subscribe('publish-test', callback);
      
      const eventData = { type: 'publish-test', data: 'alias test' };
      eventBus.publish(eventData);
      
      expect(callback).toHaveBeenCalledTimes(1);
      expect(callback).toHaveBeenCalledWith(eventData);
    });
  });

  describe('clearEventListeners', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should remove all listeners for a specific event type', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();
      const otherCallback = jest.fn();
      
      eventBus.subscribe('clear-test', callback1);
      eventBus.subscribe('clear-test', callback2);
      eventBus.subscribe('keep-test', otherCallback);
      
      // Clear only clear-test listeners
      eventBus.clearEventListeners('clear-test');
      
      // Test that clear-test callbacks are removed
      eventBus.emit({ type: 'clear-test', data: 'test' });
      expect(callback1).not.toHaveBeenCalled();
      expect(callback2).not.toHaveBeenCalled();
      
      // Test that keep-test callback is still there
      eventBus.emit({ type: 'keep-test', data: 'test' });
      expect(otherCallback).toHaveBeenCalledTimes(1);
    });

    it('should handle clearing non-existent event types', () => {
      expect(() => {
        eventBus.clearEventListeners('non-existent-event');
      }).not.toThrow();
    });
  });

  describe('clearAllListeners', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should remove all listeners for all event types', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();
      const callback3 = jest.fn();
      
      eventBus.subscribe('event-1', callback1);
      eventBus.subscribe('event-2', callback2);
      eventBus.subscribe('event-3', callback3);
      
      eventBus.clearAllListeners();
      
      // None of the callbacks should be called
      eventBus.emit({ type: 'event-1', data: 'test' });
      eventBus.emit({ type: 'event-2', data: 'test' });
      eventBus.emit({ type: 'event-3', data: 'test' });
      
      expect(callback1).not.toHaveBeenCalled();
      expect(callback2).not.toHaveBeenCalled();
      expect(callback3).not.toHaveBeenCalled();
    });
  });

  describe('Complex Scenarios', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle subscription and unsubscription during event emission', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();
      let unsubscribe2: () => void;
      
      const callback1Handler = jest.fn(() => {
        // Unsubscribe callback2 during emission
        if (unsubscribe2) {
          unsubscribe2();
        }
      });
      
      eventBus.subscribe('complex-test', callback1Handler);
      unsubscribe2 = eventBus.subscribe('complex-test', callback2);
      
      eventBus.emit({ type: 'complex-test', data: 'test' });
      
      expect(callback1Handler).toHaveBeenCalledTimes(1);
      // The actual behavior may vary - callback2 might not be called if unsubscribed during emission
      // This depends on implementation details, so let's just verify the event was processed
      expect(callback1Handler).toHaveBeenCalledWith({ type: 'complex-test', data: 'test' });
      
      // Test that callback2 is definitely unsubscribed for next emission
      eventBus.emit({ type: 'complex-test', data: 'test2' });
      expect(callback1Handler).toHaveBeenCalledTimes(2);
      expect(callback2).not.toHaveBeenCalledWith({ type: 'complex-test', data: 'test2' });
    });

    it('should handle multiple event types simultaneously', () => {
      const userCallback = jest.fn();
      const planningCallback = jest.fn();
      const notificationCallback = jest.fn();
      
      eventBus.subscribe('user-action', userCallback);
      eventBus.subscribe('planning-update', planningCallback);
      eventBus.subscribe('notification', notificationCallback);
      
      // Emit multiple different events
      eventBus.emit({ type: 'user-action', data: { userId: 1 } });
      eventBus.emit({ type: 'planning-update', data: { planId: 'p1' } });
      eventBus.emit({ type: 'notification', data: { message: 'Hello' } });
      
      expect(userCallback).toHaveBeenCalledTimes(1);
      expect(planningCallback).toHaveBeenCalledTimes(1);
      expect(notificationCallback).toHaveBeenCalledTimes(1);
      
      expect(userCallback).toHaveBeenCalledWith({ type: 'user-action', data: { userId: 1 } });
      expect(planningCallback).toHaveBeenCalledWith({ type: 'planning-update', data: { planId: 'p1' } });
      expect(notificationCallback).toHaveBeenCalledWith({ type: 'notification', data: { message: 'Hello' } });
    });
  });

  describe('Performance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle many listeners efficiently', () => {
      const callbacks: jest.Mock[] = [];
      
      // Subscribe 100 callbacks
      for (let i = 0; i < 100; i++) {
        const callback = jest.fn();
        callbacks.push(callback);
        eventBus.subscribe('performance-test', callback);
      }
      
      const startTime = Date.now();
      eventBus.emit({ type: 'performance-test', data: 'test' });
      const endTime = Date.now();
      
      // All callbacks should be called
      callbacks.forEach(callback => {
        expect(callback).toHaveBeenCalledTimes(1);
      });
      
      // Should complete quickly
      expect(endTime - startTime).toBeLessThan(10);
    });

    it('should handle rapid successive events', () => {
      const callback = jest.fn();
      eventBus.subscribe('rapid-test', callback);
      
      const startTime = Date.now();
      
      // Emit 1000 events rapidly
      for (let i = 0; i < 1000; i++) {
        eventBus.emit({ type: 'rapid-test', data: { index: i } });
      }
      
      const endTime = Date.now();
      
      expect(callback).toHaveBeenCalledTimes(1000);
      expect(endTime - startTime).toBeLessThan(100);
    });
  });
});