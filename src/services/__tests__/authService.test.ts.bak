/**
 * @jest-environment jsdom
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';

// Create mocks before importing authService
const mockPrisma = {
  user: {
    findUnique: jest.fn(),
    update: jest.fn(),
    create: jest.fn()
  },
  $transaction: jest.fn()
};

const mockAuthCache = {
  cacheAuthToken: jest.fn(),
  getCachedAuthToken: jest.fn(),
  invalidateAuthToken: jest.fn(),
  cacheUserData: jest.fn(),
  invalidateUserData: jest.fn()
};

const mockLogger = {
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
  debug: jest.fn()
};

const mockBcrypt = {
  compare: jest.fn(),
  hash: jest.fn()
};

const mockJwt = {
  sign: jest.fn(),
  verify: jest.fn()
};

// Mock external dependencies
jest.mock('@/lib/prisma', () => ({ prisma: mockPrisma }));
jest.mock('@/lib/auth/authCache', () => ({ AuthCacheService: mockAuthCache }));
jest.mock('@/lib/logger', () => ({ logger: mockLogger }));
jest.mock('bcryptjs', () => mockBcrypt);
jest.mock('jsonwebtoken', () => mockJwt);

import { authService } from '../authService';

// Test constants for medical application
const MEDICAL_USER_ROLES = {
  MAR: 'MAR', // Médecin Anesthésiste Réanimateur
  IADE: 'IADE', // Infirmier Anesthésiste Diplômé d'État
  ADMIN_TOTAL: 'ADMIN_TOTAL',
  ADMIN_PARTIEL: 'ADMIN_PARTIEL',
  CHIRURGIEN: 'CHIRURGIEN',
  USER: 'USER'
} as const;

const TEST_USERS = {
  validMAR: {
    id: 1,
    email: 'dr.martin@hospital.com',
    login: 'dr.martin',
    password: '$2b$12$validHashedPassword',
    role: MEDICAL_USER_ROLES.MAR,
    name: 'Dr. Martin',
    prenom: 'Jean',
    nom: 'Martin',
    active: true,
    mustChangePassword: false,
    loginAttempts: 0,
    lockedUntil: null,
    lastLogin: null,
    createdAt: new Date(),
    updatedAt: new Date()
  },
  validIADE: {
    id: 2,
    email: 'nurse.jane@hospital.com',
    login: 'nurse.jane',
    password: '$2b$12$validHashedPassword',
    role: MEDICAL_USER_ROLES.IADE,
    name: 'Nurse Jane',
    prenom: 'Jane',
    nom: 'Dupont',
    active: true,
    mustChangePassword: false,
    loginAttempts: 0,
    lockedUntil: null,
    lastLogin: null,
    createdAt: new Date(),
    updatedAt: new Date()
  },
  inactiveUser: {
    id: 3,
    email: 'inactive@hospital.com',
    login: 'inactive',
    password: '$2b$12$validHashedPassword',
    role: MEDICAL_USER_ROLES.USER,
    name: 'Inactive User',
    active: false,
    mustChangePassword: false,
    loginAttempts: 0,
    lockedUntil: null,
    lastLogin: null,
    createdAt: new Date(),
    updatedAt: new Date()
  },
  lockedUser: {
    id: 4,
    email: 'locked@hospital.com',
    login: 'locked',
    password: '$2b$12$validHashedPassword',
    role: MEDICAL_USER_ROLES.USER,
    name: 'Locked User',
    active: true,
    mustChangePassword: false,
    loginAttempts: 5,
    lockedUntil: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes
    lastLogin: null,
    createdAt: new Date(),
    updatedAt: new Date()
  }
};

const SECURITY_CONFIG = {
  JWT_SECRET: 'test-jwt-secret-256-bit-key-for-medical-app',
  BCRYPT_ROUNDS: 12,
  MAX_LOGIN_ATTEMPTS: 5,
  LOCKOUT_TIME: 30 * 60 * 1000, // 30 minutes
  TOKEN_EXPIRY: '24h'
};

describe('AuthService - Comprehensive Security Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
    process.env.JWT_SECRET = SECURITY_CONFIG.JWT_SECRET;
    process.env.NODE_ENV = 'test';
    
    // Configure mock implementations
    mockBcrypt.compare.mockImplementation((password, hash) => Promise.resolve(password === 'validPassword'));
    mockBcrypt.hash.mockImplementation((password) => Promise.resolve(`$2b$12$${password}Hashed`));
    mockJwt.sign.mockImplementation(() => 'mock-jwt-token');
    mockJwt.verify.mockImplementation(() => ({ userId: 1, role: 'USER' }));
  });
  
  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('login', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait authentifier un utilisateur avec des identifiants valides', async () => {
      const mockUser = {
        id: 1,
        email: 'test@example.com',
        password: 'hashedPassword',
        role: 'ADMIN',
        name: 'Test User',
        active: true
      };

      const mockToken = 'mock-jwt-token';

      mockPrisma.user.findUnique.mockResolvedValue(mockUser);
      mockPrisma.user.update.mockResolvedValue({ ...mockUser, loginAttempts: 0, lastLogin: expect.any(Date) });
      mockBcrypt.compare.mockResolvedValue(true);
      mockJwt.sign.mockReturnValue(mockToken);
      mockAuthCache.cacheAuthToken.mockResolvedValue(undefined);

      const result = await authService.login('test@example.com', 'password123');

      expect(result).toEqual({
        user: {
          id: mockUser.id,
          email: mockUser.email,
          name: mockUser.name,
          role: mockUser.role
        },
        token: mockToken
      });

      expect(mockPrisma.user.findUnique).toHaveBeenCalledWith({
        where: { email: 'test@example.com' }
      });
      expect(mockBcrypt.compare).toHaveBeenCalledWith('password123', 'hashedPassword');
      expect(mockJwt.sign).toHaveBeenCalledWith(
        { userId: 1, role: 'ADMIN' },
        'test-jwt-secret-256-bit-key-for-medical-app',
        { expiresIn: '24h' }
      );
      expect(mockAuthCache.cacheAuthToken).toHaveBeenCalled();
      expect(mockAuthCache.cacheUserData).toHaveBeenCalled();
    });

    it('devrait rejeter avec email invalide', async () => {
      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(null);

      await expect(authService.login('invalid@example.com', 'password123'))
        .rejects.toThrow('Invalid credentials');

      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Login attempt failed: user not found',
        { email: 'invalid@example.com' }
      );
    });

    it('devrait rejeter avec mot de passe invalide', async () => {
      const mockUser = {
        id: 1,
        email: 'test@example.com',
        password: 'hashedPassword',
        active: true,
        loginAttempts: 0
      };

      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
      mockPrisma.user.update = jest.fn().mockResolvedValue({ ...mockUser, loginAttempts: 1 });
      mockBcrypt.compare.mockResolvedValue(false);

      await expect(authService.login('test@example.com', 'wrongpassword'))
        .rejects.toThrow('Invalid credentials');

      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Login attempt failed: invalid password',
        { email: 'test@example.com' }
      );
    });

    it('devrait rejeter si utilisateur inactif', async () => {
      const mockUser = {
        id: 1,
        email: 'test@example.com',
        password: 'hashedPassword',
        active: false
      };

      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
      mockBcrypt.compare.mockResolvedValue(true);

      await expect(authService.login('test@example.com', 'password123'))
        .rejects.toThrow('Account is disabled');

      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Login attempt failed: account disabled',
        { email: 'test@example.com' }
      );
    });
  });

  describe('validateToken', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait valider un token valide depuis le cache', async () => {
      const mockCachedAuth = {
        userId: 1,
        role: 'ADMIN',
        exp: Math.floor(Date.now() / 1000) + 3600
      };

      mockAuthCache.getCachedAuthToken.mockResolvedValue(mockCachedAuth);

      const result = await authService.validateToken('valid-token');

      expect(result).toEqual(mockCachedAuth);
      expect(mockAuthCache.getCachedAuthToken).toHaveBeenCalledWith('valid-token');
      expect(mockJwt.verify).not.toHaveBeenCalled();
    });

    it('devrait valider un token valide non-caché', async () => {
      const mockPayload = {
        userId: 1,
        role: 'ADMIN',
        exp: Math.floor(Date.now() / 1000) + 3600
      };

      mockAuthCache.getCachedAuthToken.mockResolvedValue(null);
      mockJwt.verify.mockReturnValue(mockPayload);
      mockAuthCache.cacheAuthToken.mockResolvedValue(undefined);

      const result = await authService.validateToken('valid-token');

      expect(result).toEqual(mockPayload);
      expect(mockJwt.verify).toHaveBeenCalledWith('valid-token', 'test-jwt-secret-256-bit-key-for-medical-app');
      expect(mockAuthCache.cacheAuthToken).toHaveBeenCalled();
    });

    it('devrait rejeter un token expiré', async () => {
      const mockCachedAuth = {
        userId: 1,
        role: 'ADMIN',
        exp: Math.floor(Date.now() / 1000) - 3600 // Expiré
      };

      mockAuthCache.getCachedAuthToken.mockResolvedValue(mockCachedAuth);
      mockAuthCache.invalidateAuthToken.mockResolvedValue(undefined);

      await expect(authService.validateToken('expired-token'))
        .rejects.toThrow('Token expired');

      expect(mockAuthCache.invalidateAuthToken).toHaveBeenCalledWith('expired-token');
    });

    it('devrait rejeter un token invalide', async () => {
      mockAuthCache.getCachedAuthToken.mockResolvedValue(null);
      mockJwt.verify.mockImplementation(() => {
        throw new Error('Invalid token');
      });

      await expect(authService.validateToken('invalid-token'))
        .rejects.toThrow('Invalid token');

      expect(mockLogger.error).toHaveBeenCalledWith(
        'Token validation failed',
        expect.any(Error)
      );
    });
  });

  describe('refreshToken', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait rafraîchir un token valide', async () => {
      const mockPayload = {
        userId: 1,
        role: 'ADMIN',
        exp: Math.floor(Date.now() / 1000) + 3600
      };
      const newToken = 'new-token';

      mockJwt.verify.mockReturnValue(mockPayload);
      mockJwt.sign.mockReturnValue(newToken);
      mockAuthCache.invalidateAuthToken.mockResolvedValue(undefined);
      mockAuthCache.cacheAuthToken.mockResolvedValue(undefined);

      const result = await authService.refreshToken('old-token');

      expect(result).toBe(newToken);
      expect(mockJwt.sign).toHaveBeenCalledWith(
        { userId: 1, role: 'ADMIN' },
        'test-jwt-secret-256-bit-key-for-medical-app',
        { expiresIn: '24h' }
      );
      expect(mockAuthCache.invalidateAuthToken).toHaveBeenCalledWith('old-token');
      expect(mockAuthCache.cacheAuthToken).toHaveBeenCalled();
    });

    it('devrait rejeter un token invalide', async () => {
      mockJwt.verify.mockImplementation(() => {
        throw new Error('Invalid token');
      });

      await expect(authService.refreshToken('invalid-token'))
        .rejects.toThrow('Invalid token');
    });
  });

  describe('logout', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait invalider le token et les données utilisateur', async () => {
      const mockPayload = {
        userId: 1,
        role: 'ADMIN'
      };

      mockJwt.verify.mockReturnValue(mockPayload);
      mockAuthCache.invalidateAuthToken.mockResolvedValue(undefined);
      mockAuthCache.invalidateUserData.mockResolvedValue(undefined);

      await authService.logout('valid-token');

      expect(mockAuthCache.invalidateAuthToken).toHaveBeenCalledWith('valid-token');
      expect(mockAuthCache.invalidateUserData).toHaveBeenCalledWith('1');
      expect(mockLogger.info).toHaveBeenCalledWith(
        'User logged out successfully',
        { userId: 1 }
      );
    });

    it('devrait gérer un token invalide lors du logout', async () => {
      mockJwt.verify.mockImplementation(() => {
        throw new Error('Invalid token');
      });

      await authService.logout('invalid-token');

      expect(mockAuthCache.invalidateAuthToken).toHaveBeenCalledWith('invalid-token');
      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Logout attempted with invalid token'
      );
    });
  });

  describe('changePassword', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait changer le mot de passe avec succès', async () => {
      const mockUser = {
        id: 1,
        password: 'oldHashedPassword'
      };
      const newHashedPassword = 'newHashedPassword';

      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
      mockPrisma.user.update = jest.fn().mockResolvedValue({
        ...mockUser,
        password: newHashedPassword
      });
      mockBcrypt.compare.mockResolvedValue(true);
      mockBcrypt.hash.mockResolvedValue(newHashedPassword);

      await authService.changePassword(1, 'oldPassword', 'newPassword');

      expect(mockPrisma.user.update).toHaveBeenCalledWith({
        where: { id: 1 },
        data: { password: newHashedPassword }
      });
      expect(mockLogger.info).toHaveBeenCalledWith(
        'Password changed successfully',
        { userId: 1 }
      );
    });

    it('devrait rejeter avec ancien mot de passe invalide', async () => {
      const mockUser = {
        id: 1,
        password: 'oldHashedPassword'
      };

      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
      mockBcrypt.compare.mockResolvedValue(false);

      await expect(authService.changePassword(1, 'wrongPassword', 'newPassword'))
        .rejects.toThrow('Current password is incorrect');
    });

    it('devrait rejeter si utilisateur non trouvé', async () => {
      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(null);

      await expect(authService.changePassword(999, 'password', 'newPassword'))
        .rejects.toThrow('User not found');
    });
  });

  describe('Security Features', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('devrait implémenter rate limiting pour login', async () => {
      const mockUser = {
        id: 1,
        email: 'test@example.com',
        password: 'hashedPassword',
        active: true,
        loginAttempts: 4,
        lockedUntil: null
      };

      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
      mockPrisma.user.update = jest.fn().mockResolvedValue({
        ...mockUser,
        loginAttempts: 5,
        lockedUntil: new Date(Date.now() + 30 * 60 * 1000)
      });
      mockBcrypt.compare.mockResolvedValue(false);

      await expect(authService.login('test@example.com', 'wrongpassword'))
        .rejects.toThrow('Account locked due to too many failed attempts');

      expect(mockPrisma.user.update).toHaveBeenCalledWith({
        where: { id: 1 },
        data: {
          loginAttempts: 5,
          lockedUntil: expect.any(Date)
        }
      });
    });

    it('devrait réinitialiser les tentatives après login réussi', async () => {
      const mockUser = {
        id: 1,
        email: 'test@example.com',
        password: 'hashedPassword',
        active: true,
        loginAttempts: 3,
        role: 'USER',
        name: 'Test User'
      };

      mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
      mockPrisma.user.update = jest.fn().mockResolvedValue({
        ...mockUser,
        loginAttempts: 0,
        lastLogin: new Date()
      });
      mockBcrypt.compare.mockResolvedValue(true);
      mockJwt.sign.mockReturnValue('token');
      mockAuthCache.cacheAuthToken.mockResolvedValue(undefined);

      await authService.login('test@example.com', 'password123');

      expect(mockPrisma.user.update).toHaveBeenCalledWith({
        where: { id: 1 },
        data: {
          loginAttempts: 0,
          lastLogin: expect.any(Date),
          lockedUntil: null
        }
      });
    });
  });
});