/**
 * Tests complets pour les services d'export/import de données médicales
 */

import { 
  exportSimulationResults,
  exportLeaveData,
  exportPlanningData 
} from '../exportServiceV2';
import Papa from 'papaparse';
import { jsPDF } from 'jspdf';
import { 
  setupTestEnvironment, 
  cleanupTestEnvironment,
  testDataFactories
} from '../../test-utils/standardMocks';

// Mock des librairies d'export
jest.mock('jspdf', () => {
  const mockDoc = {
    text: jest.fn(),
    autoTable: jest.fn(),
    save: jest.fn(),
    output: jest.fn(() => 'mock-pdf-blob'),
    setFontSize: jest.fn(),
    setFont: jest.fn(),
    addPage: jest.fn(),
    previousAutoTable: { finalY: 100 }
  };
  
  return {
    jsPDF: jest.fn(() => mockDoc),
    __mockDoc: mockDoc
  };
});

jest.mock('jspdf-autotable');

jest.mock('papaparse', () => ({
  unparse: jest.fn((data) => `col1,col2
row1,row2`),
  parse: jest.fn((csv) => ({
    data: [
      ['col1', 'col2'],
      ['row1', 'row2']
    ],
    errors: [],
    meta: { fields: ['col1', 'col2'] }
  }))
}));

// Mock date-fns
jest.mock('date-fns', () => ({
  format: jest.fn((date, formatStr) => '2025-05-30'),
}));

jest.mock('date-fns/locale', () => ({
  fr: {}
}));

describe('Export/Import Services', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  let mockJsPDF: any;

  beforeAll(() => {
    mockJsPDF = require('jspdf').__mockDoc;
  });

  afterAll(() => {
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
  });

  describe('exportSimulationResults', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    const mockSimulationData = {
      id: 'sim-123',
      scenarioName: 'Test Scenario',
      scenarioDescription: 'Test scenario description',
      createdAt: new Date('2025-05-30'),
      status: 'completed',
      statistics: {
        totalAssignments: 150,
        conflictsResolved: 5,
        coverageRate: 95.5,
        averageWorkload: 42.3
      },
      conflicts: [
        {
          id: 'conflict-1',
          type: 'SKILL_MISMATCH',
          severity: 'high',
          description: 'MAR needed for specialized surgery',
          affectedAssignments: ['assignment-1', 'assignment-2']
        }
      ],
      userAssignments: [
        {
          userId: 'user-1',
          userName: 'Dr. Smith',
          role: 'MAR',
          assignments: [
            { date: '2025-06-01', time: '08:00-16:00', location: 'Bloc A' }
          ]
        }
      ],
      periodCoverage: 98.2
    };

    it('should export simulation results as PDF', async () => {
      const options = {
        format: 'pdf' as const,
        fileName: 'test_simulation.pdf'
      };

      const result = await exportSimulationResults(mockSimulationData, options);

      expect(jsPDF).toHaveBeenCalled();
      expect(mockJsPDF.text).toHaveBeenCalledWith('Rapport de Simulation: Test Scenario', 20, 20);
      expect(mockJsPDF.autoTable).toHaveBeenCalled();
      expect(mockJsPDF.output).toHaveBeenCalledWith('blob');
      expect(result).toBeDefined();
    });

    it('should export simulation results as CSV', async () => {
      const options = {
        format: 'csv' as const,
        fileName: 'test_simulation.csv'
      };

      const result = await exportSimulationResults(mockSimulationData, options);

      expect(Papa.unparse).toHaveBeenCalled();
      expect(result).toBeInstanceOf(Blob);
      expect(result.type).toBe('text/csv');
    });

    it('should include raw data when requested', async () => {
      const options = {
        format: 'csv' as const,
        includeRawData: true
      };

      await exportSimulationResults(mockSimulationData, options);

      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0]).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            Scenario: 'Test Scenario',
            Status: 'completed'
          })
        ])
      );
    });

    it('should handle empty simulation data', async () => {
      const emptyData = {
        id: 'empty-sim',
        scenarioName: 'Empty Scenario',
        createdAt: new Date(),
        status: 'pending',
        statistics: {},
        conflicts: [],
        userAssignments: []
      };

      const options = { format: 'pdf' as const };

      const result = await exportSimulationResults(emptyData, options);

      expect(result).toBeDefined();
      expect(mockJsPDF.text).toHaveBeenCalledWith('Rapport de Simulation: Empty Scenario', 20, 20);
    });

    it('should generate default filename when none provided', async () => {
      const options = { format: 'pdf' as const };

      await exportSimulationResults(mockSimulationData, options);

      // Should use scenario name in filename
      expect(require('date-fns').format).toHaveBeenCalled();
    });

    it('should handle large datasets efficiently', async () => {
      const largeData = {
        ...mockSimulationData,
        userAssignments: Array.from({ length: 1000 }, (_, i) => ({
          userId: `user-${i}`,
          userName: `User ${i}`,
          role: 'MAR',
          assignments: [
            { date: '2025-06-01', time: '08:00-16:00', location: `Bloc ${i % 10}` }
          ]
        }))
      };

      const options = { format: 'csv' as const };

      const startTime = Date.now();
      const result = await exportSimulationResults(largeData, options);
      const endTime = Date.now();

      expect(result).toBeDefined();
      expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
    });
  });

  describe('exportLeaveData', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    const mockLeaveData = [
      {
        id: 'leave-1',
        userId: 'user-1',
        userName: 'Dr. Smith',
        startDate: new Date('2025-06-01'),
        endDate: new Date('2025-06-05'),
        type: 'ANNUAL',
        status: 'APPROVED',
        reason: 'Vacances été',
        dayCount: 5
      },
      {
        id: 'leave-2',
        userId: 'user-2',
        userName: 'Dr. Johnson',
        startDate: new Date('2025-06-10'),
        endDate: new Date('2025-06-12'),
        type: 'SICK',
        status: 'PENDING',
        reason: 'Maladie',
        dayCount: 3
      }
    ];

    it('should export leave data as CSV with proper formatting', async () => {
      const options = {
        format: 'csv' as const,
        dateRange: {
          start: new Date('2025-06-01'),
          end: new Date('2025-06-30')
        }
      };

      const result = await exportLeaveData(mockLeaveData, options);

      expect(Papa.unparse).toHaveBeenCalledWith(
        expect.arrayContaining([
          expect.objectContaining({
            'Nom de l'utilisateur': 'Dr. Smith',
            'Type de congé': 'ANNUAL',
            'Statut': 'APPROVED'
          })
        ])
      );

      expect(result.type).toBe('text/csv');
    });

    it('should export leave data as PDF with tables', async () => {
      const options = { format: 'pdf' as const };

      const result = await exportLeaveData(mockLeaveData, options);

      expect(mockJsPDF.text).toHaveBeenCalledWith('Rapport des Congés', 20, 20);
      expect(mockJsPDF.autoTable).toHaveBeenCalled();
      expect(result).toBeDefined();
    });

    it('should filter data by date range', async () => {
      const options = {
        format: 'csv' as const,
        dateRange: {
          start: new Date('2025-06-01'),
          end: new Date('2025-06-07')
        }
      };

      await exportLeaveData(mockLeaveData, options);

      // Should only include leaves that overlap with date range
      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0]).toHaveLength(1); // Only first leave should be included
    });

    it('should filter data by status', async () => {
      const options = {
        format: 'csv' as const,
        statusFilter: ['APPROVED']
      };

      await exportLeaveData(mockLeaveData, options);

      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0]).toHaveLength(1); // Only approved leave
    });

    it('should filter data by leave type', async () => {
      const options = {
        format: 'csv' as const,
        typeFilter: ['ANNUAL']
      };

      await exportLeaveData(mockLeaveData, options);

      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0]).toHaveLength(1); // Only annual leave
    });

    it('should handle empty leave data', async () => {
      const options = { format: 'csv' as const };

      const result = await exportLeaveData([], options);

      expect(result).toBeDefined();
      expect(Papa.unparse).toHaveBeenCalledWith([]);
    });

    it('should include statistics in PDF export', async () => {
      const options = {
        format: 'pdf' as const,
        includeStatistics: true
      };

      await exportLeaveData(mockLeaveData, options);

      // Should add statistics section
      expect(mockJsPDF.text).toHaveBeenCalledWith('Statistiques', expect.any(Number), expect.any(Number));
    });
  });

  describe('exportPlanningData', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    const mockPlanningData = [
      {
        id: 'assignment-1',
        userId: 'user-1',
        userName: 'Dr. Smith',
        date: new Date('2025-06-01'),
        startTime: '08:00',
        endTime: '16:00',
        shiftType: 'GARDE_JOUR',
        location: 'Bloc A',
        sector: 'Chirurgie générale',
        skills: ['MAR', 'SURGERY']
      },
      {
        id: 'assignment-2',
        userId: 'user-2',
        userName: 'Dr. Johnson',
        date: new Date('2025-06-01'),
        startTime: '16:00',
        endTime: '08:00',
        shiftType: 'GARDE_NUIT',
        location: 'Bloc B',
        sector: 'Urgences',
        skills: ['IADE', 'EMERGENCY']
      }
    ];

    it('should export planning data with proper medical terminology', async () => {
      const options = { format: 'csv' as const };

      const result = await exportPlanningData(mockPlanningData, options);

      expect(Papa.unparse).toHaveBeenCalledWith(
        expect.arrayContaining([
          expect.objectContaining({
            'Professionnel': 'Dr. Smith',
            'Type de garde': 'GARDE_JOUR',
            'Secteur': 'Chirurgie générale',
            'Compétences': 'MAR, SURGERY'
          })
        ])
      );
    });

    it('should export planning data as PDF with weekly view', async () => {
      const options = {
        format: 'pdf' as const,
        viewType: 'weekly'
      };

      const result = await exportPlanningData(mockPlanningData, options);

      expect(mockJsPDF.text).toHaveBeenCalledWith(
        expect.stringContaining('Planning Hebdomadaire'),
        expect.any(Number),
        expect.any(Number)
      );
      expect(mockJsPDF.autoTable).toHaveBeenCalled();
    });

    it('should group data by sector when requested', async () => {
      const options = {
        format: 'pdf' as const,
        groupBy: 'sector'
      };

      await exportPlanningData(mockPlanningData, options);

      // Should create separate tables for each sector
      expect(mockJsPDF.autoTable).toHaveBeenCalledTimes(2); // One for each sector
    });

    it('should validate shift continuity', async () => {
      const options = {
        format: 'csv' as const,
        validateContinuity: true
      };

      await exportPlanningData(mockPlanningData, options);

      // Should add continuity validation columns
      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0][0]).toHaveProperty('Continuité validée');
    });

    it('should handle overlapping assignments', async () => {
      const overlappingData = [
        {
          ...mockPlanningData[0],
          endTime: '20:00' // Overlap with next assignment
        },
        {
          ...mockPlanningData[1],
          startTime: '18:00'
        }
      ];

      const options = {
        format: 'csv' as const,
        highlightConflicts: true
      };

      await exportPlanningData(overlappingData, options);

      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0]).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            'Conflit détecté': expect.stringContaining('Chevauchement')
          })
        ])
      );
    });
  });

  describe('Import Functionality', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should parse CSV leave data correctly', () => {
      const csvData = `Nom,Type,Date début,Date fin,Statut
Dr. Smith,ANNUAL,2025-06-01,2025-06-05,APPROVED
Dr. Johnson,SICK,2025-06-10,2025-06-12,PENDING`;

      const result = Papa.parse(csvData);

      expect(result.data).toHaveLength(3); // Header + 2 rows
      expect(result.errors).toHaveLength(0);
    });

    it('should validate imported medical data structure', () => {
      const invalidCsvData = `Nom,Type,Date début
Dr. Smith,ANNUAL`; // Missing required fields

      const result = Papa.parse(invalidCsvData);
      
      // Should detect missing required fields
      expect(result.data[1]).toHaveLength(2); // Missing Date fin
    });

    it('should handle CSV encoding issues', () => {
      const csvWithAccents = `Nom,Spécialité,Rôle
Dr. François,Anesthésie,MAR
Dr. Müller,Chirurgie,IADE`;

      const result = Papa.parse(csvWithAccents);

      expect(result.data[1][0]).toBe('Dr. François');
      expect(result.data[1][1]).toBe('Anesthésie');
    });

    it('should batch process large imports', async () => {
      const largeCsvData = Array.from({ length: 10000 }, (_, i) => 
        `User${i},ANNUAL,2025-06-01,2025-06-05,APPROVED`
      ).join('
');

      const csvWithHeader = `Nom,Type,Date début,Date fin,Statut
${largeCsvData}`;

      const startTime = Date.now();
      const result = Papa.parse(csvWithHeader);
      const endTime = Date.now();

      expect(result.data).toHaveLength(10001); // Header + 10000 rows
      expect(endTime - startTime).toBeLessThan(3000); // Should complete within 3 seconds
    });
  });

  describe('Error Handling and Edge Cases', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should handle PDF generation errors', async () => {
      mockJsPDF.output.mockImplementation(() => {
        throw new Error('PDF generation failed');
      });

      const options = { format: 'pdf' as const };

      await expect(
        exportSimulationResults(testDataFactories.apiResponse({}), options)
      ).rejects.toThrow('PDF generation failed');
    });

    it('should handle CSV parsing errors', () => {
      const malformedCsv = `Nom,Type,Date
"Unclosed quote,ANNUAL,2025-06-01`;

      (Papa.parse as jest.Mock).mockReturnValue({
        data: [],
        errors: [{ message: 'Unclosed quote' }],
        meta: { fields: [] }
      });

      const result = Papa.parse(malformedCsv);

      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].message).toBe('Unclosed quote');
    });

    it('should handle memory constraints during large exports', async () => {
      const hugeData = {
        id: 'huge-sim',
        scenarioName: 'Huge Dataset',
        createdAt: new Date(),
        status: 'completed',
        statistics: {},
        conflicts: Array.from({ length: 100000 }, (_, i) => ({ id: i })),
        userAssignments: Array.from({ length: 50000 }, (_, i) => ({ userId: i }))
      };

      const options = { format: 'csv' as const };

      // Should not throw memory errors
      await expect(
        exportSimulationResults(hugeData, options)
      ).resolves.toBeDefined();
    });

    it('should validate medical data integrity', async () => {
      const invalidMedicalData = [
        {
          // Missing required medical fields
          id: 'invalid-1',
          userName: 'Dr. Invalid'
          // Missing role, sector, etc.
        }
      ];

      const options = { format: 'csv' as const };

      // Should handle gracefully with warnings
      const result = await exportPlanningData(invalidMedicalData, options);
      expect(result).toBeDefined();
    });

    it('should handle timezone conversion in date exports', async () => {
      const dataWithTimezones = [
        {
          id: 'tz-test',
          startDate: new Date('2025-06-01T08:00:00Z'),
          endDate: new Date('2025-06-01T16:00:00Z')
        }
      ];

      const options = {
        format: 'csv' as const,
        timezone: 'Europe/Paris'
      };

      await exportLeaveData(dataWithTimezones, options);

      // Should convert times to specified timezone
      expect(Papa.unparse).toHaveBeenCalled();
    });
  });

  describe('Medical Data Compliance', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should anonymize sensitive data when requested', async () => {
      const sensitiveData = [
        {
          id: 'sensitive-1',
          userId: 'user-123',
          userName: 'Dr. Sensitive',
          personalDetails: {
            ssn: '123-45-6789',
            address: '123 Main St'
          }
        }
      ];

      const options = {
        format: 'csv' as const,
        anonymize: true
      };

      await exportPlanningData(sensitiveData, options);

      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0][0]).not.toHaveProperty('personalDetails');
      expect(papaCall[0][0]['Professionnel']).toMatch(/^Professionnel_\w+$/);
    });

    it('should add audit trail to exports', async () => {
      const options = {
        format: 'pdf' as const,
        includeAuditTrail: true,
        exportedBy: 'admin@hospital.com'
      };

      await exportPlanningData(mockPlanningData, options);

      expect(mockJsPDF.text).toHaveBeenCalledWith(
        expect.stringContaining('Exporté par: admin@hospital.com'),
        expect.any(Number),
        expect.any(Number)
      );
    });

    it('should validate GDPR compliance requirements', async () => {
      const gdprData = [
        {
          id: 'gdpr-test',
          userName: 'Dr. GDPR',
          consentGiven: true,
          dataRetentionExpiry: new Date('2026-06-01')
        }
      ];

      const options = {
        format: 'csv' as const,
        enforceGDPR: true
      };

      await exportLeaveData(gdprData, options);

      // Should only export data with valid consent
      const papaCall = (Papa.unparse as jest.Mock).mock.calls[0];
      expect(papaCall[0]).toHaveLength(1); // Should include data with consent
    });
  });
});