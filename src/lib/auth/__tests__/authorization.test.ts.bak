import { 
    getAuthorizedSession, 
    requireRole, 
    requireAdmin, 
    requireAdminTotal, 
    requireOwnerOrAdmin,
    requireLeavePermission,
    requirePlanningPermission,
    requireSimulationPermission,
    requireMessagePermission,
    withAuthorization,
    logSecurityAction,
    AuthenticationError,
    AuthorizationError
} from '../authorization';
import { getServerSession } from 'next-auth';
import { Role } from '@prisma/client';

// Mock des dÃ©pendances
jest.mock('next-auth', () => ({
    getServerSession: jest.fn()
}));

jest.mock('@/lib/auth', () => ({
    authOptions: {}
}));

// Mock console.log pour les tests de logging
const originalConsoleLog = console.log;
const originalConsoleError = console.error;

describe('Authorization Module', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    const mockGetServerSession = getServerSession as jest.Mock;
    let consoleLogSpy: jest.SpyInstance;
    let consoleErrorSpy: jest.SpyInstance;

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
    });

    afterEach(() => {
        consoleLogSpy.mockRestore();
        consoleErrorSpy.mockRestore();
    });

    describe('getAuthorizedSession', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should return session when user is authenticated', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'testuser',
                    role: Role.USER,
                    email: 'test@example.com'
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await getAuthorizedSession();

            expect(result).toEqual(mockSession);
            expect(mockGetServerSession).toHaveBeenCalled();
        });

        it('should throw AuthenticationError when no session', async () => {
            mockGetServerSession.mockResolvedValueOnce(null);

            await expect(getAuthorizedSession()).rejects.toThrow(AuthenticationError);
        });

        it('should throw AuthenticationError when session has no user', async () => {
            mockGetServerSession.mockResolvedValueOnce({ user: null });

            await expect(getAuthorizedSession()).rejects.toThrow(AuthenticationError);
        });

        it('should throw AuthenticationError when session has no user id', async () => {
            mockGetServerSession.mockResolvedValueOnce({ user: { login: 'test' } });

            await expect(getAuthorizedSession()).rejects.toThrow(AuthenticationError);
        });
    });

    describe('requireRole', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should return session when user has required role', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'admin',
                    role: Role.ADMIN_TOTAL
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireRole([Role.ADMIN_TOTAL, Role.ADMIN_PARTIEL])();

            expect(result).toEqual(mockSession);
        });

        it('should throw AuthorizationError when user lacks required role', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            await expect(requireRole([Role.ADMIN_TOTAL])()).rejects.toThrow(AuthorizationError);
        });
    });

    describe('requireAdmin', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should allow ADMIN_TOTAL access', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'admin',
                    role: Role.ADMIN_TOTAL
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireAdmin();

            expect(result).toEqual(mockSession);
        });

        it('should allow ADMIN_PARTIEL access', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'admin',
                    role: Role.ADMIN_PARTIEL
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireAdmin();

            expect(result).toEqual(mockSession);
        });

        it('should deny USER access', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            await expect(requireAdmin()).rejects.toThrow(AuthorizationError);
        });
    });

    describe('requireAdminTotal', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should allow ADMIN_TOTAL access', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'admin',
                    role: Role.ADMIN_TOTAL
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireAdminTotal();

            expect(result).toEqual(mockSession);
        });

        it('should deny ADMIN_PARTIEL access', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'admin',
                    role: Role.ADMIN_PARTIEL
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            await expect(requireAdminTotal()).rejects.toThrow(AuthorizationError);
        });
    });

    describe('requireOwnerOrAdmin', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should allow owner access', async () => {
            const mockSession = {
                user: {
                    id: 123,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireOwnerOrAdmin(123);

            expect(result).toEqual(mockSession);
        });

        it('should allow owner access with string id', async () => {
            const mockSession = {
                user: {
                    id: 123,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireOwnerOrAdmin('123');

            expect(result).toEqual(mockSession);
        });

        it('should allow admin access for any resource', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'admin',
                    role: Role.ADMIN_TOTAL
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireOwnerOrAdmin(999);

            expect(result).toEqual(mockSession);
        });

        it('should deny non-owner non-admin access', async () => {
            const mockSession = {
                user: {
                    id: 123,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            await expect(requireOwnerOrAdmin(456)).rejects.toThrow(AuthorizationError);
        });
    });

    describe('requireLeavePermission', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const mockUserSession = {
            user: {
                id: 123,
                login: 'user',
                role: Role.USER
            }
        };

        const mockAdminSession = {
            user: {
                id: 1,
                login: 'admin',
                role: Role.ADMIN_TOTAL
            }
        };

        it('should allow user to create their own leave', async () => {
            // Need to mock twice: once for getAuthorizedSession in requireLeavePermission,
            // and once for getAuthorizedSession in requireOwnerOrAdmin
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            const result = await requireLeavePermission('create', 123);

            expect(result).toEqual(mockUserSession);
        });

        it('should allow user to read their own leave', async () => {
            // Need to mock twice: once for getAuthorizedSession in requireLeavePermission,
            // and once for getAuthorizedSession in requireOwnerOrAdmin
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            const result = await requireLeavePermission('read', 123);

            expect(result).toEqual(mockUserSession);
        });

        it('should allow user to update their own leave', async () => {
            // Need to mock twice: once for getAuthorizedSession in requireLeavePermission,
            // and once for getAuthorizedSession in requireOwnerOrAdmin
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            const result = await requireLeavePermission('update', 123);

            expect(result).toEqual(mockUserSession);
        });

        it('should only allow admin total to delete leaves', async () => {
            // Need to mock twice: once for getAuthorizedSession in requireLeavePermission delete case,
            // and once for getAuthorizedSession in requireAdminTotal
            mockGetServerSession.mockResolvedValueOnce(mockAdminSession);
            mockGetServerSession.mockResolvedValueOnce(mockAdminSession);

            const result = await requireLeavePermission('delete');

            expect(result).toEqual(mockAdminSession);
        });

        it('should only allow admins to approve leaves', async () => {
            // Need to mock twice: once for getAuthorizedSession in requireLeavePermission approve case,
            // and once for getAuthorizedSession in requireAdmin
            mockGetServerSession.mockResolvedValueOnce(mockAdminSession);
            mockGetServerSession.mockResolvedValueOnce(mockAdminSession);

            const result = await requireLeavePermission('approve');

            expect(result).toEqual(mockAdminSession);
        });

        it('should throw for invalid action', async () => {
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            await expect(requireLeavePermission('invalid' as any)).rejects.toThrow('Action non reconnue');
        });
    });

    describe('requirePlanningPermission', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should allow all authenticated users to read', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requirePlanningPermission('read');

            expect(result).toEqual(mockSession);
        });

        it('should only allow admins to create/update/delete', async () => {
            const mockAdminSession = {
                user: {
                    id: 1,
                    login: 'admin',
                    role: Role.ADMIN_TOTAL
                }
            };
            // Need to mock twice: once for requirePlanningPermission, once for requireAdmin
            mockGetServerSession.mockResolvedValueOnce(mockAdminSession);
            mockGetServerSession.mockResolvedValueOnce(mockAdminSession);

            const result = await requirePlanningPermission('create');

            expect(result).toEqual(mockAdminSession);
        });

        it('should deny non-admin for create', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'user',
                    role: Role.USER
                }
            };
            // Need to mock twice: once for requirePlanningPermission, once for requireAdmin check
            mockGetServerSession.mockResolvedValueOnce(mockSession);
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            await expect(requirePlanningPermission('create')).rejects.toThrow(AuthorizationError);
        });
    });

    describe('requireSimulationPermission', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const mockUserSession = {
            user: {
                id: 123,
                login: 'user',
                role: Role.USER
            }
        };

        it('should allow user to create simulation', async () => {
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            const result = await requireSimulationPermission('create');

            expect(result).toEqual(mockUserSession);
        });

        it('should allow user to run their own simulation', async () => {
            // Need to mock twice: once for requireSimulationPermission, once for requireOwnerOrAdmin
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            const result = await requireSimulationPermission('run', 123);

            expect(result).toEqual(mockUserSession);
        });

        it('should deny user from running others simulation', async () => {
            // Need to mock twice: once for requireSimulationPermission, once for requireOwnerOrAdmin
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            await expect(requireSimulationPermission('run', 456)).rejects.toThrow(AuthorizationError);
        });
    });

    describe('requireMessagePermission', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should allow all authenticated users to create/read', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const result = await requireMessagePermission('read');

            expect(result).toEqual(mockSession);
        });

        it('should only allow admins to update/delete', async () => {
            const mockUserSession = {
                user: {
                    id: 1,
                    login: 'user',
                    role: Role.USER
                }
            };
            // Need to mock twice: once for requireMessagePermission, once for requireAdmin
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);
            mockGetServerSession.mockResolvedValueOnce(mockUserSession);

            await expect(requireMessagePermission('delete')).rejects.toThrow(AuthorizationError);
        });
    });

    describe('withAuthorization', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        const mockHandler = jest.fn();
        
        beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
            mockHandler.mockResolvedValue(new Response('OK'));
        });

        it('should call handler with session when authorized', async () => {
            const mockSession = {
                user: {
                    id: 1,
                    login: 'user',
                    role: Role.USER
                }
            };
            mockGetServerSession.mockResolvedValueOnce(mockSession);

            const authFn = jest.fn().mockResolvedValue(mockSession);
            const wrapped = withAuthorization(authFn, mockHandler);

            const result = await wrapped('arg1', 'arg2');

            expect(authFn).toHaveBeenCalledWith('arg1', 'arg2');
            expect(mockHandler).toHaveBeenCalledWith(mockSession, 'arg1', 'arg2');
            expect(result).toBeInstanceOf(Response);
        });

        it('should return 401 for authentication errors', async () => {
            const authFn = jest.fn().mockRejectedValue(new AuthenticationError());
            const wrapped = withAuthorization(authFn, mockHandler);

            const result = await wrapped();

            expect(result.status).toBe(401);
            const body = await result.json();
            expect(body.error).toBe('Authentication required');
        });

        it('should return 403 for authorization errors', async () => {
            const authFn = jest.fn().mockRejectedValue(new AuthorizationError('Access denied'));
            const wrapped = withAuthorization(authFn, mockHandler);

            const result = await wrapped();

            expect(result.status).toBe(403);
            const body = await result.json();
            expect(body.error).toBe('Access denied');
        });

        it('should return custom status code for authorization errors', async () => {
            const authFn = jest.fn().mockRejectedValue(new AuthorizationError('Forbidden', 400));
            const wrapped = withAuthorization(authFn, mockHandler);

            const result = await wrapped();

            expect(result.status).toBe(400);
        });

        it('should return 500 for other errors', async () => {
            const authFn = jest.fn().mockRejectedValue(new Error('Unknown error'));
            const wrapped = withAuthorization(authFn, mockHandler);

            const result = await wrapped();

            expect(result.status).toBe(500);
            const body = await result.json();
            expect(body.error).toBe('Internal server error');
            expect(consoleErrorSpy).toHaveBeenCalledWith('Authorization error:', expect.any(Error));
        });
    });

    describe('logSecurityAction', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should log security action with details', () => {
            const userId = 123;
            const action = 'DELETE';
            const resource = 'leave';
            const details = { leaveId: 456 };

            logSecurityAction(userId, action, resource, details);

            expect(consoleLogSpy).toHaveBeenCalledWith(
                `[SECURITY] User ${userId} performed ${action} on ${resource}`,
                expect.objectContaining({
                    timestamp: expect.any(String),
                    userId,
                    action,
                    resource,
                    details: JSON.stringify(details)
                })
            );
        });

        it('should log security action without details', () => {
            const userId = '123';
            const action = 'READ';
            const resource = 'planning';

            logSecurityAction(userId, action, resource);

            expect(consoleLogSpy).toHaveBeenCalledWith(
                `[SECURITY] User ${userId} performed ${action} on ${resource}`,
                expect.objectContaining({
                    timestamp: expect.any(String),
                    userId,
                    action,
                    resource,
                    details: undefined
                })
            );
        });
    });

    describe('Error Classes', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should create AuthenticationError with default message', () => {
            const error = new AuthenticationError();
            
            expect(error.message).toBe('Authentication required');
            expect(error.name).toBe('AuthenticationError');
        });

        it('should create AuthenticationError with custom message', () => {
            const error = new AuthenticationError('Session expired');
            
            expect(error.message).toBe('Session expired');
            expect(error.name).toBe('AuthenticationError');
        });

        it('should create AuthorizationError with message and default status', () => {
            const error = new AuthorizationError('Access denied');
            
            expect(error.message).toBe('Access denied');
            expect(error.name).toBe('AuthorizationError');
            expect(error.statusCode).toBe(403);
        });

        it('should create AuthorizationError with custom status', () => {
            const error = new AuthorizationError('Bad request', 400);
            
            expect(error.message).toBe('Bad request');
            expect(error.statusCode).toBe(400);
        });
    });
});