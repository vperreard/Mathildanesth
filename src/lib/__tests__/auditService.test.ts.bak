// Mock the entire auditService module
const mockAuditInstance = {
  log: jest.fn(),
  logAction: jest.fn(),
  getRecentLogs: jest.fn(),
  search: jest.fn(),
};

jest.mock('../auditService', () => ({
  AuditService: {
    getInstance: jest.fn(() => mockAuditInstance),
  },
  auditService: mockAuditInstance,
}));

const { AuditService, auditService } = require('../auditService');

// Mock Prisma
const mockPrisma = { auditLog: { create: jest.fn(), findMany: jest.fn() } };

describe('AuditService (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    beforeEach(() => {
    jest.clearAllMocks();
        jest.clearAllMocks();
    });

    describe('Singleton pattern', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should return the same instance when called multiple times', () => {
            const instance1 = AuditService.getInstance();
            const instance2 = AuditService.getInstance();
            
            expect(instance1).toBe(instance2);
            expect(typeof instance1).toBe('object');
        });

        it('should export the singleton instance as auditService', () => {
            const instance = AuditService.getInstance();
            expect(auditService).toBe(instance);
        });
    });

    describe('logAction', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should create an audit log entry successfully', async () => {
            const mockAuditParams = {
                action: 'TEST_ACTION',
                entityId: 'entity123',
                entityType: 'TestEntity',
                userId: 1,
                details: { key: 'value', number: 42 }
            };

            await auditService.logAction(mockAuditParams);

            expect(mockAuditInstance.logAction).toHaveBeenCalledWith(mockAuditParams);
        });

        it('should handle numeric entityId', async () => {
            const params = {
                action: 'TEST_ACTION',
                entityId: 123,
                entityType: 'TestEntity',
                userId: 1
            };

            await auditService.logAction(params);

            expect(mockAuditInstance.logAction).toHaveBeenCalledWith(params);
        });

        it('should handle missing optional parameters', async () => {
            const params = {
                action: 'MINIMAL_ACTION',
                entityId: 'entity456',
                entityType: 'MinimalEntity'
            };

            await auditService.logAction(params);

            expect(mockAuditInstance.logAction).toHaveBeenCalledWith(params);
        });

        it('should handle errors gracefully', async () => {
            const errorParams = {
                action: 'ERROR_ACTION',
                entityId: 'error-entity',
                entityType: 'ErrorEntity'
            };

            mockAuditInstance.logAction.mockRejectedValueOnce(new Error('Database error'));

            await expect(auditService.logAction(errorParams))
                .rejects.toThrow('Database error');
        });
    });

    describe('getRecentLogs', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should retrieve recent audit logs', async () => {
            const mockLogs = [
                {
                    id: 1,
                    action: 'LOGIN',
                    entityType: 'USER',
                    entityId: '1',
                    userId: 1,
                    timestamp: new Date()
                }
            ];

            mockAuditInstance.getRecentLogs.mockResolvedValue(mockLogs);

            const result = await auditService.getRecentLogs(10);
            
            expect(mockAuditInstance.getRecentLogs).toHaveBeenCalledWith(10);
            expect(result).toEqual(mockLogs);
        });

        it('should handle limit parameter correctly', async () => {
            mockAuditInstance.getRecentLogs.mockResolvedValue([]);

            await auditService.getRecentLogs(5);
            
            expect(mockAuditInstance.getRecentLogs).toHaveBeenCalledWith(5);
        });
    });

    describe('search', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        it('should search audit logs by criteria', async () => {
            const searchCriteria = {
                action: 'LOGIN',
                userId: 1,
                startDate: new Date('2023-01-01'),
                endDate: new Date('2023-12-31')
            };

            const mockResults = [
                {
                    id: 1,
                    action: 'LOGIN',
                    entityType: 'USER',
                    entityId: '1',
                    userId: 1,
                    timestamp: new Date()
                }
            ];

            mockAuditInstance.search.mockResolvedValue(mockResults);

            const result = await auditService.search(searchCriteria);
            
            expect(mockAuditInstance.search).toHaveBeenCalledWith(searchCriteria);
            expect(result).toEqual(mockResults);
        });

        it('should handle empty search results', async () => {
            mockAuditInstance.search.mockResolvedValue([]);

            const result = await auditService.search({ action: 'NONEXISTENT' });
            
            expect(result).toEqual([]);
        });
    });
});