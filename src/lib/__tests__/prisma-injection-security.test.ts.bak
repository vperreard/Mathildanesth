/**
 * @jest-environment jsdom
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { prisma } from '@/lib/prisma';

jest.mock('@/lib/prisma', () => ({
  prisma: {
    user: {
      findUnique: jest.fn(),
      findMany: jest.fn(),
      update: jest.fn(),
      updateMany: jest.fn(),
      create: jest.fn(),
      delete: jest.fn(),
      deleteMany: jest.fn(),
    },
    planning: {
      findMany: jest.fn(),
      findUnique: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    },
    leave: {
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      deleteMany: jest.fn(),
    },
    auditLog: {
      create: jest.fn(),
      findMany: jest.fn(),
    },
    $queryRaw: jest.fn(),
    $executeRaw: jest.fn(),
    $transaction: jest.fn(),
  },
}));

const mockPrisma = {
  user: {
    findUnique: jest.fn(),
    findMany: jest.fn(),
    update: jest.fn(),
    updateMany: jest.fn(),
    create: jest.fn(),
    delete: jest.fn(),
    deleteMany: jest.fn(),
  },
  planning: {
    findMany: jest.fn(),
    findUnique: jest.fn(),
    create: jest.fn(),
    update: jest.fn(),
  },
  leave: {
    findMany: jest.fn(),
    create: jest.fn(),
    update: jest.fn(),
    delete: jest.fn(),
    deleteMany: jest.fn(),
  },
  auditLog: {
    create: jest.fn(),
    findMany: jest.fn(),
  },
  $queryRaw: jest.fn(),
  $executeRaw: jest.fn(),
  $transaction: jest.fn(),
};

describe('🛡️ SQL Injection Prevention Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('User Query Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle malicious email inputs in user lookup', async () => {
      const maliciousEmails = [
        "'; DROP TABLE users; --",
        "user@test.com'; DELETE FROM users WHERE '1'='1'; --",
        "' OR '1'='1",
        "admin' UNION SELECT * FROM users --",
        "'; INSERT INTO users (email, role) VALUES ('hacker@evil.com', 'ADMIN'); --",
        "test@test.com"; DROP DATABASE hospital; --",
        "' OR 1=1 OR ''='",
        "1' OR 1=1#",
        "x' AND (SELECT count(*) FROM tabname) < 10 --",
        "'; EXEC xp_cmdshell('dir'); --"
      ];

      for (const maliciousEmail of maliciousEmails) {
        mockPrisma.user.findUnique.mockResolvedValue(null);

        // Test user lookup with malicious input
        await mockPrisma.user.findUnique({
          where: { email: maliciousEmail }
        });

        // Verify that Prisma safely parameterizes the query
        expect(mockPrisma.user.findUnique).toHaveBeenCalledWith({
          where: { email: maliciousEmail }
        });

        // The malicious input should be treated as literal string, not SQL
        const lastCall = mockPrisma.user.findUnique.mock.calls[mockPrisma.user.findUnique.mock.calls.length - 1];
        expect(lastCall[0].where.email).toBe(maliciousEmail);
      }
    });

    it('should safely handle malicious ID inputs in user queries', async () => {
      const maliciousIds = [
        "1; DROP TABLE users; --",
        "1 UNION SELECT * FROM admin_users",
        "1' OR '1'='1",
        "'; DELETE FROM users; --",
        "1; INSERT INTO users (role) VALUES ('ADMIN'); --"
      ];

      for (const maliciousId of maliciousIds) {
        mockPrisma.user.findUnique.mockResolvedValue(null);

        // Test user lookup by ID with malicious input
        // Note: In real code, this would be validated as integer
        try {
          await mockPrisma.user.findUnique({
            where: { id: parseInt(maliciousId as string) || 0 }
          });
        } catch (error) {
          // Expected to fail due to type conversion
        }

        // Verify safe handling
        if (mockPrisma.user.findUnique.mock.calls.length > 0) {
          const lastCall = mockPrisma.user.findUnique.mock.calls[mockPrisma.user.findUnique.mock.calls.length - 1];
          expect(typeof lastCall[0].where.id).toBe('number');
        }
      }
    });

    it('should safely handle complex where conditions', async () => {
      const maliciousInputs = {
        email: "'; DROP TABLE users; --",
        role: "ADMIN'; DELETE FROM users; --",
        active: "true; INSERT INTO logs VALUES ('hacked'); --"
      };

      mockPrisma.user.findMany.mockResolvedValue([]);

      await mockPrisma.user.findMany({
        where: {
          email: maliciousInputs.email,
          role: maliciousInputs.role as any,
          active: true // Should be boolean, not string
        }
      });

      expect(mockPrisma.user.findMany).toHaveBeenCalledWith({
        where: {
          email: maliciousInputs.email,
          role: maliciousInputs.role,
          active: true
        }
      });
    });
  });

  describe('Leave Request Query Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle malicious inputs in leave queries', async () => {
      const maliciousInputs = {
        userId: "1; DROP TABLE leaves; --",
        startDate: "2025-01-01'; DELETE FROM leaves; --",
        endDate: "2025-01-10'; INSERT INTO leaves (userId, approved) VALUES (999, true); --",
        reason: "'; UPDATE leaves SET approved=true WHERE userId=1; --"
      };

      mockPrisma.leave.findMany.mockResolvedValue([]);

      await mockPrisma.leave.findMany({
        where: {
          userId: parseInt(maliciousInputs.userId) || 0,
          startDate: {
            gte: new Date(maliciousInputs.startDate.split("'")[0]) // Safely extract date part
          },
          endDate: {
            lte: new Date(maliciousInputs.endDate.split("'")[0])
          },
          reason: {
            contains: maliciousInputs.reason
          }
        }
      });

      expect(mockPrisma.leave.findMany).toHaveBeenCalledWith({
        where: {
          userId: expect.any(Number),
          startDate: {
            gte: expect.any(Date)
          },
          endDate: {
            lte: expect.any(Date)
          },
          reason: {
            contains: maliciousInputs.reason
          }
        }
      });
    });

    it('should safely handle OR conditions in leave status queries', async () => {
      const maliciousStatus = "PENDING'; DELETE FROM leaves WHERE status='APPROVED'; --";

      mockPrisma.leave.findMany.mockResolvedValue([]);

      await mockPrisma.leave.findMany({
        where: {
          OR: [
            { status: maliciousStatus as any },
            { urgent: true }
          ]
        }
      });

      expect(mockPrisma.leave.findMany).toHaveBeenCalledWith({
        where: {
          OR: [
            { status: maliciousStatus },
            { urgent: true }
          ]
        }
      });
    });
  });

  describe('Planning Query Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle malicious inputs in planning queries', async () => {
      const maliciousInputs = {
        dateRange: "2025-01-01'; DROP TABLE planning; --",
        operatingRoomId: "1 UNION SELECT id FROM admin_rooms",
        surgeonId: "'; UPDATE planning SET surgeon_id=999; --"
      };

      mockPrisma.planning.findMany.mockResolvedValue([]);

      await mockPrisma.planning.findMany({
        where: {
          date: {
            gte: new Date(maliciousInputs.dateRange.split("'")[0])
          },
          operatingRoomId: parseInt(maliciousInputs.operatingRoomId) || 0,
          surgeonId: parseInt(maliciousInputs.surgeonId) || 0
        },
        include: {
          operatingRoom: true,
          surgeon: true
        }
      });

      expect(mockPrisma.planning.findMany).toHaveBeenCalledWith({
        where: {
          date: {
            gte: expect.any(Date)
          },
          operatingRoomId: expect.any(Number),
          surgeonId: expect.any(Number)
        },
        include: {
          operatingRoom: true,
          surgeon: true
        }
      });
    });

    it('should safely handle complex join queries', async () => {
      const maliciousFilter = "'; DROP TABLE specialties; --";

      mockPrisma.planning.findMany.mockResolvedValue([]);

      await mockPrisma.planning.findMany({
        where: {
          surgeon: {
            specialties: {
              some: {
                name: maliciousFilter
              }
            }
          }
        },
        include: {
          surgeon: {
            include: {
              specialties: true
            }
          }
        }
      });

      expect(mockPrisma.planning.findMany).toHaveBeenCalledWith({
        where: {
          surgeon: {
            specialties: {
              some: {
                name: maliciousFilter
              }
            }
          }
        },
        include: {
          surgeon: {
            include: {
              specialties: true
            }
          }
        }
      });
    });
  });

  describe('Update Query Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle malicious inputs in user updates', async () => {
      const maliciousData = {
        name: "John'; UPDATE users SET role='ADMIN' WHERE id=1; --",
        email: "john@test.com'; DELETE FROM users; --",
        role: "USER'; INSERT INTO audit_logs VALUES ('compromised'); --"
      };

      mockPrisma.user.update.mockResolvedValue({
        id: 1,
        ...maliciousData
      } as any);

      await mockPrisma.user.update({
        where: { id: 1 },
        data: maliciousData
      });

      expect(mockPrisma.user.update).toHaveBeenCalledWith({
        where: { id: 1 },
        data: maliciousData
      });
    });

    it('should safely handle batch updates with malicious inputs', async () => {
      const maliciousCondition = "active=true'; UPDATE users SET role='ADMIN'; --";

      mockPrisma.user.updateMany.mockResolvedValue({ count: 0 });

      await mockPrisma.user.updateMany({
        where: {
          active: true, // Should be boolean, not malicious string
          lastLogin: {
            lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 30 days ago
          }
        },
        data: {
          active: false
        }
      });

      expect(mockPrisma.user.updateMany).toHaveBeenCalledWith({
        where: {
          active: true,
          lastLogin: {
            lt: expect.any(Date)
          }
        },
        data: {
          active: false
        }
      });
    });
  });

  describe('Delete Query Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle malicious inputs in delete operations', async () => {
      const maliciousId = "1; DELETE FROM users; --";

      mockPrisma.leave.delete.mockResolvedValue({} as any);

      try {
        await mockPrisma.leave.delete({
          where: { id: parseInt(maliciousId) || 0 }
        });
      } catch (error) {
        // May fail due to invalid ID
      }

      if (mockPrisma.leave.delete.mock.calls.length > 0) {
        expect(mockPrisma.leave.delete).toHaveBeenCalledWith({
          where: { id: expect.any(Number) }
        });
      }
    });

    it('should safely handle conditional deletes', async () => {
      const maliciousCondition = "expired=true'; DELETE FROM users; --";

      mockPrisma.leave.deleteMany.mockResolvedValue({ count: 0 });

      await mockPrisma.leave.deleteMany({
        where: {
          endDate: {
            lt: new Date()
          },
          status: 'EXPIRED' // Should be enum value, not malicious string
        }
      });

      expect(mockPrisma.leave.deleteMany).toHaveBeenCalledWith({
        where: {
          endDate: {
            lt: expect.any(Date)
          },
          status: 'EXPIRED'
        }
      });
    });
  });

  describe('Raw Query Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle raw queries with parameterization', async () => {
      // Note: Raw queries should be avoided, but if used, must be parameterized
      const maliciousInput = "'; DROP TABLE users; --";

      mockPrisma.$queryRaw.mockResolvedValue([]);

      // This is how raw queries should be handled if absolutely necessary
      await mockPrisma.$queryRaw`
        SELECT * FROM users 
        WHERE email = ${maliciousInput}
      `;

      expect(mockPrisma.$queryRaw).toHaveBeenCalled();
      
      // The template literal ensures safe parameterization
      const call = mockPrisma.$queryRaw.mock.calls[0];
      // Template literals are passed as arrays to $queryRaw
      if (Array.isArray(call[0])) {
        expect(call[0].join('')).toContain('SELECT * FROM users');
        expect(call[1]).toBe(maliciousInput); // Safely parameterized
      } else {
        expect(call[0]).toContain('SELECT * FROM users');
        expect(call[1]).toBe(maliciousInput); // Safely parameterized
      }
    });

    it('should never use string concatenation for raw queries', async () => {
      // This is an ANTI-PATTERN - should never be done
      const maliciousInput = "'; DROP TABLE users; --";

      // This would be vulnerable (don't do this):
      // const vulnerableQuery = `SELECT * FROM users WHERE email = '${maliciousInput}'`;
      
      // Instead, always use parameterized queries:
      mockPrisma.$queryRaw.mockResolvedValue([]);

      await mockPrisma.$queryRaw`
        SELECT u.*, r.name as role_name 
        FROM users u 
        JOIN roles r ON u.role_id = r.id 
        WHERE u.email = ${maliciousInput}
        AND u.active = ${true}
      `;

      expect(mockPrisma.$queryRaw).toHaveBeenCalled();
    });
  });

  describe('Search Query Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle search inputs with special characters', async () => {
      const maliciousSearchTerms = [
        "'; DROP TABLE users; --",
        "% OR 1=1 --",
        "\'; DELETE FROM users; --",
        "_'; UPDATE users SET role='ADMIN'; --",
        "test'; INSERT INTO logs VALUES ('hacked'); --"
      ];

      for (const searchTerm of maliciousSearchTerms) {
        mockPrisma.user.findMany.mockResolvedValue([]);

        await mockPrisma.user.findMany({
          where: {
            OR: [
              {
                name: {
                  contains: searchTerm,
                  mode: 'insensitive'
                }
              },
              {
                email: {
                  contains: searchTerm,
                  mode: 'insensitive'
                }
              }
            ]
          }
        });

        expect(mockPrisma.user.findMany).toHaveBeenCalledWith({
          where: {
            OR: [
              {
                name: {
                  contains: searchTerm,
                  mode: 'insensitive'
                }
              },
              {
                email: {
                  contains: searchTerm,
                  mode: 'insensitive'
                }
              }
            ]
          }
        });
      }
    });

    it('should safely handle regex-like patterns in search', async () => {
      const regexPatterns = [
        ".*'; DROP TABLE users; --",
        "^'; DELETE FROM users; --",
        "[a-z]*'; UPDATE users; --",
        "(test|admin)'; INSERT INTO users; --"
      ];

      for (const pattern of regexPatterns) {
        mockPrisma.user.findMany.mockResolvedValue([]);

        await mockPrisma.user.findMany({
          where: {
            name: {
              contains: pattern
            }
          }
        });

        expect(mockPrisma.user.findMany).toHaveBeenCalledWith({
          where: {
            name: {
              contains: pattern
            }
          }
        });
      }
    });
  });

  describe('Transaction Security', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should safely handle malicious inputs in transactions', async () => {
      const maliciousData = {
        email: "test@test.com'; DROP TABLE users; --",
        role: "USER'; INSERT INTO admin_users VALUES ('hacker'); --"
      };

      mockPrisma.$transaction.mockImplementation(async (operations) => {
        // Execute each operation in the transaction
        const results = [];
        for (const operation of operations) {
          if (typeof operation === 'function') {
            results.push(await operation);
          } else {
            results.push(operation);
          }
        }
        return results;
      });

      await mockPrisma.$transaction([
        mockPrisma.user.create({
          data: maliciousData
        }),
        mockPrisma.auditLog.create({
          data: {
            action: 'USER_CREATED',
            userId: 1,
            details: JSON.stringify(maliciousData)
          }
        })
      ]);

      expect(mockPrisma.$transaction).toHaveBeenCalled();
    });
  });

  describe('Type Safety Validation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should enforce type safety to prevent injection', () => {
      // TypeScript should prevent these at compile time
      const validUserId: number = 1;
      const invalidUserId: string = "'; DROP TABLE users; --";

      // This should be safe due to TypeScript typing
      expect(() => {
        mockPrisma.user.findUnique({
          where: { id: validUserId }
        });
      }).not.toThrow();

      // This should be caught by TypeScript (but we test runtime safety)
      expect(() => {
        mockPrisma.user.findUnique({
          where: { id: parseInt(invalidUserId) || 0 }
        });
      }).not.toThrow();
    });

    it('should validate enum values to prevent injection', () => {
      const validRole = 'USER';
      const maliciousRole = "ADMIN'; DROP TABLE users; --";

      // Valid enum value should work
      mockPrisma.user.findMany.mockResolvedValue([]);
      
      mockPrisma.user.findMany({
        where: { role: validRole as any }
      });

      expect(mockPrisma.user.findMany).toHaveBeenCalledWith({
        where: { role: validRole }
      });

      // Malicious enum value should be handled safely
      mockPrisma.user.findMany({
        where: { role: maliciousRole as any }
      });

      expect(mockPrisma.user.findMany).toHaveBeenCalledWith({
        where: { role: maliciousRole }
      });
    });
  });
});