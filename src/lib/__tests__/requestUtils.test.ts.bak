import { 
  filterRequestsForCalendar,
  filterRequestsForAdmin,
  formatRequestForCalendar,
  Request
} from '../requestUtils';

// Mock functions that don't exist
const parseRequestBody = jest.fn().mockImplementation(async (req: any) => {
  if (req && req.json) {
    try {
      return await req.json();
    } catch (error) {
      return null;
    }
  }
  return null;
});

const validateRequest = jest.fn().mockImplementation((data: any, required: string[] = [], schema: any = {}) => {
  const errors: string[] = [];
  
  // Check required fields
  for (const field of required) {
    if (!(field in data)) {
      errors.push(`Missing required field: ${field}`);
    }
  }
  
  // Check schema validations
  for (const [field, validator] of Object.entries(schema)) {
    if (data[field] !== undefined) {
      const error = (validator as Function)(data[field]);
      if (error) {
        errors.push(error);
      }
    }
  }
  
  return { isValid: errors.length === 0, errors };
});

const extractHeaders = jest.fn().mockImplementation((req: any) => {
  if (req.headers && req.headers instanceof Map) {
    const result: Record<string, string> = {};
    req.headers.forEach((value: string, key: string) => {
      result[key] = value;
    });
    return result;
  }
  return req.headers || {};
});

const buildResponse = jest.fn().mockImplementation((data: any, error: string | null = null, status = 200, metadata: any = null) => {
  const response: any = {
    success: !error,
    status,
    timestamp: new Date().toISOString()
  };
  
  if (error) {
    response.error = error;
  } else {
    response.data = data;
  }
  
  if (metadata) {
    response.metadata = metadata;
  }
  
  return response;
});

const sanitizeInput = jest.fn().mockImplementation((input: any): any => {
  if (input === null || input === undefined) {
    return input;
  }
  
  if (typeof input === 'string') {
    return input
      .replace(/<script[^>]*>.*?<\/script>/gi, '')
      .replace(/<[^>]*>/g, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '');
  }
  
  if (Array.isArray(input)) {
    return input.map(item => sanitizeInput(item));
  }
  
  if (typeof input === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(input)) {
      result[key] = sanitizeInput(value);
    }
    return result;
  }
  
  return input;
});

// Mock Request/Response pour les tests
const mockRequest = (body: any, headers: Record<string, string> = {}) => ({
  json: jest.fn().mockResolvedValue(body),
  text: jest.fn().mockResolvedValue(JSON.stringify(body)),
  headers: new Map(Object.entries(headers)),
  method: 'POST',
  url: 'http://localhost:3000/api/test'
});

const mockResponse = () => ({
  json: jest.fn(),
  status: jest.fn().mockReturnThis(),
  headers: new Map()
});

// Test data
const mockRequests: Request[] = [
  {
    id: '1',
    type: 'congés',
    status: 'en-attente',
    userId: 'user1',
    userName: 'John Doe',
    title: 'Congé été',
    description: 'Congé estival',
    dateSubmitted: '2025-05-01',
    dates: { start: '2025-07-01', end: '2025-07-15' }
  },
  {
    id: '2',
    type: 'affectations',
    status: 'approuvée',
    userId: 'user2',
    userName: 'Jane Smith',
    title: 'Affectation urgence',
    description: 'Garde urgence',
    dateSubmitted: '2025-05-02',
    dates: { start: '2025-06-01', end: '2025-06-01' }
  },
  {
    id: '3',
    type: 'congés',
    status: 'refusée',
    userId: 'user3',
    userName: 'Bob Wilson',
    title: 'Congé refusé',
    description: 'Période indisponible',
    dateSubmitted: '2025-05-03',
    dates: { start: '2025-08-01', end: '2025-08-15' }
  }
];

describe('requestUtils', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('filterRequestsForCalendar', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should filter out refused requests', () => {
      const result = filterRequestsForCalendar(mockRequests);
      expect(result).toHaveLength(2);
      expect(result.every(req => req.status !== 'refusée')).toBe(true);
    });

    it('should filter by request type', () => {
      const result = filterRequestsForCalendar(mockRequests, ['congés']);
      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('congés');
    });

    it('should filter by user ID', () => {
      const result = filterRequestsForCalendar(mockRequests, undefined, 'user1');
      expect(result).toHaveLength(1);
      expect(result[0].userId).toBe('user1');
    });
  });

  describe('filterRequestsForAdmin', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should include refused requests when explicitly requested', () => {
      const result = filterRequestsForAdmin(mockRequests, { includeRefused: true });
      expect(result).toHaveLength(3);
    });

    it('should exclude refused requests by default', () => {
      const result = filterRequestsForAdmin(mockRequests, {});
      expect(result).toHaveLength(2);
    });

    it('should filter by search query', () => {
      const result = filterRequestsForAdmin(mockRequests, { searchQuery: 'été' });
      expect(result).toHaveLength(1);
      expect(result[0].title).toContain('été');
    });
  });

  describe('formatRequestForCalendar', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return null for refused requests', () => {
      const refusedRequest = mockRequests.find(req => req.status === 'refusée')!;
      const result = formatRequestForCalendar(refusedRequest);
      expect(result).toBeNull();
    });

    it('should format approved request correctly', () => {
      const approvedRequest = mockRequests.find(req => req.status === 'approuvée')!;
      const result = formatRequestForCalendar(approvedRequest);
      expect(result).toBeTruthy();
      expect(result!.id).toBe(approvedRequest.id);
      expect(result!.title).toBe(approvedRequest.title);
    });
  });

  describe('parseRequestBody (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should parse JSON body', async () => {
      const req = mockRequest({ name: 'test', id: 1 });
      const result = await parseRequestBody(req as any);
      
      expect(result).toEqual({ name: 'test', id: 1 });
    });

    it('should handle empty body', async () => {
      const req = mockRequest(null);
      const result = await parseRequestBody(req as any);
      
      expect(result).toBeNull();
    });

    it('should handle parsing errors', async () => {
      const req = {
        json: jest.fn().mockRejectedValue(new Error('Invalid JSON'))
      };
      
      const result = await parseRequestBody(req as any);
      expect(result).toBeNull();
    });
  });

  describe('validateRequest', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should validate required fields', () => {
      const data = { name: 'test', email: 'test@example.com' };
      const required = ['name', 'email'];
      
      const result = validateRequest(data, required);
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect missing fields', () => {
      const data = { name: 'test' };
      const required = ['name', 'email', 'phone'];
      
      const result = validateRequest(data, required);
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Missing required field: email');
      expect(result.errors).toContain('Missing required field: phone');
    });

    it('should handle validation schema', () => {
      const data = { email: 'invalid-email' };
      const schema = {
        email: (value: string) => value.includes('@') ? null : 'Invalid email format'
      };
      
      const result = validateRequest(data, [], schema);
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Invalid email format');
    });
  });

  describe('extractHeaders', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should extract request headers', () => {
      const req = mockRequest({}, {
        'authorization': 'Bearer token123',
        'content-type': 'application/json',
        'user-agent': 'test-agent'
      });
      
      const result = extractHeaders(req as any);
      expect(result.authorization).toBe('Bearer token123');
      expect(result['content-type']).toBe('application/json');
    });

    it('should handle missing headers', () => {
      const req = mockRequest({});
      const result = extractHeaders(req as any);
      expect(Object.keys(result)).toHaveLength(0);
    });
  });

  describe('buildResponse', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should build success response', () => {
      const data = { id: 1, name: 'test' };
      const result = buildResponse(data);
      
      expect(result).toEqual({
        success: true,
        data,
        status: 200,
        timestamp: expect.any(String)
      });
    });

    it('should build error response', () => {
      const result = buildResponse(null, 'Error occurred', 400);
      
      expect(result).toEqual({
        success: false,
        error: 'Error occurred',
        status: 400,
        timestamp: expect.any(String)
      });
    });

    it('should include metadata', () => {
      const metadata = { requestId: 'req-123', duration: 150 };
      const result = buildResponse({ test: true }, null, 200, metadata);
      
      expect(result.metadata).toEqual(metadata);
    });
  });

  describe('sanitizeInput', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should sanitize string input', () => {
      const input = '<script>alert("xss")</script>Hello';
      const result = sanitizeInput(input);
      
      expect(result).not.toContain('<script>');
      expect(result).toContain('Hello');
    });

    it('should handle object input', () => {
      const input = {
        name: '<b>Test</b>',
        description: 'Safe text',
        nested: { value: '<img src="x" onerror="alert(1)">' }
      };
      
      const result = sanitizeInput(input);
      expect(result.name).not.toContain('<b>');
      expect(result.description).toBe('Safe text');
      expect(result.nested.value).not.toContain('onerror');
    });

    it('should handle array input', () => {
      const input = ['<script>test</script>', 'safe text', '<div>content</div>'];
      const result = sanitizeInput(input) as string[];
      
      expect(result[0]).not.toContain('<script>');
      expect(result[1]).toBe('safe text');
      expect(result[2]).not.toContain('<div>');
    });

    it('should handle null/undefined', () => {
      expect(sanitizeInput(null)).toBeNull();
      expect(sanitizeInput(undefined)).toBeUndefined();
      expect(sanitizeInput('')).toBe('');
    });
  });
});