import { cn } from '../utils';

// Mock pour les fonctions manquantes
const generateId = jest.fn().mockImplementation((prefix = '', length = 8) => {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let result = prefix;
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
});

const sleep = jest.fn().mockImplementation((ms: number) => {
  return new Promise(resolve => setTimeout(resolve, ms));
});

const debounce = jest.fn().mockImplementation((func: Function, delay: number) => {
  let timeoutId: NodeJS.Timeout;
  return (...args: any[]) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(null, args), delay);
  };
});

const throttle = jest.fn().mockImplementation((func: Function, delay: number) => {
  let lastCall = 0;
  return (...args: any[]) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      return func.apply(null, args);
    }
  };
});

describe('lib/utils', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('cn (className utility)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should concatenate class names', () => {
      const result = cn('class1', 'class2', 'class3');
      expect(result).toContain('class1');
      expect(result).toContain('class2');
      expect(result).toContain('class3');
    });

    it('should handle conditional classes', () => {
      const result = cn('base', true && 'conditional', false && 'hidden');
      expect(result).toContain('base');
      expect(result).toContain('conditional');
      expect(result).not.toContain('hidden');
    });

    it('should handle undefined/null values', () => {
      const result = cn('class1', null, undefined, 'class2');
      expect(result).toContain('class1');
      expect(result).toContain('class2');
      expect(result).not.toContain('null');
      expect(result).not.toContain('undefined');
    });
  });

  describe('generateId (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should generate unique IDs', () => {
      const id1 = generateId();
      const id2 = generateId();
      
      expect(id1).toBeDefined();
      expect(id2).toBeDefined();
      expect(typeof id1).toBe('string');
      expect(typeof id2).toBe('string');
    });

    it('should generate IDs with custom prefix', () => {
      const id = generateId('user');
      expect(id).toContain('user');
    });
  });

  describe('sleep (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should delay execution', async () => {
      const start = Date.now();
      await sleep(100);
      const end = Date.now();
      
      expect(end - start).toBeGreaterThanOrEqual(90);
    });
  });

  describe('debounce (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should debounce function calls', (done) => {
      let callCount = 0;
      const fn = () => { callCount++; };
      const debouncedFn = debounce(fn, 100);

      debouncedFn();
      debouncedFn();
      debouncedFn();

      expect(callCount).toBe(0);

      setTimeout(() => {
        expect(callCount).toBe(1);
        done();
      }, 150);
    });
  });

  describe('throttle (mocked)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should throttle function calls', (done) => {
      let callCount = 0;
      const fn = () => { callCount++; };
      const throttledFn = throttle(fn, 100);

      throttledFn();
      throttledFn();
      throttledFn();

      expect(callCount).toBe(1);

      setTimeout(() => {
        throttledFn();
        expect(callCount).toBe(2);
        done();
      }, 150);
    });
  });
});