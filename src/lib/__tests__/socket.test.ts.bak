import { initSocket, NextApiResponseWithSocket } from '../socket';
import { verifyAuthToken } from '../auth-server-utils';
import { Server as SocketIOServer } from 'socket.io';

// Mocks
jest.mock('../auth-server-utils');
jest.mock('socket.io', () => {
    return {
        Server: jest.fn().mockImplementation(() => mockIoInstance)
    };
});

// Mock d'une instance socket.io
const mockIoInstance = {
    on: jest.fn(),
    use: jest.fn(),
    to: jest.fn().mockReturnThis(),
    emit: jest.fn()
};

// Mock d'un socket
const createMockSocket = (id: string, auth: any = {}) => ({
    id,
    handshake: {
        auth
    },
    data: {},
    join: jest.fn(),
    leave: jest.fn(),
    on: jest.fn(),
    emit: jest.fn(),
    disconnect: jest.fn()
});

describe('WebSocket Server', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    let mockResponse: NextApiResponseWithSocket;

    beforeEach(() => {
    jest.clearAllMocks();
        // Réinitialiser les mocks
        jest.clearAllMocks();

        // Créer un mock de réponse avec un serveur
        mockResponse = {
            socket: {
                server: {
                    io: undefined
                }
            }
        } as any;

        // Reset de mockIoInstance
        Object.keys(mockIoInstance).forEach(key => {
            if (typeof mockIoInstance[key as keyof typeof mockIoInstance] === 'function') {
                (mockIoInstance[key as keyof typeof mockIoInstance] as jest.Mock).mockClear();
            }
        });
    });

    it('initialise le serveur WebSocket correctement', () => {
        const io = initSocket(mockResponse);

        expect(io).toBe(mockIoInstance);
        expect(mockResponse.socket.server.io).toBe(mockIoInstance);
    });

    it('utilise le serveur existant si disponible', () => {
        // Définir une instance io existante sur le serveur
        const existingIo = { existingInstance: true };
        mockResponse.socket.server.io = existingIo as any;

        const io = initSocket(mockResponse);

        expect(io).toBe(existingIo);
        // Le constructeur ne doit pas être appelé
        expect(require('socket.io').Server).not.toHaveBeenCalled();
    });

    it('configure le middleware d'authentification', () => {
        initSocket(mockResponse);

        expect(mockIoInstance.use).toHaveBeenCalledTimes(1);

        // Tester le middleware d'authentification
        const middleware = (mockIoInstance.use as jest.Mock).mock.calls[0][0];
        expect(typeof middleware).toBe('function');
    });

    describe('Middleware d'authentification WebSocket', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        let authMiddleware: Function;

        beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
            // Récupérer le middleware d'authentification
            initSocket(mockResponse);
            authMiddleware = (mockIoInstance.use as jest.Mock).mock.calls[0][0];
        });

        it('autorise la connexion sans token (authentification différée)', async () => {
            const socket = createMockSocket('no-token-socket', {});
            const next = jest.fn();

            await authMiddleware(socket, next);

            expect(socket.data.authenticated).toBe(false);
            expect(next).toHaveBeenCalled();
        });

        it('authentifie un utilisateur avec un token valide', async () => {
            const socket = createMockSocket('valid-token-socket', {
                userId: 123,
                token: 'valid-token'
            });
            const next = jest.fn();

            // Configurer le mock de vérification du token
            (verifyAuthToken as jest.Mock).mockResolvedValue({
                authenticated: true,
                userId: 123,
                role: 'USER'
            });

            await authMiddleware(socket, next);

            expect(verifyAuthToken).toHaveBeenCalledWith('valid-token');
            expect(socket.data.authenticated).toBe(true);
            expect(socket.data.userId).toBe(123);
            expect(socket.data.authToken).toBe('valid-token');
            expect(socket.join).toHaveBeenCalledWith('user_123');
            expect(next).toHaveBeenCalled();
        });

        it('n'authentifie pas avec un token invalide', async () => {
            const socket = createMockSocket('invalid-token-socket', {
                userId: 123,
                token: 'invalid-token'
            });
            const next = jest.fn();

            // Configurer le mock de vérification du token
            (verifyAuthToken as jest.Mock).mockResolvedValue({
                authenticated: false,
                error: 'Token invalide'
            });

            await authMiddleware(socket, next);

            expect(verifyAuthToken).toHaveBeenCalledWith('invalid-token');
            expect(socket.data.authenticated).toBe(false);
            expect(socket.join).not.toHaveBeenCalled();
            expect(next).toHaveBeenCalled(); // Autorise quand même la connexion pour authentification ultérieure
        });

        it('gère les erreurs lors de la vérification', async () => {
            const socket = createMockSocket('error-socket', {
                userId: 123,
                token: 'error-token'
            });
            const next = jest.fn();

            // Simuler une erreur lors de la vérification
            (verifyAuthToken as jest.Mock).mockRejectedValue(new Error('Erreur pendant la vérification'));

            await authMiddleware(socket, next);

            expect(verifyAuthToken).toHaveBeenCalledWith('error-token');
            expect(socket.data.authenticated).toBe(false);
            expect(next).toHaveBeenCalled(); // Continue malgré l'erreur
        });
    });

    describe('Gestion des événements WebSocket', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

        let connectionHandler: Function;

        beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllMocks();
            // Récupérer le gestionnaire de connexion
            initSocket(mockResponse);
            connectionHandler = (mockIoInstance.on as jest.Mock).mock.calls[0][1];
        });

        it('configure les gestionnaires d'événements à la connexion', () => {
            const socket = createMockSocket('test-socket');

            connectionHandler(socket);

            // Vérifier que les gestionnaires d'événements sont configurés
            expect(socket.on).toHaveBeenCalledWith('USER_AUTHENTICATION_WEBSOCKET', expect.any(Function));
            expect(socket.on).toHaveBeenCalledWith('join_room', expect.any(Function));
            expect(socket.on).toHaveBeenCalledWith('leave_room', expect.any(Function));
            expect(socket.on).toHaveBeenCalledWith('disconnect', expect.any(Function));
        });

        it('gère l'événement USER_AUTHENTICATION_WEBSOCKET avec token valide', async () => {
            const socket = createMockSocket('auth-socket');
            socket.data.rooms = [];

            connectionHandler(socket);

            // Récupérer le gestionnaire d'authentification
            const authHandler = (socket.on as jest.Mock).mock.calls.find(
                call => call[0] === 'USER_AUTHENTICATION_WEBSOCKET'
            )[1];

            // Configurer le mock de vérification du token
            (verifyAuthToken as jest.Mock).mockResolvedValue({
                authenticated: true,
                userId: 456,
                role: 'USER'
            });

            // Appeler le gestionnaire avec des données d'authentification
            await authHandler({
                userId: 456,
                token: 'valid-user-token'
            });

            // Vérifier l'authentification
            expect(verifyAuthToken).toHaveBeenCalledWith('valid-user-token');
            expect(socket.data.authenticated).toBe(true);
            expect(socket.data.userId).toBe(456);
            expect(socket.data.authToken).toBe('valid-user-token');
            expect(socket.join).toHaveBeenCalledWith('user_456');
            expect(socket.emit).not.toHaveBeenCalledWith('auth_error', expect.any(String));
        });

        it('rejette l'authentification avec token invalide', async () => {
            const socket = createMockSocket('invalid-auth-socket');

            connectionHandler(socket);

            // Récupérer le gestionnaire d'authentification
            const authHandler = (socket.on as jest.Mock).mock.calls.find(
                call => call[0] === 'USER_AUTHENTICATION_WEBSOCKET'
            )[1];

            // Configurer le mock de vérification du token
            (verifyAuthToken as jest.Mock).mockResolvedValue({
                authenticated: false,
                error: 'Token invalide'
            });

            // Appeler le gestionnaire avec des données d'authentification
            await authHandler({
                userId: 456,
                token: 'invalid-user-token'
            });

            // Vérifier le rejet
            expect(socket.data.authenticated).toBeFalsy();
            expect(socket.join).not.toHaveBeenCalled();
            expect(socket.emit).toHaveBeenCalledWith('auth_error', 'Token invalide');
        });

        it('gère l'événement join_room correctement', () => {
            const socket = createMockSocket('join-room-socket');
            socket.data.authenticated = true;
            socket.data.rooms = ['existing_room'];

            connectionHandler(socket);

            // Récupérer le gestionnaire de join_room
            const joinRoomHandler = (socket.on as jest.Mock).mock.calls.find(
                call => call[0] === 'join_room'
            )[1];

            // Appeler le gestionnaire pour rejoindre une room
            joinRoomHandler('new_room');

            // Vérifier que la room est jointe
            expect(socket.join).toHaveBeenCalledWith('new_room');
            expect(socket.data.rooms).toContain('existing_room');
            expect(socket.data.rooms).toContain('new_room');
        });

        it('refuse join_room pour les utilisateurs non authentifiés', () => {
            const socket = createMockSocket('unauthenticated-socket');
            socket.data.authenticated = false;

            connectionHandler(socket);

            // Récupérer le gestionnaire de join_room
            const joinRoomHandler = (socket.on as jest.Mock).mock.calls.find(
                call => call[0] === 'join_room'
            )[1];

            // Appeler le gestionnaire pour rejoindre une room
            joinRoomHandler('restricted_room');

            // Vérifier que la room n'est pas jointe
            expect(socket.join).not.toHaveBeenCalled();
            expect(socket.emit).toHaveBeenCalledWith('auth_error', expect.any(String));
        });

        it('gère l'événement leave_room correctement', () => {
            const socket = createMockSocket('leave-room-socket');
            socket.data.rooms = ['room_to_leave', 'other_room'];

            connectionHandler(socket);

            // Récupérer le gestionnaire de leave_room
            const leaveRoomHandler = (socket.on as jest.Mock).mock.calls.find(
                call => call[0] === 'leave_room'
            )[1];

            // Appeler le gestionnaire pour quitter une room
            leaveRoomHandler('room_to_leave');

            // Vérifier que la room est quittée
            expect(socket.leave).toHaveBeenCalledWith('room_to_leave');
            expect(socket.data.rooms).not.toContain('room_to_leave');
            expect(socket.data.rooms).toContain('other_room');
        });
    });
}); 