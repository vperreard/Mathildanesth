import { 
  getErrorMessage,
  getErrorSuggestion,
  getFullErrorInfo,
  translateTechnicalError,
  GENERAL_ERROR_MESSAGES,
  APP_ERROR_MESSAGES
} from '../errorMessages';

describe('errorMessages utils', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('GENERAL_ERROR_MESSAGES constants', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should define common error messages', () => {
      expect(GENERAL_ERROR_MESSAGES).toBeDefined();
      expect(typeof GENERAL_ERROR_MESSAGES).toBe('object');
      
      // Test that it contains common error types
      expect(GENERAL_ERROR_MESSAGES.network_error).toBeDefined();
      expect(GENERAL_ERROR_MESSAGES.unauthorized).toBeDefined();
      expect(GENERAL_ERROR_MESSAGES.validation_error).toBeDefined();
      expect(typeof GENERAL_ERROR_MESSAGES.network_error.message).toBe('string');
    });
  });

  describe('getErrorMessage', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return error message for known error codes', () => {
      const result = getErrorMessage('validation_error');
      expect(typeof result).toBe('string');
      expect(result.length).toBeGreaterThan(0);
      expect(result).toBe('Le formulaire contient des erreurs');
    });

    it('should return default message for unknown error codes', () => {
      const result = getErrorMessage('UNKNOWN_ERROR_CODE');
      expect(typeof result).toBe('string');
      expect(result).toBe('Une erreur inattendue est survenue');
    });

    it('should handle null/undefined input', () => {
      const result1 = getErrorMessage(null as any);
      const result2 = getErrorMessage(undefined as any);
      
      expect(typeof result1).toBe('string');
      expect(typeof result2).toBe('string');
    });
  });

  describe('getErrorSuggestion', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return suggestion for known error codes', () => {
      const result = getErrorSuggestion('network_error');
      expect(typeof result).toBe('string');
      expect(result).toBe('Vérifiez votre connexion internet et réessayez');
    });

    it('should return undefined for unknown error codes', () => {
      const result = getErrorSuggestion('UNKNOWN_ERROR_CODE');
      expect(result).toBeUndefined();
    });
  });

  describe('getFullErrorInfo', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return full error info for known error codes', () => {
      const result = getFullErrorInfo('network_error');
      
      expect(result).toHaveProperty('message');
      expect(result).toHaveProperty('suggestion');
      expect(result).toHaveProperty('priority');
      expect(result).toHaveProperty('category');
      expect(result.category).toBe('network');
    });

    it('should handle custom default message', () => {
      const customDefault = 'Custom error message';
      const result = getFullErrorInfo('UNKNOWN_ERROR_CODE', customDefault);
      
      expect(result.message).toBe('Une erreur inattendue est survenue');
    });
  });

  describe('translateTechnicalError', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should translate network errors', () => {
      const error = new Error('Network Error');
      const result = translateTechnicalError(error);
      expect(result).toBe('Impossible de se connecter au serveur');
    });

    it('should translate timeout errors', () => {
      const error = new Error('Request timeout');
      const result = translateTechnicalError(error);
      expect(result).toBe('La requête a pris trop de temps');
    });

    it('should translate 401 errors', () => {
      const error = new Error('401 Unauthorized');
      const result = translateTechnicalError(error);
      expect(result).toBe('Vous n'êtes pas autorisé à accéder à cette ressource');
    });

    it('should handle string errors', () => {
      const result = translateTechnicalError('Something went wrong');
      expect(typeof result).toBe('string');
      expect(result).toBe('Something went wrong');
    });
  });

  describe('Error message localization', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should return French error messages', () => {
      const result = getErrorMessage('network_error');
      expect(result).toMatch(/français|Impossible|Veuillez|erreur|connexion/i);
    });
  });

  describe('APP_ERROR_MESSAGES constants', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should define app-specific error messages', () => {
      expect(APP_ERROR_MESSAGES).toBeDefined();
      expect(typeof APP_ERROR_MESSAGES).toBe('object');
      
      // Test app-specific errors
      expect(APP_ERROR_MESSAGES.quota_exceeded).toBeDefined();
      expect(APP_ERROR_MESSAGES.invalid_date_range).toBeDefined();
      expect(typeof APP_ERROR_MESSAGES.quota_exceeded.message).toBe('string');
    });
  });

  describe('Error severity handling', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

    it('should categorize error severity', () => {
      const maintenanceInfo = getFullErrorInfo('maintenance');
      const unknownInfo = getFullErrorInfo('unknown');
      
      expect(maintenanceInfo.priority).toBeLessThan(unknownInfo.priority);
    });
  });
});