generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- NOUVELLES ÉNUMÉRATIONS ---
enum ActivityCategory {
  BLOC_OPERATOIRE
  CONSULTATION
  GARDE
  ASTREINTE
  REUNION
  FORMATION
  ADMINISTRATIF
  AUTRE
}

enum Period {
  MATIN
  APRES_MIDI
  JOURNEE_ENTIERE
  // NUIT // Optionnel pour plus tard
}

enum BlocPlanningStatus {
  DRAFT
  VALIDATION_REQUESTED
  VALIDATED
  MODIFIED_AFTER_VALIDATION
  LOCKED
  ARCHIVED
}

enum BlocStaffRole {
  MAR
  IADE
}

enum ConflictSeverity {
  WARNING
  ERROR
}

// AJOUTS POUR TRAME MODELE
enum RecurrenceTypeTrame {
  AUCUNE
  HEBDOMADAIRE
  // MENSUELLE // Pour plus tard si besoin
}

enum TypeSemaineTrame {
  TOUTES
  PAIRES
  IMPAIRES
}

// Nouvelle énumération pour les rôles des trames modèles
enum TrameRoleType {
  MAR
  IADE
  CHIRURGIEN
  TOUS // Option par défaut ou si la trame s'applique à tous
}

// --- NOUVEAUX MODÈLES POUR LES TRAMES DE PLANNING BLOC (isolés) ---
model TrameModele {
  id           Int                         @id @default(autoincrement())
  name         String                      @unique
  description  String?
  siteId       String?
  site         Site?                       @relation("SiteTrameModeles", fields: [siteId], references: [id])
  
  isActive     Boolean                     @default(true)

  dateDebutEffet      DateTime
  dateFinEffet        DateTime?
  recurrenceType      RecurrenceTypeTrame @default(HEBDOMADAIRE)
  joursSemaineActifs  Int[]
  typeSemaine         TypeSemaineTrame @default(TOUTES)

  // Ajout du champ roles
  roles               TrameRoleType[] @default([TOUS])
  
  // Champ pour stocker les variations et d'autres données JSON personnalisées
  detailsJson         Json?

  affectations AffectationModele[]
  createdAt    DateTime                    @default(now())
  updatedAt    DateTime                    @updatedAt

  @@map("trame_modeles")
}

model AffectationModele {
  id                  Int               @id @default(autoincrement())
  trameModeleId       Int
  trameModele         TrameModele       @relation(fields: [trameModeleId], references: [id], onDelete: Cascade)

  activityTypeId      String
  activityType        ActivityType      @relation("ActivityTypeAffectationModeles", fields: [activityTypeId], references: [id])

  jourSemaine         DayOfWeek
  periode             Period
  typeSemaine         TypeSemaineTrame

  operatingRoomId     Int?
  operatingRoom       OperatingRoom?    @relation("OperatingRoomAffectationModeles", fields: [operatingRoomId], references: [id], onDelete: SetNull)
  locationId          Int?

  priorite            Int      @default(5)
  isActive            Boolean  @default(true)
  detailsJson         Json?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  personnelRequis     PersonnelRequisModele[]

  @@map("affectation_modeles")
}

model PersonnelRequisModele {
  id                        Int      @id @default(autoincrement())
  affectationModeleId       Int
  affectationModele         AffectationModele @relation(fields: [affectationModeleId], references: [id], onDelete: Cascade)

  roleGenerique             String
  professionalRoleId        String?
  professionalRoleConfig    ProfessionalRoleConfig? @relation("RoleConfigPourPersonnelRequis", fields: [professionalRoleId], references: [code])
  specialtyId               Int?
  specialty                 Specialty? @relation("SpecialtyPourPersonnelRequis", fields: [specialtyId], references: [id])
  
  nombreRequis              Int      @default(1)

  personnelHabituelUserId   Int?
  userHabituel              User?    @relation("UserHabituelPourPersonnelRequis", fields: [personnelHabituelUserId], references: [id], onDelete: SetNull)
  personnelHabituelSurgeonId Int?
  surgeonHabituel           Surgeon? @relation("SurgeonHabituelPourPersonnelRequis", fields: [personnelHabituelSurgeonId], references: [id], onDelete: SetNull)
  personnelHabituelNomExterne String?
  
  notes                       String?
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt

  @@map("personnel_requis_modeles")
}

// --- NOUVEAUX MODÈLES SPÉCIFIQUES AU PLANNING DU BLOC OPÉRATOIRE V2 ---
model BlocDayPlanning {
  id     String             @id @default(uuid())
  date   DateTime
  siteId String
  site   Site               @relation(fields: [siteId], references: [id])
  status BlocPlanningStatus @default(DRAFT)

  assignments BlocRoomAssignment[]
  conflicts   BlocPlanningConflict[]

  lockedAt       DateTime?
  lockedByUserId Int?
  // lockedByUser   User? @relation(fields: [lockedByUserId], references: [id])

  validatedAt       DateTime?
  validatedByUserId Int?
  // validatedByUser User? @relation(fields: [validatedByUserId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([siteId, date])
  @@map("bloc_day_plannings")
}

model BlocRoomAssignment {
  id                String          @id @default(uuid())
  blocDayPlanningId String
  blocDayPlanning   BlocDayPlanning @relation(fields: [blocDayPlanningId], references: [id], onDelete: Cascade)

  operatingRoomId Int
  operatingRoom   OperatingRoom @relation(fields: [operatingRoomId], references: [id])
  period          Period

  chirurgienId Int?
  surgeon      Surgeon? @relation(fields: [chirurgienId], references: [id])

  expectedSpecialty String?

  staffAssignments BlocStaffAssignment[]

  sourceBlocTrameAffectationId Int?
  // sourceBlocTrameAffectation BlocAffectationHabituelle? @relation(fields: [sourceBlocTrameAffectationId], references: [id], onDelete: SetNull) 

  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bloc_room_assignments")
}

model BlocStaffAssignment {
  id                   String             @id @default(uuid())
  blocRoomAssignmentId String
  blocRoomAssignment   BlocRoomAssignment @relation(fields: [blocRoomAssignmentId], references: [id], onDelete: Cascade)

  userId Int
  user   User          @relation(fields: [userId], references: [id])
  role   BlocStaffRole

  isPrimaryAnesthetist Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bloc_staff_assignments")
}

model BlocPlanningConflict {
  id                String          @id @default(uuid())
  blocDayPlanningId String
  blocDayPlanning   BlocDayPlanning @relation(fields: [blocDayPlanningId], references: [id], onDelete: Cascade)

  relatedRoomAssignmentId  String?
  relatedStaffAssignmentId String?
  relatedUserId            Int?
  relatedSurgeonId         Int?

  type     String
  message  String
  severity ConflictSeverity

  isResolved       Boolean   @default(false)
  resolvedAt       DateTime?
  resolvedByUserId Int?
  resolvedByUser   User?     @relation("ResolvedBy", fields: [resolvedByUserId], references: [id], onDelete: SetNull)
  resolutionNotes  String?

  isForceResolved       Boolean   @default(false)
  forceResolvedAt       DateTime?
  forceResolvedByUserId Int?
  forceResolvedByUser   User?     @relation("ForcedBy", fields: [forceResolvedByUserId], references: [id], onDelete: SetNull)
  forceResolutionNotes  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bloc_planning_conflicts")
}

model User {
  id                            Int                         @id @default(autoincrement())
  nom                           String
  prenom                        String
  login                         String                      @unique
  email                         String                      @unique
  password                      String
  role                          Role                        @default(USER)
  professionalRole              ProfessionalRole
  tempsPartiel                  Boolean                     @default(false)
  pourcentageTempsPartiel       Float?
  dateEntree                    DateTime?
  dateSortie                    DateTime?
  actif                         Boolean                     @default(true)
  createdAt                     DateTime                    @default(now())
  updatedAt                     DateTime                    @updatedAt
  mustChangePassword            Boolean                     @default(false)
  phoneNumber                   String?
  alias                         String?
  workOnMonthType               WeekType?
  workPattern                   WorkPatternType             @default(FULL_TIME)
  joursTravaillesSemaineImpaire Json                        @default("[]")
  joursTravaillesSemainePaire   Json                        @default("[]")
  displayPreferences            Json?
  lastLogin                     DateTime?
  departmentId                  String?
  Absence                       Absence[]
  assignments                   Assignment[]
  dashboards                    Dashboard[]
  duties                        Duty[]
  loginLogs                     LoginLog[]
  notifications                 Notification[]              @relation("UserNotifications")
  onCalls                       OnCall[]
  createdRules                  Rule[]                      @relation("CreatedRules")
  updatedRules                  Rule[]                      @relation("UpdatedRules")
  tramesCreated                 TrameAffectation[]          @relation("CreatedTrames")
  auditLogs                     AuditLog[]
  leaveBalances                 LeaveBalance[]              @relation("UserLeaveBalances")
  approvedLeaves                Leave[]                     @relation("ApprovedLeaves")
  leaves                        Leave[]
  plannedAbsences               PlannedAbsence[]
  validatedAbsences             PlannedAbsence[]            @relation("ValidatedAbsences")
  approvedCarryOvers            QuotaCarryOver[]            @relation("ApprovedCarryOvers")
  quotaCarryOvers               QuotaCarryOver[]            @relation("UserQuotaCarryOvers")
  approvedTransfers             QuotaTransfer[]             @relation("ApprovedTransfers")
  quotaTransfers                QuotaTransfer[]             @relation("UserQuotaTransfers")
  regularAssignments            RegularAssignment[]
  surgeonProfile                Surgeon?
  calendarSettings              UserCalendarSettings?
  department                    Department?                 @relation(fields: [departmentId], references: [id])
  sites                         Site[]                      @relation("SiteUsers")
  blocStaffAssignments          BlocStaffAssignment[]
  blocPlanningConflictsResolved BlocPlanningConflict[]      @relation("ResolvedBy")
  blocPlanningConflictsForced   BlocPlanningConflict[]      @relation("ForcedBy")
  personnelRequisModelesCommeHabituel PersonnelRequisModele[] @relation("UserHabituelPourPersonnelRequis")
  canSuperviseOphtalmo          Boolean                     @default(false)
  canSuperviseEndo              Boolean                     @default(false)

  CreatedIncompatibilities PersonnelIncompatibility[] @relation("CreatedIncompatibilities")
  incompatibilitiesAsUser1 PersonnelIncompatibility[] @relation("User1Incompatibilities")
  incompatibilitiesAsUser2 PersonnelIncompatibility[] @relation("User2Incompatibilities")

  userRequests     UserRequest[]
  assignedRequests UserRequest[] @relation("AssignedRequests")

  // Relation aux compétences utilisateur
  userSkills UserSkill[]

  initiatedSwapRequests AssignmentSwapRequest[] @relation("InitiatedSwapRequests")
  receivedSwapRequests  AssignmentSwapRequest[] @relation("ReceivedSwapRequests")

  assignedSkills UserSkill[] @relation("AssignedSkillsByAdmin")

  createdSimulationScenarios     SimulationScenario[]           @relation("UserSimulationScenarios")
  createdSimulationTemplates     SimulationTemplate[]           @relation("UserSimulationTemplates")

  triggeredNotifications        Notification[]              @relation("TriggeredByUserNotifications")
  authoredMessages              ContextualMessage[]         @relation("AuthoredMessages")

  // Relations pour TeamConfiguration
  teamMembership                TeamConfiguration[]         @relation("TeamMembers")
  teamResponsibilities          TeamConfiguration[]         @relation("TeamResponsibles")

  notificationPreferences       NotificationPreference? @relation("UserNotificationPreferences")

  @@map("users")
}

model Specialty {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  isPediatric Boolean      @default(false)
  assignments Assignment[]
  surgeons    Surgeon[]    @relation("SpecialtyToSurgeon")
  personnelRequisModeles PersonnelRequisModele[] @relation("SpecialtyPourPersonnelRequis")
}

model Surgeon {
  id              Int        @id @default(autoincrement())
  nom             String
  prenom          String
  email           String?    @unique
  phoneNumber     String?
  status          UserStatus @default(ACTIF)
  userId          Int?       @unique
  user            User?      @relation(fields: [userId], references: [id])
  googleSheetName String?

  specialties Specialty[] @relation("SpecialtyToSurgeon")
  sites       Site[]      @relation("SurgeonSites")

  plannedAbsences             PlannedAbsence[]
  preferences                 SurgeonPreference[]
  regularAssignments          RegularAssignment[]
  blocRoomAssignments         BlocRoomAssignment[]
  absences                    Absence[]
  personnelRequisModelesCommeHabituel PersonnelRequisModele[] @relation("SurgeonHabituelPourPersonnelRequis")
  assignments                 Assignment[]                @relation("SurgeonAssignments")
  // Relations pour PersonnelIncompatibility
  incompatibilitiesAsSurgeon1 PersonnelIncompatibility[]  @relation("Surgeon1Incompatibilities")
  incompatibilitiesAsSurgeon2 PersonnelIncompatibility[]  @relation("Surgeon2Incompatibilities")

  @@map("surgeons")
}

model SurgeonPreference {
  id        Int     @id @default(autoincrement())
  name      String
  value     String
  surgeonId Int
  surgeon   Surgeon @relation(fields: [surgeonId], references: [id])

  @@map("preferences")
}

model LoginLog {
  id        Int      @id @default(autoincrement())
  timestamp DateTime @default(now())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PlanningRule {
  id            Int      @id @default(autoincrement())
  category      String
  name          String
  description   String?
  isActive      Boolean  @default(true)
  priority      Int      @default(1)
  conditionJSON Json
  parameterJSON Json
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model OperatingRoom {
  id                 Int      @id @default(autoincrement())
  name               String // Nom usuel de la salle
  number             String   @unique // Numéro officiel/identifiant unique
  description        String?
  roomType           RoomType @default(STANDARD)
  capacity           Int      @default(1) // Capacité standard
  isActive           Boolean  @default(true)
  displayOrder       Int      @default(0)
  colorCode          String? // Pour l'affichage
  supervisionRules   Json? // Règles spécifiques de supervision pour cette salle
  allowedSpecialties String[] @default([]) // Spécialités autorisées

  siteId String
  site   Site   @relation("SiteOperatingRooms", fields: [siteId], references: [id])

  operatingSectorId Int?
  operatingSector   OperatingSector? @relation(fields: [operatingSectorId], references: [id])

  blocRoomAssignments BlocRoomAssignment[]
  assignments         Assignment[]
  affectationModeles  AffectationModele[] @relation("OperatingRoomAffectationModeles")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siteId])
  @@index([operatingSectorId])
  @@map("operating_rooms")
}

model Rule {
  id            String         @id @default(uuid())
  name          String
  description   String?
  type          RuleType
  priority      RulePriority   @default(WARNING)
  isActive      Boolean        @default(false)
  validFrom     DateTime
  validTo       DateTime?
  configuration Json
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  createdBy     Int
  updatedBy     Int?
  createdByUser User           @relation("CreatedRules", fields: [createdBy], references: [id])
  updatedByUser User?          @relation("UpdatedRules", fields: [updatedBy], references: [id])
  conflicts     RuleConflict[] @relation("RuleToConflict")
}

model RuleConflict {
  id                String       @id @default(uuid())
  description       String
  severity          RuleSeverity @default(WARNING)
  detectedAt        DateTime     @default(now())
  resolvedAt        DateTime?
  resolution        String?
  resolutionDetails String?
  rules             Rule[]       @relation("RuleToConflict")
}

model Location {
  id                 Int                 @id @default(autoincrement())
  name               String              @unique
  sector             String?
  isActive           Boolean             @default(true)
  assignments        Assignment[]
  duties             Duty[]
  onCalls            OnCall[]
  regularAssignments RegularAssignment[]
}

model LeaveTypeSetting {
  id               String   @id @default(cuid())
  code             String   @unique
  label            String
  description      String?
  rules            Json?
  isActive         Boolean  @default(true)
  isUserSelectable Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@map("leave_type_settings")
}

model Leave {
  id                 String      @id @default(cuid())
  userId             Int
  startDate          DateTime
  endDate            DateTime
  typeCode           String
  type               LeaveType
  status             LeaveStatus
  reason             String?
  comment            String?
  requestDate        DateTime    @default(now())
  approvalDate       DateTime?
  approvedById       Int?
  countedDays        Float
  calculationDetails Json?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  isRecurring        Boolean?    @default(false)
  parentId           String?
  recurrencePattern  Json?
  approvedBy         User?       @relation("ApprovedLeaves", fields: [approvedById], references: [id])
  parent             Leave?      @relation("RecurringLeaveOccurrences", fields: [parentId], references: [id])
  occurrences        Leave[]     @relation("RecurringLeaveOccurrences")
  user               User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  alerts             LeaveRequestAlert[]

  isHalfDay          Boolean?
  halfDayPeriod      String?

  @@index([userId])
  @@index([startDate, endDate])
  @@index([typeCode])
  @@index([parentId])
  @@map("leaves")
}

model Duty {
  id         Int       @id @default(autoincrement())
  userId     Int
  date       DateTime
  locationId Int?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  location   Location? @relation(fields: [locationId], references: [id])
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([date])
  @@index([locationId])
}

model OnCall {
  id         Int       @id @default(autoincrement())
  userId     Int
  startDate  DateTime
  endDate    DateTime
  locationId Int?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  location   Location? @relation(fields: [locationId], references: [id])
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([startDate])
  @@index([endDate])
  @@index([locationId])
}

model Assignment {
  id                  String             @id @default(uuid())
  date                DateTime
  userId              Int? // MAR ou IADE
  user                User?              @relation(fields: [userId], references: [id])
  chirurgien          String? // Nom du chirurgien (legacy ou si pas de modèle Surgeon lié)
  salle               String? // Nom de la salle (legacy ou si pas de modèle OperatingRoom lié)
  type                String // Ex: BLOC_OPERATION, CONSULTATION, GARDE_JOUR, GARDE_NUIT, ASTREINTE, REPOS_GARDE, FORMATION, CONGRES, MALADIE, MATERNITE, ABS_AUTORISEE, ABS_NON_AUTORISEE, FERIE
  statut              String? // Ex: PREVU, REALISE, ANNULE
  heureDebut          String? // Format HH:MM
  heureFin            String? // Format HH:MM
  notes               String?
  specialtyId         Int? // Pour lier à une spécialité
  specialty           Specialty?         @relation(fields: [specialtyId], references: [id])
  siteId              String? // Pour lier à un site
  site                Site?              @relation(fields: [siteId], references: [id])
  operatingRoomId     Int? // Pour lier à une salle d'opération spécifique
  operatingRoom       OperatingRoom?     @relation(fields: [operatingRoomId], references: [id])
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  blocDayPlanningId   String? // Ajout pour lier à BlocDayPlanning si nécessaire
  surgeonId           Int?
  surgeon             Surgeon?           @relation("SurgeonAssignments", fields: [surgeonId], references: [id], onDelete: Cascade)
  regularAssignmentId Int?
  regularAssignment   RegularAssignment? @relation("GeneratedFromRegular", fields: [regularAssignmentId], references: [id])
  Location            Location?          @relation(fields: [locationId], references: [id])
  locationId          Int?

  proposedSwapRequests  AssignmentSwapRequest[] @relation("ProposedSwapAssignment")
  requestedSwapRequests AssignmentSwapRequest[] @relation("RequestedSwapAssignment")

  contextualMessages ContextualMessage[] @relation("AssignmentContextualMessages")
  notifications      Notification[]      @relation("NotificationRelatedAssignment")

  @@index([date])
  @@index([userId, date])
  @@index([siteId, date])
  @@map("assignments")
}

model OperatingSector {
  id           Int             @id @default(autoincrement())
  name         String          @unique
  colorCode    String?
  isActive     Boolean         @default(true)
  description  String?
  rules        Json?
  category     SectorCategory  @default(STANDARD)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  siteId       String?
  displayOrder Int?
  rooms        OperatingRoom[]
  site         Site?           @relation(fields: [siteId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([siteId])
}

model UserCalendarSettings {
  id                 String   @id @default(cuid())
  userId             Int      @unique
  defaultView        String   @default("month")
  showWeekends       Boolean  @default(true)
  showHolidays       Boolean  @default(true)
  showRejectedLeaves Boolean  @default(false)
  colorScheme        String   @default("default")
  startWeekOn        String   @default("monday")
  timeFormat         String   @default("24h")
  notifications      Json     @default("{\"email\": true, \"sound\": false, \"browser\": true}")
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id])

  @@map("user_calendar_settings")
}

model ProfessionalRoleConfig {
  id                 String   @id
  code               String   @unique
  label              String
  description        String?
  isActive           Boolean  @default(true)
  displayPreferences Json?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  personnelRequisModeles PersonnelRequisModele[] @relation("RoleConfigPourPersonnelRequis")
}

model TeamConfiguration {
  id            String   @id @default(cuid())
  name          String   @unique
  description   String?
  siteId        String?
  site          Site?    @relation("SiteTeamConfigurations", fields: [siteId], references: [id])
  members       User[]   @relation("TeamMembers")
  responsibles  User[]   @relation("TeamResponsibles")
  rules         Json     // Règles spécifiques à l'équipe
  workingHours  Json?    // Horaires de travail type
  leaveQuotas   Json?    // Quotas de congés spécifiques
  skillsNeeded  Json?    // Compétences requises pour l'équipe
  configuration Json?    // Configuration diverse

  gardes        Json
  consultations Json
  bloc          Json
  conges        Json
  fatigue       Json?
  tempsPartiel  Json?
  iades         Json?
  remplacants   Json?
  preferences   Json?
  statistiques  Json?
  horaires      Json?
  affectations  Json?
  transitions   Json?
  equite        Json?
  alertes       Json?
  algorithme    Json?
  rapports      Json?
  audit         Json?
  
  isDefault     Boolean  @default(false)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("team_configurations")
}

model RegularAssignment {
  id            Int               @id @default(autoincrement())
  trameId       String?
  userId        Int?
  surgeonId     Int?
  locationId    Int?
  siteId        String?
  weekType      WeekType          @default(ALL)
  active        Boolean           @default(true)
  configuration Json?
  type          String
  dayOfWeek     Int               @default(1)
  period        String
  assignments   Assignment[]      @relation("GeneratedFromRegular")
  location      Location?         @relation(fields: [locationId], references: [id])
  surgeon       Surgeon?          @relation(fields: [surgeonId], references: [id])
  trame         TrameAffectation? @relation("TrameAssignments", fields: [trameId], references: [id])
  user          User?             @relation(fields: [userId], references: [id])
  site          Site?             @relation(fields: [siteId], references: [id])

  @@index([userId])
  @@index([surgeonId])
  @@index([trameId])
  @@index([siteId])
  @@index([dayOfWeek, period, weekType])
  @@map("regular_assignments")
}

model TrameAffectation {
  id          String              @id @default(cuid())
  name        String
  description String?
  isActive    Boolean             @default(true)
  startDate   DateTime
  endDate     DateTime?
  createdBy   Int?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  user        User?               @relation("CreatedTrames", fields: [createdBy], references: [id])
  periods     TramePeriod[]
  assignments RegularAssignment[] @relation("TrameAssignments")
}

model TramePeriod {
  id          String            @id @default(uuid())
  name        String
  startTime   String
  endTime     String
  color       String
  isActive    Boolean           @default(true)
  isLocked    Boolean           @default(false)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  trameId     String
  assignments TrameAssignment[]
  trame       TrameAffectation  @relation(fields: [trameId], references: [id], onDelete: Cascade)
}

model TrameAssignment {
  id       String      @id @default(uuid())
  type     String
  name     String
  duration Int
  isActive Boolean     @default(true)
  periodId String
  period   TramePeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  posts    TramePost[]
}

model TramePost {
  id           String          @id @default(uuid())
  type         String
  name         String
  required     Boolean         @default(false)
  maxCount     Int             @default(1)
  minCount     Int             @default(0)
  assignmentId String
  assignment   TrameAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
}

model PlannedAbsence {
  id             Int           @id @default(autoincrement())
  userId         Int?
  surgeonId      Int?
  startDate      DateTime
  endDate        DateTime
  type           AbsenceType
  typeDetail     String?
  impactPlanning Boolean       @default(true)
  priority       Int           @default(5)
  comment        String?
  status         AbsenceStatus
  validatedById  Int?
  notify         Boolean       @default(false)
  importSource   String?
  documents      Json?         @default("[]")
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  surgeon        Surgeon?      @relation(fields: [surgeonId], references: [id])
  user           User?         @relation(fields: [userId], references: [id])
  validatedBy    User?         @relation("ValidatedAbsences", fields: [validatedById], references: [id])

  @@index([userId])
  @@index([surgeonId])
  @@index([startDate, endDate])
  @@index([type, status])
  @@map("planned_absences")
}

model Notification {
  id        String    @id @default(cuid())
  userId    Int // L'utilisateur qui reçoit la notification (doit être Int si User.id est Int)
  user      User      @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  type      NotificationType // NOUVEAU CHAMP: utilise l'énumération

  message   String    // Le contenu textuel de la notification
  link      String?   // Lien optionnel vers l'élément concerné
  isRead    Boolean   @default(false)
  createdAt DateTime  @default(now())

  // Qui a déclenché la notification (optionnel)
  triggeredByUserId Int?
  triggeredByUser   User?     @relation("TriggeredByUserNotifications", fields: [triggeredByUserId], references: [id], onDelete:SetNull)

  // Contexte de la notification (liens optionnels vers les entités concernées)
  relatedAssignmentId String?
  relatedAssignment   Assignment? @relation("NotificationRelatedAssignment", fields: [relatedAssignmentId], references: [id], onDelete:SetNull)

  relatedRequestId String?
  relatedRequest    UserRequest? @relation("NotificationRelatedRequest", fields: [relatedRequestId], references: [id], onDelete:SetNull)

  // Ajoutez d'autres liens contextuels si nécessaire (ex: relatedCommentId)

  @@index([userId, isRead])
  @@map("notifications") // Assurez-vous que le nom de la table est correct
}

model Dashboard {
  id        String   @id @default(cuid())
  userId    Int
  name      String
  widgets   Json
  layout    String   @default("grid")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model Absence {
  id           String      @id @default(cuid())
  userId       Int?
  user         User?       @relation(fields: [userId], references: [id], onDelete: Cascade)
  startDate    DateTime
  endDate      DateTime
  type         LeaveType
  status       LeaveStatus
  reason       String?
  comment      String?
  requestDate  DateTime    @default(now())
  approvalDate DateTime?
  approvedById Int?
  chirurgienId Int?
  surgeon      Surgeon?    @relation(fields: [chirurgienId], references: [id])

  @@index([endDate])
  @@index([startDate])
  @@index([userId])
}

model LeaveBalance {
  id          String    @id @default(cuid())
  userId      Int
  leaveType   LeaveType
  year        Int
  initial     Float     @default(0)
  used        Float     @default(0)
  pending     Float     @default(0)
  remaining   Float     @default(0)
  lastUpdated DateTime  @default(now())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation("UserLeaveBalances", fields: [userId], references: [id])

  @@unique([userId, leaveType, year])
  @@map("leave_balances")
}

model QuotaTransferRule {
  id                    String    @id @default(cuid())
  fromType              LeaveType
  toType                LeaveType
  conversionRate        Float     @default(1.0)
  maxTransferDays       Float?
  maxTransferPercentage Float?
  requiresApproval      Boolean   @default(false)
  authorizedRoles       String[]  @default([])
  isActive              Boolean   @default(true)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([fromType, toType])
  @@map("quota_transfer_rules")
}

model QuotaTransfer {
  id               String    @id @default(cuid())
  userId           Int
  fromType         LeaveType
  toType           LeaveType
  amount           Float
  convertedAmount  Float
  reason           String
  transferDate     DateTime  @default(now())
  status           String    @default("APPROVED")
  requiresApproval Boolean   @default(false)
  approvedById     Int?
  approvalDate     DateTime?
  comments         String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  approvedBy       User?     @relation("ApprovedTransfers", fields: [approvedById], references: [id])
  user             User      @relation("UserQuotaTransfers", fields: [userId], references: [id])

  @@index([userId, fromType, toType])
  @@index([status])
  @@map("quota_transfers")
}

model QuotaCarryOverRule {
  id               String    @id @default(cuid())
  leaveType        LeaveType @unique
  ruleType         String    @default("PERCENTAGE")
  value            Float     @default(100.0)
  maxCarryOverDays Float?
  expirationDays   Int?
  requiresApproval Boolean   @default(false)
  authorizedRoles  String[]  @default([])
  isActive         Boolean   @default(true)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@map("quota_carry_over_rules")
}

model QuotaCarryOver {
  id               String    @id @default(cuid())
  userId           Int
  leaveType        LeaveType
  fromYear         Int
  toYear           Int
  amount           Float
  expiryDate       DateTime?
  status           String    @default("APPROVED")
  requiresApproval Boolean   @default(false)
  approvedById     Int?
  approvalDate     DateTime?
  reason           String?
  comments         String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  approvedBy       User?     @relation("ApprovedCarryOvers", fields: [approvedById], references: [id])
  user             User      @relation("UserQuotaCarryOvers", fields: [userId], references: [id])

  @@index([userId, leaveType])
  @@index([fromYear, toYear])
  @@index([status])
  @@map("quota_carry_overs")
}

model AuditLog {
  id         String   @id @default(cuid())
  action     String
  entityId   String
  entityType String
  userId     Int?
  details    String?
  timestamp  DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id])

  @@index([entityType, entityId])
  @@index([userId])
  @@index([timestamp])
  @@map("audit_logs")
}

model PublicHoliday {
  id          String   @id @default(cuid())
  date        DateTime @db.Date
  name        String
  description String?
  isNational  Boolean  @default(true)
  region      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([date, region])
  @@index([date])
  @@map("public_holidays")
}

model Department {
  id           String   @id @default(cuid())
  name         String
  description  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  contactEmail String?
  contactPhone String?
  isActive     Boolean  @default(true)
  location     String?
  users        User[]

  @@map("departments")
}

model Site {
  id           String   @id @default(uuid())
  name         String   @unique
  description  String?
  isActive     Boolean  @default(true)
  address      String?
  colorCode    String?
  timezone     String   @default("Europe/Paris")
  displayOrder Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  operatingRooms     OperatingRoom[]     @relation("SiteOperatingRooms")
  operatingSectors   OperatingSector[]
  users              User[]              @relation("SiteUsers")
  trameModeles       TrameModele[]       @relation("SiteTrameModeles")
  blocDayPlannings   BlocDayPlanning[]
  UserRequest        UserRequest[]       @relation("SiteUserRequests")

  surgeons           Surgeon[]           @relation("SurgeonSites")
  regularAssignments RegularAssignment[]
  assignments        Assignment[]

  activityTypes ActivityType[] @relation("SiteActivityTypes")

  teamConfigurations TeamConfiguration[] @relation("SiteTeamConfigurations")

  @@map("sites")
}

enum Role {
  USER
  ADMIN_PARTIEL
  ADMIN_TOTAL
}

enum UserStatus {
  ACTIF
  INACTIF
}

enum ProfessionalRole {
  MAR
  IADE
  SECRETAIRE
}

enum WorkPatternType {
  FULL_TIME
  ALTERNATING_WEEKS
  ALTERNATING_MONTHS
  SPECIFIC_DAYS
}

enum WeekType {
  EVEN
  ODD
  ALL
}

enum RuleType {
  LEAVE
  DUTY
  SUPERVISION
  ASSIGNMENT
  ON_CALL
}

enum RulePriority {
  LOW
  WARNING
  HIGH
  CRITICAL
}

enum RuleSeverity {
  ERROR
  WARNING
  INFO
}

enum RotationStrategy {
  ROUND_ROBIN
  LEAST_RECENTLY_ASSIGNED
  BALANCED_LOAD
}

enum LeaveType {
  ANNUAL
  RECOVERY
  TRAINING
  SICK
  MATERNITY
  SPECIAL
  UNPAID
  OTHER
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum DayPeriod {
  MORNING
  AFTERNOON
}

enum TrameType {
  BLOCK
  CONSULTATION
  DUTY
  ON_CALL
}

enum AbsenceType {
  LEAVE
  ILLNESS
  TRAINING
  OTHER
}

enum AbsenceStatus {
  REQUESTED
  VALIDATED
  REJECTED
}

model PersonnelIncompatibility {
  id         String   @id @default(cuid())
  // Personne 1 (peut être un User ou un Surgeon)
  user1Id    Int?
  user1      User?    @relation("User1Incompatibilities", fields: [user1Id], references: [id], onDelete: Cascade)
  surgeon1Id Int?
  surgeon1   Surgeon? @relation("Surgeon1Incompatibilities", fields: [surgeon1Id], references: [id], onDelete: Cascade)

  // Personne 2 (peut être un User ou un Surgeon)
  user2Id    Int?
  user2      User?    @relation("User2Incompatibilities", fields: [user2Id], references: [id], onDelete: Cascade)
  surgeon2Id Int?
  surgeon2   Surgeon? @relation("Surgeon2Incompatibilities", fields: [surgeon2Id], references: [id], onDelete: Cascade)

  type   IncompatibilityType
  reason String? // Motif optionnel

  startDate DateTime? // Période de validité
  endDate   DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdBy     Int? // ID de l'utilisateur qui a créé la règle
  createdByUser User?    @relation("CreatedIncompatibilities", fields: [createdBy], references: [id], onDelete: SetNull) // onDelete: SetNull pour ne pas supprimer l'incompatibilité si l'admin est supprimé
  // S'assurer qu'au moins un ID est fourni pour chaque personne (pas directement faisable avec des attributs simples, logique applicative)
  // Prévenir les incompatibilités avec soi-même (user1Id != user2Id si surgeon1Id et surgeon2Id sont null, etc.) -> logique applicative

  // Index pour les requêtes courantes
  @@index([user1Id, user2Id, type, startDate, endDate])
  @@index([surgeon1Id, surgeon2Id, type, startDate, endDate])
  @@index([user1Id, surgeon2Id, type, startDate, endDate])
  @@map("personnel_incompatibilities")
}

enum IncompatibilityType {
  BLOQUANT // Ne doivent jamais travailler ensemble sur la même vacation/salle
  PREFERENTIEL // À éviter si possible, génère un avertissement
}

enum SectorCategory {
  STANDARD
  HYPERASEPTIQUE
  OPHTALMOLOGIE
  ENDOSCOPIE
}

enum RoomType {
  STANDARD
  FIV
  CONSULTATION
}

model RequestType {
  id                    String        @id @default(uuid())
  name                  String        @unique
  description           String?
  requiresAdminApproval Boolean       @default(true)
  isActive              Boolean       @default(true)
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  userRequests          UserRequest[]

  @@map("request_types")
}

model UserRequest {
  id          String            @id @default(uuid())
  title       String // Titre de la requête
  description String // Description détaillée
  status      UserRequestStatus @default(SUBMITTED)
  adminNotes  String? // Notes de l'administrateur

  userId Int // Qui a fait la demande
  user   User @relation(fields: [userId], references: [id])

  requestTypeId String // Type de requête (lien vers RequestType)
  requestType   RequestType @relation(fields: [requestTypeId], references: [id])

  assignedToId Int? // Optionnel: à qui la tâche est assignée pour traitement
  assignedTo   User? @relation("AssignedRequests", fields: [assignedToId], references: [id])

  siteId String? // Site concerné par la requête, si applicable
  site   Site?   @relation("SiteUserRequests", fields: [siteId], references: [id])

  startDate DateTime?
  endDate   DateTime?
  details   Json?

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  resolvedAt DateTime?

  contextualMessages ContextualMessage[] @relation("UserRequestContextualMessages")
  notifications      Notification[]      @relation("NotificationRelatedRequest")

  @@index([userId, status])
  @@index([requestTypeId, status])
  @@index([assignedToId, status])
  @@map("user_requests")
}

enum UserRequestStatus {
  SUBMITTED
  IN_PROGRESS
  APPROVED
  REJECTED
  COMPLETED
  CANCELLED_BY_USER
}

enum AssignmentSwapStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
  EXPIRED
}

model AssignmentSwapRequest {
  id              String @id @default(cuid())
  initiatorUserId Int
  initiator       User   @relation("InitiatedSwapRequests", fields: [initiatorUserId], references: [id])

  proposedAssignmentId String
  proposedAssignment   Assignment @relation("ProposedSwapAssignment", fields: [proposedAssignmentId], references: [id])

  targetUserId Int?
  targetUser   User? @relation("ReceivedSwapRequests", fields: [targetUserId], references: [id])

  requestedAssignmentId String?
  requestedAssignment   Assignment? @relation("RequestedSwapAssignment", fields: [requestedAssignmentId], references: [id])

  status          AssignmentSwapStatus @default(PENDING)
  message         String?
  responseMessage String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expiresAt DateTime?

  @@index([initiatorUserId])
  @@index([targetUserId])
  @@index([proposedAssignmentId])
  @@index([requestedAssignmentId])
}

// --- MODÈLE POUR LES COMPÉTENCES ---
model Skill {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userSkills UserSkill[] // Relation vers les utilisateurs ayant cette compétence

  @@map("skills")
}

// --- MODÈLE POUR LES COMPÉTENCES UTILISATEUR (TABLE DE JOINTURE) ---
model UserSkill {
  id         String   @id @default(cuid())
  userId     Int // Référence l'ID de l'utilisateur (Int)
  skillId    String // Référence l'ID de la compétence (String CUID)
  assignedAt DateTime @default(now())
  assignedBy Int? // ID de l'utilisateur (admin) qui a assigné la compétence, optionnel

  user            User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  skill           Skill @relation(fields: [skillId], references: [id], onDelete: Cascade)
  assignedByAdmin User? @relation("AssignedSkillsByAdmin", fields: [assignedBy], references: [id], onDelete: SetNull)

  @@unique([userId, skillId], name: "user_skill_unique_constraint") // Assurer que chaque compétence n'est assignée qu'une fois par utilisateur
  @@map("user_skills")
}

model ActivityType {
  id          String           @id @default(uuid())
  name        String           @unique // Ex: "Garde Anesthésie Pontoise", "Consultation Dr. Durand", "Bloc Salle 3"
  code        String           @unique // Ajouté: Code unique pour identification métier
  description String?
  category    ActivityCategory @default(AUTRE)
  color       String? // Pour affichage dans le planning, ex: "#FF5733"
  icon        String? // Nom d'une icône (ex: "BriefcaseIcon") ou slug pour affichage
  isActive    Boolean          @default(true) // Pour pouvoir désactiver sans supprimer

  defaultDurationHours Float?    // Ajouté: Durée par défaut en heures (ex: 4.0, 8.0, 12.0, 24.0)
  defaultPeriod        Period?   // Ajouté: Période par défaut (MATIN, APRES_MIDI, JOURNEE_ENTIERE)

  // Relation Many-to-Many avec Site
  // Une activité peut être disponible sur plusieurs sites, ou aucun (globale)
  // Relation à UN site (un type d'activité appartient à un site, ou à aucun si global)
  site   Site?   @relation("SiteActivityTypes", fields: [siteId], references: [id])
  siteId String? @map("site_id")
  affectationModeles AffectationModele[] @relation("ActivityTypeAffectationModeles")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("activity_types")
}

model SchoolHolidayPeriod {
  id        Int      @id @default(autoincrement())
  name      String // e.g., "Vacances de Pâques 2025 Zone A"
  startDate DateTime @db.Date // Store as Date without time
  endDate   DateTime @db.Date // Store as Date without time
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("school_holiday_periods")
}

model LeaveRequestAlert {
  id             Int      @id @default(autoincrement())
  leaveId        String
  leave          Leave    @relation(fields: [leaveId], references: [id], onDelete: Cascade)
  ruleCode       String // e.g., "MAR_THRESHOLD_OFF_HOLIDAYS_EXCEEDED"
  messageDetails String // e.g., "Currently 3 MAR on leave (threshold: 2)"
  generatedAt    DateTime @default(now())

  @@index([leaveId])
  @@map("leave_request_alerts")
}

// --- MODÈLES POUR LA SIMULATION DE PLANNING ---

model SimulationTemplate {
  id                  String   @id @default(uuid())
  name                String
  description         String?
  isPublic            Boolean  @default(false)  // Si le template peut être utilisé par tous les utilisateurs
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  createdById         Int
  createdBy           User     @relation("UserSimulationTemplates", fields: [createdById], references: [id])
  
  // Paramètres de base du template
  parametersJson      Json     // Mêmes paramètres que SimulationScenario
  
  // Catégorie pour faciliter le classement/filtrage
  category            String?  // Ex: "Vacances scolaires", "Effectif réduit", "Planning été"
  
  @@map("simulation_templates")
}

model SimulationScenario {
  id                  String   @id @default(uuid())
  name                String
  description         String?
  createdAt           DateTime @default(now())
  createdById         Int
  createdBy           User     @relation("UserSimulationScenarios", fields: [createdById], references: [id])

  // Paramètres de la simulation
  // - période de simulation (startDate, endDate)
  // - règles modifiées (IDs ou définitions complètes)
  // - effectifs ajustés (ex: liste d'utilisateurs exclus/ajoutés temporairement)
  // - trames alternatives (IDs de TrameModele à utiliser)
  // - ... autres paramètres spécifiques
  parametersJson      Json
  
  // Référence optionnelle au template utilisé
  templateId          String?
  
  // Optionnel: Si la simulation part d'un snapshot d'un planning existant (ex: BlocDayPlanning)
  // basePlanningSnapshotId String?

  results             SimulationResult[]

  @@map("simulation_scenarios")
}

model SimulationResult {
  id                  String   @id @default(uuid())
  scenarioId          String
  scenario            SimulationScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  
  createdAt           DateTime @default(now())
  
  // Le planning "virtuel" généré.
  // Pourrait être une structure JSON complexe ou pointer vers des versions "simulées" des modèles de planning actuels.
  // Pour une première version, un JSON stockant les affectations simulées pourrait suffire.
  // Exemple: { assignments: [...], dailyStats: {...} }
  generatedPlanningData Json
  
  // Statistiques clés issues de la simulation
  // Exemple: { coverageRate: 0.95, ruleViolations: 5, totalAssignments: 150 }
  statisticsJson      Json
  
  // Alertes de conflits potentiels identifiés
  // Exemple: [{ ruleId: "...", message: "...", severity: "ERROR" }]
  conflictAlertsJson  Json?
  
  // Optionnel: Données de comparaison avec un planning de référence (actuel ou autre scénario)
  // Exemple: { diffAssignments: [...], kpiChanges: {...} }
  comparisonDataJson  Json?

  // État de la simulation (utile si le calcul est long/asynchrone)
  status              SimulationStatus @default(PENDING)
  errorMessage        String? // En cas d'échec de la simulation

  @@map("simulation_results")
}

enum SimulationStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

// --- FIN MODÈLES POUR LA SIMULATION DE PLANNING ---

// NOUVELLE ÉNUMÉRATION POUR LES TYPES DE NOTIFICATION
enum NotificationType {
  // Messages & Commentaires
  NEW_CONTEXTUAL_MESSAGE
  MENTION_IN_MESSAGE
  NEW_PLANNING_COMMENT

  // Échanges d'affectations
  ASSIGNMENT_SWAP_REQUEST_RECEIVED
  ASSIGNMENT_SWAP_REQUEST_ACCEPTED
  ASSIGNMENT_SWAP_REQUEST_REJECTED
  ASSIGNMENT_SWAP_REQUEST_APPROVED_ADMIN
  ASSIGNMENT_SWAP_REQUEST_CANCELLED

  // Infos & Alertes Planning
  ASSIGNMENT_REMINDER
  PLANNING_UPDATED_IMPACTING_YOU
  LEAVE_REQUEST_STATUS_CHANGED // Pourrait déjà exister sous une autre forme
  NEW_OPEN_SHIFT_AVAILABLE

  // Admin/Système
  TEAM_PLANNING_PUBLISHED
  RULE_CONFLICT_DETECTED_ADMIN

  // Notifications générales (à ajouter si besoin)
  GENERAL_INFO
  SYSTEM_ALERT
}

// --- NOUVEAU MODÈLE POUR LA MESSAGERIE CONTEXTUELLE ---
model ContextualMessage {
  id        String   @id @default(cuid())
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  authorId  Int
  author    User     @relation("AuthoredMessages", fields: [authorId], references: [id], onDelete: Cascade)

  assignmentId String?
  assignment   Assignment? @relation("AssignmentContextualMessages", fields: [assignmentId], references: [id], onDelete: Cascade)

  contextDate DateTime? @db.Date

  requestId String?
  request   UserRequest? @relation("UserRequestContextualMessages", fields: [requestId], references: [id], onDelete: Cascade)

  parentId  String?
  parent    ContextualMessage?  @relation("Thread", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies   ContextualMessage[] @relation("Thread")

  @@index([assignmentId])
  @@index([contextDate])
  @@index([requestId])
  @@index([authorId])
  @@map("contextual_messages")
}

// --- NOUVEAU MODÈLE POUR LES COMMENTAIRES SUR PLANNING (Optionnel, si distinct de ContextualMessage) ---
// Si nous décidons que les commentaires de planning sont suffisamment différents
// pour justifier leur propre modèle. Sinon, on utilise ContextualMessage avec contextDate.
// Pour l'instant, je vais commenter cette partie et nous pourrons l'activer si besoin.
/*
model PlanningComment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  authorId  Int
  author    User     @relation("AuthoredPlanningComments", fields: [authorId], references: [id], onDelete: Cascade)

  date      DateTime @db.Date // Commentaire pour un jour spécifique

  // Optionnel: portée (site, équipe, etc.)
  // siteId    String?
  // site      Site?    @relation(fields: [siteId], references: [id])

  @@index([date])
  @@index([authorId])
  @@map("planning_comments")
}
*/

// --- MODÈLE POUR LES PRÉFÉRENCES DE NOTIFICATIONS ---
model NotificationPreference {
  id        String   @id @default(cuid())
  userId    Int
  user      User     @relation("UserNotificationPreferences", fields: [userId], references: [id], onDelete: Cascade)
  
  // Types de notifications
  assignmentReminders          Boolean @default(true)  // Rappels d'affectations
  assignmentSwapRequests       Boolean @default(true)  // Demandes d'échange
  assignmentSwapResponses      Boolean @default(true)  // Réponses aux demandes d'échange
  assignmentSwapAdminActions   Boolean @default(true)  // Actions administratives sur les échanges
  contextualMessages           Boolean @default(true)  // Messages contextuels
  mentionsInMessages           Boolean @default(true)  // Mentions dans les messages
  planningUpdates              Boolean @default(true)  // Mises à jour du planning
  leaveRequestStatusChanges    Boolean @default(true)  // Changements de statut des demandes de congés
  openShifts                   Boolean @default(false) // Postes ouverts disponibles
  teamPlanningPublished        Boolean @default(true)  // Publication du planning d'équipe
  
  // Canaux de notification
  emailEnabled                 Boolean @default(true)  // Notifications par email
  inAppEnabled                 Boolean @default(true)  // Notifications dans l'application
  pushEnabled                  Boolean @default(false) // Notifications push (si implémentées)
  
  // Périodes de non-dérangement
  quietHoursEnabled            Boolean @default(false) // Activer les heures calmes
  quietHoursStart              String? @default("22:00") // Début des heures calmes (format HH:MM)
  quietHoursEnd                String? @default("08:00") // Fin des heures calmes (format HH:MM)
  quietHoursDays               String? // Jours avec heures calmes (format JSON ["MON", "TUE", ...])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId])
  @@map("notification_preferences")
}
