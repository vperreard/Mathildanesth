generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- NOUVELLES ÉNUMÉRATIONS ---
enum Period {
  MATIN
  APRES_MIDI
  JOURNEE_ENTIERE
  // NUIT // Optionnel pour plus tard
}

enum BlocPlanningStatus {
  DRAFT
  VALIDATION_REQUESTED
  VALIDATED
  MODIFIED_AFTER_VALIDATION
  LOCKED
  ARCHIVED
}

enum BlocStaffRole {
  MAR
  IADE
}

enum ConflictSeverity {
  WARNING
  ERROR
}

// --- NOUVEAUX MODÈLES POUR LES TRAMES DE PLANNING BLOC (isolés) ---
model BlocTramePlanning {
  id           Int                         @id @default(autoincrement())
  name         String                      @unique
  description  String?
  siteId       String?
  dateDebut    DateTime
  dateFin      DateTime?
  isActive     Boolean                     @default(true)
  affectations BlocAffectationHabituelle[]
  createdAt    DateTime                    @default(now())
  updatedAt    DateTime                    @updatedAt

  @@map("bloc_trame_plannings")
}

model BlocAffectationHabituelle {
  id                  Int               @id @default(autoincrement())
  blocTramePlanningId Int
  blocTramePlanning   BlocTramePlanning @relation(fields: [blocTramePlanningId], references: [id], onDelete: Cascade)

  userId       Int?
  user         User?    @relation(fields: [userId], references: [id])
  chirurgienId Int?
  surgeon      Surgeon? @relation(fields: [chirurgienId], references: [id])

  jourSemaine DayOfWeek
  periode     Period
  typeSemaine WeekType

  typeAffectation   String
  roleInAffectation String?

  operatingRoomId Int?
  specialiteChir  String?

  priorite    Int      @default(5)
  detailsJson Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("bloc_affectation_habituelles")
}

// --- NOUVEAUX MODÈLES SPÉCIFIQUES AU PLANNING DU BLOC OPÉRATOIRE V2 ---
model BlocDayPlanning {
  id     String             @id @default(uuid())
  date   DateTime
  siteId String
  site   Site               @relation(fields: [siteId], references: [id])
  status BlocPlanningStatus @default(DRAFT)

  assignments BlocRoomAssignment[]
  conflicts   BlocPlanningConflict[]

  lockedAt       DateTime?
  lockedByUserId Int?
  // lockedByUser   User? @relation(fields: [lockedByUserId], references: [id])

  validatedAt       DateTime?
  validatedByUserId Int?
  // validatedByUser User? @relation(fields: [validatedByUserId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([siteId, date])
  @@map("bloc_day_plannings")
}

model BlocRoomAssignment {
  id                String          @id @default(uuid())
  blocDayPlanningId String
  blocDayPlanning   BlocDayPlanning @relation(fields: [blocDayPlanningId], references: [id], onDelete: Cascade)

  operatingRoomId Int
  operatingRoom   OperatingRoom @relation(fields: [operatingRoomId], references: [id])
  period          Period

  chirurgienId Int?
  surgeon      Surgeon? @relation(fields: [chirurgienId], references: [id])

  expectedSpecialty String?

  staffAssignments BlocStaffAssignment[]

  sourceBlocTrameAffectationId Int?
  // sourceBlocTrameAffectation BlocAffectationHabituelle? @relation(fields: [sourceBlocTrameAffectationId], references: [id], onDelete: SetNull) 

  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bloc_room_assignments")
}

model BlocStaffAssignment {
  id                   String             @id @default(uuid())
  blocRoomAssignmentId String
  blocRoomAssignment   BlocRoomAssignment @relation(fields: [blocRoomAssignmentId], references: [id], onDelete: Cascade)

  userId Int
  user   User          @relation(fields: [userId], references: [id])
  role   BlocStaffRole

  isPrimaryAnesthetist Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bloc_staff_assignments")
}

model BlocPlanningConflict {
  id                String          @id @default(uuid())
  blocDayPlanningId String
  blocDayPlanning   BlocDayPlanning @relation(fields: [blocDayPlanningId], references: [id], onDelete: Cascade)

  relatedRoomAssignmentId  String?
  relatedStaffAssignmentId String?
  relatedUserId            Int?
  relatedSurgeonId         Int?

  type     String
  message  String
  severity ConflictSeverity

  isResolved       Boolean   @default(false)
  resolvedAt       DateTime?
  resolvedByUserId Int?
  resolvedByUser   User?     @relation("ResolvedBy", fields: [resolvedByUserId], references: [id], onDelete: SetNull)
  resolutionNotes  String?

  isForceResolved       Boolean   @default(false)
  forceResolvedAt       DateTime?
  forceResolvedByUserId Int?
  forceResolvedByUser   User?     @relation("ForcedBy", fields: [forceResolvedByUserId], references: [id], onDelete: SetNull)
  forceResolutionNotes  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bloc_planning_conflicts")
}

model User {
  id                            Int                         @id @default(autoincrement())
  nom                           String
  prenom                        String
  login                         String                      @unique
  email                         String                      @unique
  password                      String
  role                          Role                        @default(USER)
  professionalRole              ProfessionalRole
  tempsPartiel                  Boolean                     @default(false)
  pourcentageTempsPartiel       Float?
  dateEntree                    DateTime?
  dateSortie                    DateTime?
  actif                         Boolean                     @default(true)
  createdAt                     DateTime                    @default(now())
  updatedAt                     DateTime                    @updatedAt
  mustChangePassword            Boolean                     @default(false)
  phoneNumber                   String?
  alias                         String?
  workOnMonthType               WeekType?
  workPattern                   WorkPatternType             @default(FULL_TIME)
  joursTravaillesSemaineImpaire Json                        @default("[]")
  joursTravaillesSemainePaire   Json                        @default("[]")
  displayPreferences            Json?
  lastLogin                     DateTime?
  departmentId                  String?
  Absence                       Absence[]
  assignments                   Assignment[]
  dashboards                    Dashboard[]
  duties                        Duty[]
  loginLogs                     LoginLog[]
  createdNotifications          Notification[]              @relation("CreatedNotifications")
  notifications                 Notification[]              @relation("UserNotifications")
  onCalls                       OnCall[]
  createdRules                  Rule[]                      @relation("CreatedRules")
  updatedRules                  Rule[]                      @relation("UpdatedRules")
  tramesCreated                 TrameAffectation[]          @relation("CreatedTrames")
  auditLogs                     AuditLog[]
  leaveBalances                 LeaveBalance[]              @relation("UserLeaveBalances")
  approvedLeaves                Leave[]                     @relation("ApprovedLeaves")
  leaves                        Leave[]
  plannedAbsences               PlannedAbsence[]
  validatedAbsences             PlannedAbsence[]            @relation("ValidatedAbsences")
  approvedCarryOvers            QuotaCarryOver[]            @relation("ApprovedCarryOvers")
  quotaCarryOvers               QuotaCarryOver[]            @relation("UserQuotaCarryOvers")
  approvedTransfers             QuotaTransfer[]             @relation("ApprovedTransfers")
  quotaTransfers                QuotaTransfer[]             @relation("UserQuotaTransfers")
  regularAssignments            RegularAssignment[]
  surgeonProfile                Surgeon?
  calendarSettings              UserCalendarSettings?
  department                    Department?                 @relation(fields: [departmentId], references: [id])
  sites                         Site[]                      @relation("SiteUsers")
  blocStaffAssignments          BlocStaffAssignment[]
  blocPlanningConflictsResolved BlocPlanningConflict[]      @relation("ResolvedBy")
  blocPlanningConflictsForced   BlocPlanningConflict[]      @relation("ForcedBy")
  blocTrameAffectations         BlocAffectationHabituelle[]
  canSuperviseOphtalmo          Boolean                     @default(false)
  canSuperviseEndo              Boolean                     @default(false)

  CreatedIncompatibilities PersonnelIncompatibility[] @relation("CreatedIncompatibilities")
  incompatibilitiesAsUser1 PersonnelIncompatibility[] @relation("User1Incompatibilities")
  incompatibilitiesAsUser2 PersonnelIncompatibility[] @relation("User2Incompatibilities")

  @@map("users")
}

model Specialty {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  isPediatric Boolean      @default(false)
  assignments Assignment[]
  surgeons    Surgeon[]    @relation("SpecialtyToSurgeon")
}

model Surgeon {
  id              Int        @id @default(autoincrement())
  nom             String
  prenom          String
  email           String?    @unique
  phoneNumber     String?
  status          UserStatus @default(ACTIF)
  userId          Int?       @unique
  user            User?      @relation(fields: [userId], references: [id])
  googleSheetName String?

  specialties Specialty[] @relation("SpecialtyToSurgeon")
  sites       Site[]      @relation("SurgeonSites")

  plannedAbsences             PlannedAbsence[]
  preferences                 SurgeonPreference[]
  regularAssignments          RegularAssignment[]
  blocRoomAssignments         BlocRoomAssignment[] // Maintenu pour la rétrocompatibilité si utilisé ailleurs
  absences                    Absence[]
  blocTrameAffectations       BlocAffectationHabituelle[]
  assignments                 Assignment[]                @relation("SurgeonAssignments")
  // Relations pour PersonnelIncompatibility
  incompatibilitiesAsSurgeon1 PersonnelIncompatibility[]  @relation("Surgeon1Incompatibilities")
  incompatibilitiesAsSurgeon2 PersonnelIncompatibility[]  @relation("Surgeon2Incompatibilities")

  @@map("surgeons")
}

model SurgeonPreference {
  id        Int     @id @default(autoincrement())
  name      String
  value     String
  surgeonId Int
  surgeon   Surgeon @relation(fields: [surgeonId], references: [id])

  @@map("preferences")
}

model LoginLog {
  id        Int      @id @default(autoincrement())
  timestamp DateTime @default(now())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PlanningRule {
  id            Int      @id @default(autoincrement())
  category      String
  name          String
  description   String?
  isActive      Boolean  @default(true)
  priority      Int      @default(1)
  conditionJSON Json
  parameterJSON Json
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model OperatingRoom {
  id                  Int                  @id @default(autoincrement())
  name                String
  number              String               @unique
  sectorId            Int?
  colorCode           String?
  isActive            Boolean              @default(true)
  supervisionRules    Json
  type                RoomType             @default(STANDARD)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  displayOrder        Int                  @default(0)
  allowedSpecialties  String[]             @default([])
  blocRoomAssignments BlocRoomAssignment[]
  sector              OperatingSector?     @relation(fields: [sectorId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  Assignment          Assignment[]

  @@index([sectorId])
}

model Rule {
  id            String         @id @default(uuid())
  name          String
  description   String?
  type          RuleType
  priority      RulePriority   @default(WARNING)
  isActive      Boolean        @default(false)
  validFrom     DateTime
  validTo       DateTime?
  configuration Json
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  createdBy     Int
  updatedBy     Int?
  createdByUser User           @relation("CreatedRules", fields: [createdBy], references: [id])
  updatedByUser User?          @relation("UpdatedRules", fields: [updatedBy], references: [id])
  conflicts     RuleConflict[] @relation("RuleToConflict")
}

model RuleConflict {
  id                String       @id @default(uuid())
  description       String
  severity          RuleSeverity @default(WARNING)
  detectedAt        DateTime     @default(now())
  resolvedAt        DateTime?
  resolution        String?
  resolutionDetails String?
  rules             Rule[]       @relation("RuleToConflict")
}

model Location {
  id                 Int                 @id @default(autoincrement())
  name               String              @unique
  sector             String?
  isActive           Boolean             @default(true)
  assignments        Assignment[]
  duties             Duty[]
  onCalls            OnCall[]
  regularAssignments RegularAssignment[]
}

model LeaveTypeSetting {
  id               String   @id @default(cuid())
  code             String   @unique
  label            String
  description      String?
  rules            Json?
  isActive         Boolean  @default(true)
  isUserSelectable Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@map("leave_type_settings")
}

model Leave {
  id                 String      @id @default(cuid())
  userId             Int
  startDate          DateTime
  endDate            DateTime
  typeCode           String
  type               LeaveType
  status             LeaveStatus
  reason             String?
  comment            String?
  requestDate        DateTime    @default(now())
  approvalDate       DateTime?
  approvedById       Int?
  countedDays        Float
  calculationDetails Json?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  isRecurring        Boolean?    @default(false)
  parentId           String?
  recurrencePattern  Json?
  approvedBy         User?       @relation("ApprovedLeaves", fields: [approvedById], references: [id])
  parent             Leave?      @relation("RecurringLeaveOccurrences", fields: [parentId], references: [id])
  occurrences        Leave[]     @relation("RecurringLeaveOccurrences")
  user               User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([startDate, endDate])
  @@index([typeCode])
  @@index([parentId])
  @@map("leaves")
}

model Duty {
  id         Int       @id @default(autoincrement())
  userId     Int
  date       DateTime
  locationId Int?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  location   Location? @relation(fields: [locationId], references: [id])
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([date])
  @@index([locationId])
}

model OnCall {
  id         Int       @id @default(autoincrement())
  userId     Int
  startDate  DateTime
  endDate    DateTime
  locationId Int?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  location   Location? @relation(fields: [locationId], references: [id])
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([startDate])
  @@index([endDate])
  @@index([locationId])
}

model Assignment {
  id                  String             @id @default(uuid())
  date                DateTime
  userId              Int? // MAR ou IADE
  user                User?              @relation(fields: [userId], references: [id])
  chirurgien          String? // Nom du chirurgien (legacy ou si pas de modèle Surgeon lié)
  salle               String? // Nom de la salle (legacy ou si pas de modèle OperatingRoom lié)
  type                String // Ex: BLOC_OPERATION, CONSULTATION, GARDE_JOUR, GARDE_NUIT, ASTREINTE, REPOS_GARDE, FORMATION, CONGRES, MALADIE, MATERNITE, ABS_AUTORISEE, ABS_NON_AUTORISEE, FERIE
  statut              String? // Ex: PREVU, REALISE, ANNULE
  heureDebut          String? // Format HH:MM
  heureFin            String? // Format HH:MM
  notes               String?
  specialtyId         Int? // Pour lier à une spécialité
  specialty           Specialty?         @relation(fields: [specialtyId], references: [id])
  siteId              String? // Pour lier à un site
  site                Site?              @relation(fields: [siteId], references: [id])
  operatingRoomId     Int? // Pour lier à une salle d'opération spécifique
  operatingRoom       OperatingRoom?     @relation(fields: [operatingRoomId], references: [id])
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  blocDayPlanningId   String? // Ajout pour lier à BlocDayPlanning si nécessaire
  surgeonId           Int?
  surgeon             Surgeon?           @relation("SurgeonAssignments", fields: [surgeonId], references: [id], onDelete: Cascade)
  regularAssignmentId Int?
  regularAssignment   RegularAssignment? @relation("GeneratedFromRegular", fields: [regularAssignmentId], references: [id])
  Location            Location?          @relation(fields: [locationId], references: [id])
  locationId          Int?

  @@index([date])
  @@index([userId, date])
  @@index([siteId, date])
  @@map("assignments")
}

model OperatingSector {
  id           Int            @id @default(autoincrement())
  name         String         @unique
  colorCode    String?
  isActive     Boolean        @default(true)
  description  String?
  rules        Json?
  category     SectorCategory @default(STANDARD)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  siteId       String?
  displayOrder Int?
  rooms        OperatingRoom[]
  site         Site?          @relation(fields: [siteId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([siteId])
}

model UserCalendarSettings {
  id                 String   @id @default(cuid())
  userId             Int      @unique
  defaultView        String   @default("month")
  showWeekends       Boolean  @default(true)
  showHolidays       Boolean  @default(true)
  showRejectedLeaves Boolean  @default(false)
  colorScheme        String   @default("default")
  startWeekOn        String   @default("monday")
  timeFormat         String   @default("24h")
  notifications      Json     @default("{\"email\": true, \"sound\": false, \"browser\": true}")
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id])

  @@map("user_calendar_settings")
}

model ProfessionalRoleConfig {
  id                 String   @id
  code               String   @unique
  label              String
  description        String?
  isActive           Boolean  @default(true)
  displayPreferences Json?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model TeamConfiguration {
  id            String   @id @default(cuid())
  name          String
  description   String?
  isDefault     Boolean  @default(false)
  isActive      Boolean  @default(true)
  gardes        Json
  consultations Json
  bloc          Json
  conges        Json
  fatigue       Json?
  tempsPartiel  Json?
  iades         Json?
  remplacants   Json?
  preferences   Json?
  statistiques  Json?
  horaires      Json?
  affectations  Json?
  transitions   Json?
  equite        Json?
  alertes       Json?
  algorithme    Json?
  rapports      Json?
  audit         Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("team_configurations")
}

model RegularAssignment {
  id            Int               @id @default(autoincrement())
  trameId       String?
  userId        Int?
  surgeonId     Int?
  locationId    Int?
  siteId        String?
  weekType      WeekType          @default(ALL)
  active        Boolean           @default(true)
  configuration Json?
  type          String
  dayOfWeek     Int               @default(1)
  period        String
  assignments   Assignment[]      @relation("GeneratedFromRegular")
  location      Location?         @relation(fields: [locationId], references: [id])
  surgeon       Surgeon?          @relation(fields: [surgeonId], references: [id])
  trame         TrameAffectation? @relation("TrameAssignments", fields: [trameId], references: [id])
  user          User?             @relation(fields: [userId], references: [id])
  site          Site?             @relation(fields: [siteId], references: [id])

  @@index([userId])
  @@index([surgeonId])
  @@index([trameId])
  @@index([siteId])
  @@index([dayOfWeek, period, weekType])
  @@map("regular_assignments")
}

model TrameAffectation {
  id          String              @id @default(cuid())
  name        String
  description String?
  isActive    Boolean             @default(true)
  startDate   DateTime
  endDate     DateTime?
  createdBy   Int?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  user        User?               @relation("CreatedTrames", fields: [createdBy], references: [id])
  periods     TramePeriod[]
  assignments RegularAssignment[] @relation("TrameAssignments")
}

model TramePeriod {
  id          String            @id @default(uuid())
  name        String
  startTime   String
  endTime     String
  color       String
  isActive    Boolean           @default(true)
  isLocked    Boolean           @default(false)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  trameId     String
  assignments TrameAssignment[]
  trame       TrameAffectation  @relation(fields: [trameId], references: [id], onDelete: Cascade)
}

model TrameAssignment {
  id       String      @id @default(uuid())
  type     String
  name     String
  duration Int
  isActive Boolean     @default(true)
  periodId String
  period   TramePeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  posts    TramePost[]
}

model TramePost {
  id           String          @id @default(uuid())
  type         String
  name         String
  required     Boolean         @default(false)
  maxCount     Int             @default(1)
  minCount     Int             @default(0)
  assignmentId String
  assignment   TrameAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
}

model PlannedAbsence {
  id             Int           @id @default(autoincrement())
  userId         Int?
  surgeonId      Int?
  startDate      DateTime
  endDate        DateTime
  type           AbsenceType
  typeDetail     String?
  impactPlanning Boolean       @default(true)
  priority       Int           @default(5)
  comment        String?
  status         AbsenceStatus
  validatedById  Int?
  notify         Boolean       @default(false)
  importSource   String?
  documents      Json?         @default("[]")
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  surgeon        Surgeon?      @relation(fields: [surgeonId], references: [id])
  user           User?         @relation(fields: [userId], references: [id])
  validatedBy    User?         @relation("ValidatedAbsences", fields: [validatedById], references: [id])

  @@index([userId])
  @@index([surgeonId])
  @@index([startDate, endDate])
  @@index([type, status])
  @@map("planned_absences")
}

model Notification {
  id        Int      @id @default(autoincrement())
  type      String
  title     String
  message   String
  read      Boolean  @default(false)
  userId    Int
  createdBy Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  creator   User     @relation("CreatedNotifications", fields: [createdBy], references: [id])
  user      User     @relation("UserNotifications", fields: [userId], references: [id])

  @@index([userId])
  @@index([createdBy])
}

model Dashboard {
  id        String   @id @default(cuid())
  userId    Int
  name      String
  widgets   Json
  layout    String   @default("grid")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model Absence {
  id           String      @id @default(cuid())
  userId       Int?
  user         User?       @relation(fields: [userId], references: [id], onDelete: Cascade)
  startDate    DateTime
  endDate      DateTime
  type         LeaveType
  status       LeaveStatus
  reason       String?
  comment      String?
  requestDate  DateTime    @default(now())
  approvalDate DateTime?
  approvedById Int?
  chirurgienId Int?
  surgeon      Surgeon?    @relation(fields: [chirurgienId], references: [id])

  @@index([endDate])
  @@index([startDate])
  @@index([userId])
}

model LeaveBalance {
  id          String    @id @default(cuid())
  userId      Int
  leaveType   LeaveType
  year        Int
  initial     Float     @default(0)
  used        Float     @default(0)
  pending     Float     @default(0)
  remaining   Float     @default(0)
  lastUpdated DateTime  @default(now())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation("UserLeaveBalances", fields: [userId], references: [id])

  @@unique([userId, leaveType, year])
  @@map("leave_balances")
}

model QuotaTransferRule {
  id                    String    @id @default(cuid())
  fromType              LeaveType
  toType                LeaveType
  conversionRate        Float     @default(1.0)
  maxTransferDays       Float?
  maxTransferPercentage Float?
  requiresApproval      Boolean   @default(false)
  authorizedRoles       String[]  @default([])
  isActive              Boolean   @default(true)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([fromType, toType])
  @@map("quota_transfer_rules")
}

model QuotaTransfer {
  id               String    @id @default(cuid())
  userId           Int
  fromType         LeaveType
  toType           LeaveType
  amount           Float
  convertedAmount  Float
  reason           String
  transferDate     DateTime  @default(now())
  status           String    @default("APPROVED")
  requiresApproval Boolean   @default(false)
  approvedById     Int?
  approvalDate     DateTime?
  comments         String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  approvedBy       User?     @relation("ApprovedTransfers", fields: [approvedById], references: [id])
  user             User      @relation("UserQuotaTransfers", fields: [userId], references: [id])

  @@index([userId, fromType, toType])
  @@index([status])
  @@map("quota_transfers")
}

model QuotaCarryOverRule {
  id               String    @id @default(cuid())
  leaveType        LeaveType @unique
  ruleType         String    @default("PERCENTAGE")
  value            Float     @default(100.0)
  maxCarryOverDays Float?
  expirationDays   Int?
  requiresApproval Boolean   @default(false)
  authorizedRoles  String[]  @default([])
  isActive         Boolean   @default(true)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@map("quota_carry_over_rules")
}

model QuotaCarryOver {
  id               String    @id @default(cuid())
  userId           Int
  leaveType        LeaveType
  fromYear         Int
  toYear           Int
  amount           Float
  expiryDate       DateTime?
  status           String    @default("APPROVED")
  requiresApproval Boolean   @default(false)
  approvedById     Int?
  approvalDate     DateTime?
  reason           String?
  comments         String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  approvedBy       User?     @relation("ApprovedCarryOvers", fields: [approvedById], references: [id])
  user             User      @relation("UserQuotaCarryOvers", fields: [userId], references: [id])

  @@index([userId, leaveType])
  @@index([fromYear, toYear])
  @@index([status])
  @@map("quota_carry_overs")
}

model AuditLog {
  id         String   @id @default(cuid())
  action     String
  entityId   String
  entityType String
  userId     Int?
  details    String?
  timestamp  DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id])

  @@index([entityType, entityId])
  @@index([userId])
  @@index([timestamp])
  @@map("audit_logs")
}

model PublicHoliday {
  id          String   @id @default(cuid())
  date        DateTime @db.Date
  name        String
  description String?
  isNational  Boolean  @default(true)
  region      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([date, region])
  @@index([date])
  @@map("public_holidays")
}

model Department {
  id           String   @id @default(cuid())
  name         String
  description  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  contactEmail String?
  contactPhone String?
  isActive     Boolean  @default(true)
  location     String?
  users        User[]

  @@map("departments")
}

model Site {
  id                 String    @id @default(cuid())
  name               String    @unique
  description        String?
  isActive           Boolean   @default(true)
  displayOrder       Int?
  address            String?
  colorCode          String?             @default("#007bff")
  operatingSectors   OperatingSector[]
  users              User[]              @relation("SiteUsers")
  regularAssignments RegularAssignment[]
  surgeons           Surgeon[]           @relation("SurgeonSites")
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  blocDayPlannings   BlocDayPlanning[]
  Assignment         Assignment[]

  @@map("sites")
}

enum Role {
  ADMIN_TOTAL
  ADMIN_PARTIEL
  USER
}

enum UserStatus {
  ACTIF
  INACTIF
}

enum ProfessionalRole {
  MAR
  IADE
  SECRETAIRE
}

enum WorkPatternType {
  FULL_TIME
  ALTERNATING_WEEKS
  ALTERNATING_MONTHS
  SPECIFIC_DAYS
}

enum WeekType {
  EVEN
  ODD
  ALL
}

enum RuleType {
  LEAVE
  DUTY
  SUPERVISION
  ASSIGNMENT
  ON_CALL
}

enum RulePriority {
  LOW
  WARNING
  HIGH
  CRITICAL
}

enum RuleSeverity {
  ERROR
  WARNING
  INFO
}

enum RotationStrategy {
  ROUND_ROBIN
  LEAST_RECENTLY_ASSIGNED
  BALANCED_LOAD
}

enum LeaveType {
  ANNUAL
  RECOVERY
  TRAINING
  SICK
  MATERNITY
  SPECIAL
  UNPAID
  OTHER
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum DayPeriod {
  MORNING
  AFTERNOON
}

enum TrameType {
  BLOCK
  CONSULTATION
  DUTY
  ON_CALL
}

enum AbsenceType {
  LEAVE
  ILLNESS
  TRAINING
  OTHER
}

enum AbsenceStatus {
  REQUESTED
  VALIDATED
  REJECTED
}

model PersonnelIncompatibility {
  id         String   @id @default(cuid())
  // Personne 1 (peut être un User ou un Surgeon)
  user1Id    Int?
  user1      User?    @relation("User1Incompatibilities", fields: [user1Id], references: [id], onDelete: Cascade)
  surgeon1Id Int?
  surgeon1   Surgeon? @relation("Surgeon1Incompatibilities", fields: [surgeon1Id], references: [id], onDelete: Cascade)

  // Personne 2 (peut être un User ou un Surgeon)
  user2Id    Int?
  user2      User?    @relation("User2Incompatibilities", fields: [user2Id], references: [id], onDelete: Cascade)
  surgeon2Id Int?
  surgeon2   Surgeon? @relation("Surgeon2Incompatibilities", fields: [surgeon2Id], references: [id], onDelete: Cascade)

  type   IncompatibilityType
  reason String? // Motif optionnel

  startDate DateTime? // Période de validité
  endDate   DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdBy     Int? // ID de l'utilisateur qui a créé la règle
  createdByUser User?    @relation("CreatedIncompatibilities", fields: [createdBy], references: [id], onDelete: SetNull) // onDelete: SetNull pour ne pas supprimer l'incompatibilité si l'admin est supprimé
  // S'assurer qu'au moins un ID est fourni pour chaque personne (pas directement faisable avec des attributs simples, logique applicative)
  // Prévenir les incompatibilités avec soi-même (user1Id != user2Id si surgeon1Id et surgeon2Id sont null, etc.) -> logique applicative

  // Index pour les requêtes courantes
  @@index([user1Id, user2Id, type, startDate, endDate])
  @@index([surgeon1Id, surgeon2Id, type, startDate, endDate])
  @@index([user1Id, surgeon2Id, type, startDate, endDate])
  @@map("personnel_incompatibilities")
}

enum IncompatibilityType {
  BLOQUANT // Ne doivent jamais travailler ensemble sur la même vacation/salle
  PREFERENTIEL // À éviter si possible, génère un avertissement
}

enum SectorCategory {
  STANDARD
  HYPERASEPTIQUE
  OPHTALMOLOGIE
  ENDOSCOPIE
}

enum RoomType {
  STANDARD
  FIV
  CONSULTATION
}
