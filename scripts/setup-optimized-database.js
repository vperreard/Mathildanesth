#!/usr/bin/env node

/**
 * Script pour configurer la base de donn√©es avec optimisations performance
 */

const { PrismaClient } = require('@prisma/client');
const fs = require('fs');
const path = require('path');

const prisma = new PrismaClient({
    log: ['query', 'info', 'warn', 'error'],
});

async function setupOptimizedDatabase() {
    console.log('üöÄ Configuration de la base de donn√©es optimis√©e...');
    
    try {
        // 1. V√©rifier la connexion
        await prisma.$connect();
        console.log('‚úÖ Connexion √† la base de donn√©es √©tablie');
        
        // 2. Appliquer les migrations Prisma
        console.log('üì¶ Application des migrations Prisma...');
        const { spawn } = require('child_process');
        
        await new Promise((resolve, reject) => {
            const migrate = spawn('npx', ['prisma', 'migrate', 'dev'], {
                stdio: 'inherit',
                cwd: process.cwd()
            });
            
            migrate.on('close', (code) => {
                if (code === 0) {
                    resolve();
                } else {
                    reject(new Error(`Migration failed with code ${code}`));
                }
            });
        });
        
        console.log('‚úÖ Migrations Prisma appliqu√©es');
        
        // 3. Cr√©er les indexes de performance
        await createPerformanceIndexes();
        
        // 4. Configurer les param√®tres de performance
        await configurePerformanceSettings();
        
        // 5. Cr√©er des donn√©es de test optimis√©es si n√©cessaire
        await seedOptimizedTestData();
        
        console.log('üéâ Base de donn√©es optimis√©e configur√©e avec succ√®s !');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la configuration:', error);
        process.exit(1);
    } finally {
        await prisma.$disconnect();
    }
}

async function createPerformanceIndexes() {
    console.log('üèóÔ∏è Cr√©ation des indexes de performance...');
    
    const indexes = [
        // Index User.email (critique pour auth)
        'CREATE INDEX IF NOT EXISTS "User_email_idx" ON "User"("email");',
        
        // Indexes pour requ√™tes temporelles fr√©quentes
        'CREATE INDEX IF NOT EXISTS "User_createdAt_idx" ON "User"("createdAt");',
        'CREATE INDEX IF NOT EXISTS "User_actif_idx" ON "User"("actif");',
        
        // Si les tables existent, cr√©er d'autres indexes
        // Ces requ√™tes √©choueront silencieusement si les tables n'existent pas
        'CREATE INDEX IF NOT EXISTS "Leave_userId_status_idx" ON "Leave"("userId", "status");',
        'CREATE INDEX IF NOT EXISTS "Leave_startDate_endDate_idx" ON "Leave"("startDate", "endDate");',
        
        'CREATE INDEX IF NOT EXISTS "Assignment_userId_date_idx" ON "Assignment"("userId", "date");',
        'CREATE INDEX IF NOT EXISTS "Assignment_date_idx" ON "Assignment"("date");',
        
        'CREATE INDEX IF NOT EXISTS "Session_userId_idx" ON "Session"("userId");',
        'CREATE INDEX IF NOT EXISTS "Session_expires_idx" ON "Session"("expires");',
    ];
    
    for (const indexQuery of indexes) {
        try {
            await prisma.$executeRawUnsafe(indexQuery);
            console.log(`‚úÖ Index cr√©√©: ${indexQuery.substring(0, 50)}...`);
        } catch (error) {
            console.log(`‚ö†Ô∏è Index ignor√© (table inexistante): ${indexQuery.substring(0, 50)}...`);
        }
    }
    
    console.log('‚úÖ Indexes de performance cr√©√©s');
}

async function configurePerformanceSettings() {
    console.log('‚öôÔ∏è Configuration des param√®tres de performance...');
    
    try {
        // V√©rifier si on est sur PostgreSQL
        const result = await prisma.$queryRaw`SELECT version();`;
        const isPostgreSQL = result[0]?.version?.includes('PostgreSQL');
        
        if (isPostgreSQL) {
            console.log('üêò PostgreSQL d√©tect√©, optimisation...');
            
            // Param√®tres de performance PostgreSQL
            const postgresOptimizations = [
                // Augmenter les statistiques pour de meilleures requ√™tes
                "ALTER DATABASE mathildanesth SET default_statistics_target = 100;",
                
                // Optimiser les requ√™tes de jointure
                "ALTER DATABASE mathildanesth SET random_page_cost = 1.1;",
                
                // Cache plus agressif
                "ALTER DATABASE mathildanesth SET effective_cache_size = '256MB';",
            ];
            
            for (const optimization of postgresOptimizations) {
                try {
                    await prisma.$executeRawUnsafe(optimization);
                    console.log(`‚úÖ Param√®tre appliqu√©: ${optimization.substring(0, 50)}...`);
                } catch (error) {
                    console.log(`‚ö†Ô∏è Param√®tre ignor√©: ${error.message}`);
                }
            }
        } else {
            console.log('üìÑ SQLite d√©tect√©, optimisation...');
            
            // Param√®tres de performance SQLite
            const sqliteOptimizations = [
                "PRAGMA synchronous = NORMAL;",
                "PRAGMA cache_size = 10000;",
                "PRAGMA journal_mode = WAL;",
                "PRAGMA temp_store = memory;",
            ];
            
            for (const optimization of sqliteOptimizations) {
                try {
                    await prisma.$executeRawUnsafe(optimization);
                    console.log(`‚úÖ Param√®tre appliqu√©: ${optimization}`);
                } catch (error) {
                    console.log(`‚ö†Ô∏è Param√®tre ignor√©: ${error.message}`);
                }
            }
        }
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Impossible de d√©terminer le type de base de donn√©es:', error.message);
    }
    
    console.log('‚úÖ Param√®tres de performance configur√©s');
}

async function seedOptimizedTestData() {
    console.log('üå± Cr√©ation de donn√©es de test optimis√©es...');
    
    try {
        // V√©rifier s'il y a d√©j√† des utilisateurs
        const userCount = await prisma.user.count();
        
        if (userCount === 0) {
            console.log('üìù Cr√©ation des utilisateurs de test...');
            
            // Cr√©er quelques utilisateurs de test avec des patterns optimis√©s
            const testUsers = [
                {
                    email: 'admin@test.com',
                    nom: 'Admin',
                    prenom: 'Test',
                    password: '$2b$10$K8l.yZ5qPm9L3Q7mN2p8XeJ.ZvQ3kN4j8Lm2rOw1qA7sY6tU9rE8V',
                    role: 'ADMIN_TOTAL',
                    professionalRole: 'MAR',
                    actif: true,
                    login: 'admin'
                },
                {
                    email: 'medecin@test.com',
                    nom: 'Medecin',
                    prenom: 'Test',
                    password: '$2b$10$K8l.yZ5qPm9L3Q7mN2p8XeJ.ZvQ3kN4j8Lm2rOw1qA7sY6tU9rE8V',
                    role: 'USER',
                    professionalRole: 'MAR',
                    actif: true,
                    login: 'medecin'
                },
                {
                    email: 'iade@test.com',
                    nom: 'IADE',
                    prenom: 'Test',
                    password: '$2b$10$K8l.yZ5qPm9L3Q7mN2p8XeJ.ZvQ3kN4j8Lm2rOw1qA7sY6tU9rE8V',
                    role: 'USER',
                    professionalRole: 'IADE',
                    actif: true,
                    login: 'iade'
                }
            ];
            
            for (const user of testUsers) {
                try {
                    await prisma.user.create({ data: user });
                    console.log(`‚úÖ Utilisateur cr√©√©: ${user.email}`);
                } catch (error) {
                    console.log(`‚ö†Ô∏è Utilisateur ignor√©: ${user.email} (existe d√©j√†)`);
                }
            }
        } else {
            console.log(`‚ÑπÔ∏è ${userCount} utilisateurs existants d√©tect√©s, pas de seed n√©cessaire`);
        }
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Erreur lors du seed des donn√©es de test:', error.message);
    }
    
    console.log('‚úÖ Donn√©es de test optimis√©es cr√©√©es');
}

// Fonction pour mesurer les performances de la DB
async function benchmarkDatabase() {
    console.log('üìä Benchmark de la base de donn√©es...');
    
    const benchmarks = [];
    
    try {
        // Test 1: Requ√™te simple par email
        const start1 = Date.now();
        await prisma.user.findFirst({ where: { email: 'admin@test.com' } });
        const time1 = Date.now() - start1;
        benchmarks.push({ test: 'User by email', time: time1 });
        
        // Test 2: Count des utilisateurs
        const start2 = Date.now();
        await prisma.user.count();
        const time2 = Date.now() - start2;
        benchmarks.push({ test: 'User count', time: time2 });
        
        // Test 3: Requ√™te avec filtre
        const start3 = Date.now();
        await prisma.user.findMany({ where: { actif: true }, take: 10 });
        const time3 = Date.now() - start3;
        benchmarks.push({ test: 'Active users (limit 10)', time: time3 });
        
        console.log('üìà R√©sultats du benchmark:');
        benchmarks.forEach(b => {
            const status = b.time < 10 ? 'üü¢' : b.time < 50 ? 'üü°' : 'üî¥';
            console.log(`${status} ${b.test}: ${b.time}ms`);
        });
        
        const avgTime = benchmarks.reduce((sum, b) => sum + b.time, 0) / benchmarks.length;
        console.log(`üìä Temps moyen: ${avgTime.toFixed(2)}ms`);
        
        return benchmarks;
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Erreur lors du benchmark:', error.message);
        return [];
    }
}

// Interface CLI
if (require.main === module) {
    const command = process.argv[2] || 'setup';
    
    switch (command) {
        case 'setup':
            setupOptimizedDatabase();
            break;
        case 'benchmark':
            (async () => {
                await prisma.$connect();
                await benchmarkDatabase();
                await prisma.$disconnect();
            })();
            break;
        case 'indexes':
            (async () => {
                await prisma.$connect();
                await createPerformanceIndexes();
                await prisma.$disconnect();
            })();
            break;
        default:
            console.log('Usage: node setup-optimized-database.js [setup|benchmark|indexes]');
            process.exit(1);
    }
}

module.exports = {
    setupOptimizedDatabase,
    benchmarkDatabase,
    createPerformanceIndexes
};